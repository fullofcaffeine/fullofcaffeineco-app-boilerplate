{
"version":3,
"file":"hx.js",
"sourceRoot":"file:///",
"sources":["/home/fullofcaffeine/haxe/versions/4.0.0-rc.3/std/DateTools.hx","/home/fullofcaffeine/haxe/versions/4.0.0-rc.3/std/js/_std/EReg.hx","/home/fullofcaffeine/haxe/versions/4.0.0-rc.3/std/js/_std/HxOverrides.hx","/home/fullofcaffeine/haxe/versions/4.0.0-rc.3/std/js/_std/Reflect.hx","/home/fullofcaffeine/haxe/versions/4.0.0-rc.3/std/js/_std/Std.hx","/home/fullofcaffeine/haxe/versions/4.0.0-rc.3/std/StringBuf.hx","/home/fullofcaffeine/haxe/versions/4.0.0-rc.3/std/StringTools.hx","/home/fullofcaffeine/haxe/versions/4.0.0-rc.3/std/haxe/Timer.hx","/home/fullofcaffeine/haxe/versions/4.0.0-rc.3/std/js/_std/haxe/io/Bytes.hx","/home/fullofcaffeine/haxe/versions/4.0.0-rc.3/std/haxe/crypto/Base64.hx","/home/fullofcaffeine/haxe/versions/4.0.0-rc.3/std/haxe/crypto/BaseCode.hx","/home/fullofcaffeine/haxe/versions/4.0.0-rc.3/std/js/_std/haxe/ds/ObjectMap.hx","/home/fullofcaffeine/haxe/versions/4.0.0-rc.3/std/js/_std/haxe/ds/StringMap.hx","/home/fullofcaffeine/haxe/versions/4.0.0-rc.3/std/haxe/io/Eof.hx","/home/fullofcaffeine/haxe/versions/4.0.0-rc.3/std/haxe/io/Input.hx","/home/fullofcaffeine/haxe/versions/4.0.0-rc.3/std/haxe/io/Output.hx","/home/fullofcaffeine/haxe/haxe_libraries/http-status/1.3.1/haxelib/src/httpstatus/HttpStatusCode.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_http/0.8.2/git/13413e2f16cfe53fc8cd987928310729ee33156d/src/tink/http/Response.hx","/home/fullofcaffeine/haxe/haxe_libraries/http-status/1.3.1/haxelib/src/httpstatus/HttpStatusMessage.hx","/home/fullofcaffeine/haxe/versions/4.0.0-rc.3/std/js/Boot.hx","/home/fullofcaffeine/haxe/haxe_libraries/hxnodejs/6.9.1/github/666bc1fb9ebf9dcf77150dc4d0ed0be7d551197d/src/js/node/buffer/Buffer.hx","/home/fullofcaffeine/workspace/code/fullofcaffeineco-boilerplate/src/hx/server/Main.hx","/home/fullofcaffeine/workspace/code/fullofcaffeineco-boilerplate/src/hx/server/TinkAPI.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_web/0.1.5/git/c60d1278af68bd85111dd1c7a8e4cc3bfef61833/src/tink/web/macros/Routing.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_web/0.1.5/git/c60d1278af68bd85111dd1c7a8e4cc3bfef61833/src/tink/web/macros/Route.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_http/0.8.2/git/13413e2f16cfe53fc8cd987928310729ee33156d/src/tink/http/containers/NodeContainer.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Source.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_http/0.8.2/git/13413e2f16cfe53fc8cd987928310729ee33156d/src/tink/http/Header.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_http/0.8.2/git/13413e2f16cfe53fc8cd987928310729ee33156d/src/tink/http/Request.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_url/0.4.1/haxelib/src/tink/url/Query.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_url/0.4.1/haxelib/src/tink/Url.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_url/0.4.1/haxelib/src/tink/url/Host.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_url/0.4.1/haxelib/src/tink/url/Path.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_core/1.22.0/git/fa752b88f6757c18da92998aeab5523fe4f28853/src/tink/core/Named.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_streams/0.3.2/haxelib/src/tink/streams/Stream.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/nodejs/NodejsSource.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/nodejs/WrappedReadable.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_core/1.22.0/git/fa752b88f6757c18da92998aeab5523fe4f28853/src/tink/core/Future.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_core/1.22.0/git/fa752b88f6757c18da92998aeab5523fe4f28853/src/tink/core/Lazy.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_core/1.22.0/git/fa752b88f6757c18da92998aeab5523fe4f28853/src/tink/core/Callback.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_core/1.22.0/git/fa752b88f6757c18da92998aeab5523fe4f28853/src/tink/core/Error.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_http/0.8.2/git/13413e2f16cfe53fc8cd987928310729ee33156d/src/tink/http/Message.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Sink.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/nodejs/NodejsSink.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/nodejs/WrappedWritable.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_web/0.1.5/git/c60d1278af68bd85111dd1c7a8e4cc3bfef61833/src/tink/web/routing/Context.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_url/0.4.1/haxelib/src/tink/url/Portion.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_core/1.22.0/git/fa752b88f6757c18da92998aeab5523fe4f28853/src/tink/core/Promise.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_chunk/0.2.0/haxelib/src/tink/chunk/ChunkBase.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_chunk/0.2.0/haxelib/src/tink/chunk/ByteChunk.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_chunk/0.2.0/haxelib/src/tink/Chunk.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_http/0.8.2/git/13413e2f16cfe53fc8cd987928310729ee33156d/src/tink/http/Handler.hx","/home/fullofcaffeine/workspace/code/fullofcaffeineco-boilerplate/src/hx/server/externs/express/Route.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_stringly/0.3.1/haxelib/src/tink/Stringly.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_chunk/0.2.0/haxelib/src/tink/chunk/ChunkCursor.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_chunk/0.2.0/haxelib/src/tink/chunk/ChunkIterator.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_chunk/0.2.0/haxelib/src/tink/chunk/Seekable.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_core/1.22.0/git/fa752b88f6757c18da92998aeab5523fe4f28853/src/tink/core/Annex.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_core/1.22.0/git/fa752b88f6757c18da92998aeab5523fe4f28853/src/tink/core/Option.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_core/1.22.0/git/fa752b88f6757c18da92998aeab5523fe4f28853/src/tink/core/Outcome.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_core/1.22.0/git/fa752b88f6757c18da92998aeab5523fe4f28853/src/tink/core/Pair.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_core/1.22.0/git/fa752b88f6757c18da92998aeab5523fe4f28853/src/tink/core/Ref.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_core/1.22.0/git/fa752b88f6757c18da92998aeab5523fe4f28853/src/tink/core/Signal.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_http/0.8.2/git/13413e2f16cfe53fc8cd987928310729ee33156d/src/tink/http/Chunked.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/StreamParser.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_http/0.8.2/git/13413e2f16cfe53fc8cd987928310729ee33156d/src/tink/http/Method.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_http/0.8.2/git/13413e2f16cfe53fc8cd987928310729ee33156d/src/tink/http/StructuredBody.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/PipeOptions.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/PipeResult.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Worker.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/js/BlobSource.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/nodejs/WrappedBuffer.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/std/InputSource.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/std/OutputSink.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_json/0.9.0/haxelib/src/tink/json/Char.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_json/0.9.0/haxelib/src/tink/json/Representation.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_json/0.9.0/haxelib/src/tink/json/Writer.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_json/0.9.0/haxelib/src/tink/json/macros/Macro.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_json/0.9.0/haxelib/src/tink/json/macros/GenWriter.hx","/home/fullofcaffeine/workspace/code/fullofcaffeineco-boilerplate/src/hx/ApiResult.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_querystring/0.6.0/haxelib/src/tink/querystring/Pairs.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_streams/0.3.2/haxelib/src/tink/streams/IdealStream.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_streams/0.3.2/haxelib/src/tink/streams/RealStream.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_url/0.4.1/haxelib/src/tink/url/Auth.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_url/0.4.1/haxelib/src/tink/url/PortionArray.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_web/0.1.5/git/c60d1278af68bd85111dd1c7a8e4cc3bfef61833/src/tink/web/Response.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_web/0.1.5/git/c60d1278af68bd85111dd1c7a8e4cc3bfef61833/src/tink/web/forms/FormField.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_web/0.1.5/git/c60d1278af68bd85111dd1c7a8e4cc3bfef61833/src/tink/web/forms/FormFile.hx","/home/fullofcaffeine/haxe/haxe_libraries/tink_web/0.1.5/git/c60d1278af68bd85111dd1c7a8e4cc3bfef61833/src/tink/web/routing/Response.hx","/home/fullofcaffeine/haxe/versions/4.0.0-rc.3/std/js/_std/String.hx"],
"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/**\n\tThe DateTools class contains some extra functionalities for handling `Date`\n\tinstances and timestamps.\n\n\tIn the context of Haxe dates, a timestamp is defined as the number of\n\tmilliseconds elapsed since 1st January 1970.\n**/\nclass DateTools {\n\n\t#if php\n\t#elseif (neko && !(macro || interp))\n\tstatic var date_format = neko.Lib.load(\"std\",\"date_format\",2);\n\t#else\n\tstatic var DAY_SHORT_NAMES = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n\tstatic var DAY_NAMES = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n\tstatic var MONTH_SHORT_NAMES = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\tstatic var MONTH_NAMES = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n\n\tprivate static function __format_get( d : Date, e : String ) : String {\n\t\treturn switch( e ){\n\t\t\tcase \"%\":\n\t\t\t\t\"%\";\n\t\t\tcase \"a\":\n\t\t\t\tDAY_SHORT_NAMES[d.getDay()];\n\t\t\tcase \"A\":\n\t\t\t\tDAY_NAMES[d.getDay()];\n\t\t\tcase \"b\",\"h\":\n\t\t\t\tMONTH_SHORT_NAMES[d.getMonth()];\n\t\t\tcase \"B\":\n\t\t\t\tMONTH_NAMES[d.getMonth()];\n\t\t\tcase \"C\":\n\t\t\t\tuntyped StringTools.lpad(Std.string(Std.int(d.getFullYear()/100)),\"0\",2);\n\t\t\tcase \"d\":\n\t\t\t\tuntyped StringTools.lpad(Std.string(d.getDate()),\"0\",2);\n\t\t\tcase \"D\":\n\t\t\t\t__format(d,\"%m/%d/%y\");\n\t\t\tcase \"e\":\n\t\t\t\tuntyped Std.string(d.getDate());\n\t\t\tcase \"F\":\n\t\t\t\t__format(d,\"%Y-%m-%d\");\n\t\t\tcase \"H\",\"k\":\n\t\t\t\tuntyped StringTools.lpad(Std.string(d.getHours()),if( e == \"H\" ) \"0\" else \" \",2);\n\t\t\tcase \"I\",\"l\":\n\t\t\t\tvar hour = d.getHours()%12;\n\t\t\t\tuntyped StringTools.lpad(Std.string(hour == 0 ? 12 : hour),if( e == \"I\" ) \"0\" else \" \",2);\n\t\t\tcase \"m\":\n\t\t\t\tuntyped StringTools.lpad(Std.string(d.getMonth()+1),\"0\",2);\n\t\t\tcase \"M\":\n\t\t\t\tuntyped StringTools.lpad(Std.string(d.getMinutes()),\"0\",2);\n\t\t\tcase \"n\":\n\t\t\t\t\"\\n\";\n\t\t\tcase \"p\":\n\t\t\t\tuntyped if( d.getHours() > 11 ) \"PM\"; else \"AM\";\n\t\t\tcase \"r\":\n\t\t\t\t__format(d,\"%I:%M:%S %p\");\n\t\t\tcase \"R\":\n\t\t\t\t__format(d,\"%H:%M\");\n\t\t\tcase \"s\":\n\t\t\t\tStd.string(Std.int(d.getTime()/1000));\n\t\t\tcase \"S\":\n\t\t\t\tuntyped StringTools.lpad(Std.string(d.getSeconds()),\"0\",2);\n\t\t\tcase \"t\":\n\t\t\t\t\"\\t\";\n\t\t\tcase \"T\":\n\t\t\t\t__format(d,\"%H:%M:%S\");\n\t\t\tcase \"u\":\n\t\t\t\tuntyped{\n\t\t\t\t\tvar t = d.getDay();\n\t\t\t\t\tif( t == 0 ) \"7\"; else Std.string(t);\n\t\t\t\t}\n\t\t\tcase \"w\":\n\t\t\t\tuntyped Std.string(d.getDay());\n\t\t\tcase \"y\":\n\t\t\t\tuntyped StringTools.lpad(Std.string(d.getFullYear()%100),\"0\",2);\n\t\t\tcase \"Y\":\n\t\t\t\tuntyped Std.string(d.getFullYear());\n\t\t\tdefault:\n\t\t\t\tthrow \"Date.format %\"+e+\"- not implemented yet.\";\n\t\t}\n\t}\n\n\tprivate static function __format( d : Date, f : String ) : String {\n\t\tvar r = new StringBuf();\n\t\tvar p = 0;\n\t\twhile( true ){\n\t\t\tvar np = f.indexOf(\"%\", p);\n\t\t\tif( np < 0 )\n\t\t\t\tbreak;\n\n\t\t\tr.addSub(f,p,np-p);\n\t\t\tr.add( __format_get(d, f.substr(np+1,1) ) );\n\n\t\t\tp = np+2;\n\t\t}\n\t\tr.addSub(f,p,f.length-p);\n\t\treturn r.toString();\n\t}\n\t#end\n\n\t/**\n\t\tFormat the date `d` according to the format `f`. The format is\n\t\tcompatible with the `strftime` standard format, except that there is no\n\t\tsupport in Flash and JS for day and months names (due to lack of proper\n\t\tinternationalization API). On Haxe/Neko/Windows, some formats are not\n\t\tsupported.\n\n\t\t```haxe\n\t\tvar t = DateTools.format(Date.now(), \"%Y-%m-%d_%H:%M:%S\");\n\t\t// 2016-07-08_14:44:05\n\n\t\tvar t = DateTools.format(Date.now(), \"%r\");\n\t\t// 02:44:05 PM\n\n\t\tvar t = DateTools.format(Date.now(), \"%T\");\n\t\t// 14:44:05\n\n\t\tvar t = DateTools.format(Date.now(), \"%F\");\n\t\t// 2016-07-08\n\t\t```\n\t**/\n\tpublic static function format( d : Date, f : String ) : String {\n\t\t#if (neko && !(macro || interp))\n\t\t\treturn new String(untyped date_format(d.__t, f.__s));\n\t\t#elseif php\n\t\t\treturn php.Global.strftime(f, php.Syntax.int(@:privateAccess d.__t));\n\t\t#else\n\t\t\treturn __format(d,f);\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns the result of adding timestamp `t` to Date `d`.\n\n\t\tThis is a convenience function for calling\n\t\t`Date.fromTime(d.getTime() + t)`.\n\t**/\n\tpublic static inline function delta( d : Date, t : Float ) : Date {\n\t\treturn Date.fromTime( d.getTime() + t );\n\t}\n\n\tstatic var DAYS_OF_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n\t/**\n\t\tReturns the number of days in the month of Date `d`.\n\n\t\tThis method handles leap years.\n\t**/\n\tpublic static function getMonthDays( d : Date ) : Int {\n\t\tvar month = d.getMonth();\n\t\tvar year = d.getFullYear();\n\n\t\tif (month != 1)\n\t\t\treturn DAYS_OF_MONTH[month];\n\n\t\tvar isB = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n\t\treturn if (isB) 29 else 28;\n\t}\n\n\t/**\n\t\tConverts a number of seconds to a timestamp.\n\t**/\n\tpublic static inline function seconds( n : Float ) : Float {\n\t\treturn n * 1000.0;\n\t}\n\n\t/**\n\t\tConverts a number of minutes to a timestamp.\n\t**/\n\t#if as3 extern #end public static inline function minutes( n : Float ) : Float {\n\t\treturn n * 60.0 * 1000.0;\n\t}\n\n\t/**\n\t\tConverts a number of hours to a timestamp.\n\t**/\n\tpublic static inline function hours( n : Float ) : Float {\n\t\treturn n * 60.0 * 60.0 * 1000.0;\n\t}\n\n\t/**\n\t\tConverts a number of days to a timestamp.\n\t**/\n\tpublic static inline function days( n : Float ) : Float {\n\t\treturn n * 24.0 * 60.0 * 60.0 * 1000.0;\n\t}\n\n\t/**\n\t\tSeparate a date-time into several components\n\t**/\n\tpublic static function parse( t : Float ) {\n\t\tvar s = t / 1000;\n\t\tvar m = s / 60;\n\t\tvar h = m / 60;\n\t\treturn {\n\t\t\tms : t % 1000,\n\t\t\tseconds : Std.int(s % 60),\n\t\t\tminutes : Std.int(m % 60),\n\t\t\thours : Std.int(h % 24),\n\t\t\tdays : Std.int(h / 24),\n\t\t};\n\t}\n\n\t/**\n\t\tBuild a date-time from several components\n\t**/\n\tpublic static function make( o : { ms : Float, seconds : Int, minutes : Int, hours : Int, days : Int } ) {\n\t\treturn o.ms + 1000.0 * (o.seconds + 60.0 * (o.minutes + 60.0 * (o.hours + 24.0 * o.days)));\n\t}\n\n\t#if (js || flash || php || cpp || python)\n\t/**\n\t\tRetrieve Unix timestamp value from Date components. Takes same argument sequence as the Date constructor.\n\t**/\n\tpublic static #if (js || flash || php) inline #end function makeUtc(year : Int, month : Int, day : Int, hour : Int, min : Int, sec : Int ):Float {\n\t    #if (js || flash || python)\n\t\t   return untyped Date.UTC(year, month, day, hour, min, sec);\n\t\t#elseif php\n\t\t   return php.Global.gmmktime(hour, min, sec, month + 1, day, year) * 1000;\n\t\t#elseif cpp\n\t\t  return untyped __global__.__hxcpp_utc_date(year,month,day,hour,min,sec)*1000.0 ;\n\t\t#else\n\t\t\t//TODO\n\t\t   return 0.;\n\t\t#end\n\t}\n\t#end\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class EReg {\n\n\tvar r : HaxeRegExp;\n\n\tpublic inline function new( r : String, opt : String ) : Void {\n\t\tthis.r = new HaxeRegExp(r, opt.split(\"u\").join(\"\")); // 'u' (utf8) depends on page encoding\n\t}\n\n\tpublic function match( s : String ) : Bool {\n\t\tif( r.global ) r.lastIndex = 0;\n\t\tr.m = r.exec(s);\n\t\tr.s = s;\n\t\treturn (r.m != null);\n\t}\n\n\tpublic function matched( n : Int ) : String {\n\t\treturn if( r.m != null && n >= 0 && n < r.m.length ) r.m[n] else throw \"EReg::matched\";\n\t}\n\n\tpublic function matchedLeft() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn r.s.substr(0,r.m.index);\n\t}\n\n\tpublic function matchedRight() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\tvar sz = r.m.index+r.m[0].length;\n\t\treturn r.s.substr(sz,r.s.length-sz);\n\t}\n\n\tpublic function matchedPos() : { pos : Int, len : Int } {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn { pos : r.m.index, len : r.m[0].length };\n\t}\n\n\tpublic function matchSub( s : String, pos : Int, len : Int = -1):Bool {\n\t\treturn if (r.global) {\n\t\t\tr.lastIndex = pos;\n\t\t\tr.m = r.exec(len < 0 ? s : s.substr(0, pos + len));\n\t\t\tvar b = r.m != null;\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t}\n\t\t\tb;\n\t\t} else {\n\t\t\t// TODO: check some ^/$ related corner cases\n\t\t\tvar b = match( len < 0 ? s.substr(pos) : s.substr(pos,len) );\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t\tr.m.index += pos;\n\t\t\t}\n\t\t\tb;\n\t\t}\n\t}\n\n\tpublic function split( s : String ) : Array<String> {\n\t\t// we can't use directly s.split because it's ignoring the 'g' flag\n\t\tvar d = \"#__delim__#\";\n\t\treturn replace(s,d).split(d);\n\t}\n\n\tpublic inline function replace( s : String, by : String ) : String {\n\t\treturn (cast s).replace(r,by);\n\t}\n\n\tpublic function map( s : String, f : EReg -> String ) : String {\n\t\tvar offset = 0;\n\t\tvar buf = new StringBuf();\n\t\tdo {\n\t\t\tif (offset >= s.length)\n\t\t\t\tbreak;\n\t\t\telse if (!matchSub(s, offset)) {\n\t\t\t\tbuf.add(s.substr(offset));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar p = matchedPos();\n\t\t\tbuf.add(s.substr(offset, p.pos - offset));\n\t\t\tbuf.add(f(this));\n\t\t\tif (p.len == 0) {\n\t\t\t\tbuf.add(s.substr(p.pos, 1));\n\t\t\t\toffset = p.pos + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p.pos + p.len;\n\t\t} while (r.global);\n\t\tif (!r.global && offset > 0 && offset < s.length)\n\t\t\tbuf.add(s.substr(offset));\n\t\treturn buf.toString();\n\t}\n\n\tpublic static inline function escape( s : String ) : String {\n\t\treturn (cast s).replace(escapeRe, \"\\\\$&\");\n\t}\n\tstatic var escapeRe = new js.lib.RegExp(\"[.*+?^${}()|[\\\\]\\\\\\\\]\", \"g\");\n}\n\n@:native(\"RegExp\")\nprivate extern class HaxeRegExp extends js.lib.RegExp {\n\tvar m:js.lib.RegExp.RegExpMatch;\n\tvar s:String;\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\n\tstatic function dateStr( date :Date ) : String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear()\n\t\t\t+\"-\"+(if( m < 10 ) \"0\"+m else \"\"+m)\n\t\t\t+\"-\"+(if( d < 10 ) \"0\"+d else \"\"+d)\n\t\t\t+\" \"+(if( h < 10 ) \"0\"+h else \"\"+h)\n\t\t\t+\":\"+(if( mi < 10 ) \"0\"+mi else \"\"+mi)\n\t\t\t+\":\"+(if( s < 10 ) \"0\"+s else \"\"+s);\n\t}\n\n\tstatic function strDate( s : String ) : Date {\n\t\tswitch( s.length ) {\n\t\tcase 8: // hh:mm:ss\n\t\t\tvar k = s.split(\":\");\n\t\t\tvar d = js.Syntax.construct(Date);\n\t\t\t(cast d)[cast \"setTime\"](0);\n\t\t\t(cast d)[cast \"setUTCHours\"](k[0]);\n\t\t\t(cast d)[cast \"setUTCMinutes\"](k[1]);\n\t\t\t(cast d)[cast \"setUTCSeconds\"](k[2]);\n\t\t\treturn d;\n\t\tcase 10: // YYYY-MM-DD\n\t\t\tvar k = s.split(\"-\");\n\t\t\treturn new Date(cast k[0],(cast k[1]) - 1,cast k[2],0,0,0);\n\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\tvar k = s.split(\" \");\n\t\t\tvar y = k[0].split(\"-\");\n\t\t\tvar t = k[1].split(\":\");\n\t\t\treturn new Date(cast y[0],(cast y[1]) - 1,cast y[2],cast t[0],cast t[1],cast t[2]);\n\t\tdefault:\n\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\t@:pure\n\tstatic function cca( s : String, index : Int ) : Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif( x != x ) // fast isNaN\n\t\t\treturn js.Lib.undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\t@:pure\n\tstatic function substr( s : String, pos : Int, ?len : Int ) : String {\n\t\tif (len == null) {\n\t\t\tlen = s.length;\n\t\t} else if (len < 0) {\n\t\t\tif (pos == 0)\n\t\t\t\tlen = s.length + len;\n\t\t\telse\n\t\t\t\treturn \"\";\n\t\t}\n\n\t\t#if (js_es < 5)\n\t\tif (pos < 0) {\n\t\t\tpos = s.length + pos;\n\t\t\tif (pos < 0)\n\t\t\t\tpos = 0;\n\t\t}\n\t\t#end\n\n\t\treturn (cast s).substr(pos, len);\n\t}\n\n\t@:pure\n\tstatic function indexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0) i = 0;\n\t\t}\n\t\twhile (i < len)\n\t\t{\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@:pure\n\tstatic function lastIndexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0)\n\t\t{\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>( a : Array<T>, obj : T ) {\n\t\tvar i = a.indexOf(obj);\n\t\tif( i == -1 ) return false;\n\t\ta.splice(i,1);\n\t\treturn true;\n\t}\n\n\t@:pure\n\tstatic function iter<T>( a : Array<T> ) : Iterator<T> untyped {\n\t\treturn {\n\t\t\tcur : 0,\n\t\t\tarr : a,\n\t\t\thasNext : function() {\n\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t}\n\t\t};\n\t}\n\n\tstatic function __init__() untyped {\n#if (js_es < 5)\n\t\t__feature__('HxOverrides.indexOf', if( Array.prototype.indexOf ) __js__(\"HxOverrides\").indexOf = function(a,o,i) return Array.prototype.indexOf.call(a, o, i));\n\t\t__feature__('HxOverrides.lastIndexOf', if( Array.prototype.lastIndexOf ) __js__(\"HxOverrides\").lastIndexOf = function(a,o,i) return Array.prototype.lastIndexOf.call(a, o, i));\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class Reflect {\n\n\t@:pure\n\tpublic inline static function hasField( o : Dynamic, field : String ) : Bool {\n\t\treturn js.lib.Object.prototype.hasOwnProperty.call(o, field);\n\t}\n\n\t@:pure\n\tpublic static function field( o : Dynamic, field : String ) : Dynamic {\n\t\ttry return o[cast field] catch( e : Dynamic ) return null;\n\t}\n\n\tpublic inline static function setField( o : Dynamic, field : String, value : Dynamic ) : Void {\n\t\to[cast field] = value;\n\t}\n\n\tpublic static function getProperty( o : Dynamic, field : String ) : Dynamic untyped {\n\t\tvar tmp;\n\t\treturn if( o == null ) __define_feature__(\"Reflect.getProperty\",null) else if( o.__properties__ && (tmp=o.__properties__[\"get_\"+field]) ) o[tmp]() else o[field];\n\t}\n\n\tpublic static function setProperty( o : Dynamic, field : String, value : Dynamic ) : Void untyped {\n\t\tvar tmp;\n\t\tif( o.__properties__ && (tmp=o.__properties__[\"set_\"+field]) ) o[tmp](value) else o[field] = __define_feature__(\"Reflect.setProperty\",value);\n\t}\n\n\tpublic inline static function callMethod( o : Dynamic, func : haxe.Constraints.Function, args : Array<Dynamic> ) : Dynamic {\n\t\treturn (cast func : js.lib.Function).apply(o,args);\n\t}\n\n\tpublic static function fields( o : Dynamic ) : Array<String> {\n\t\tvar a = [];\n\t\tif (o != null) untyped {\n\t\t\tvar hasOwnProperty = js.lib.Object.prototype.hasOwnProperty;\n\t\t\t__js__(\"for( var f in o ) {\");\n\t\t\tif( f != \"__id__\" && f != \"hx__closures__\" && hasOwnProperty.call(o, f) ) a.push(f);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a;\n\t}\n\n\t@:access(js.Boot)\n\tpublic static function isFunction( f : Dynamic ) : Bool {\n\t\treturn js.Syntax.typeof(f) == \"function\" && !(js.Boot.isClass(f) || js.Boot.isEnum(f));\n\t}\n\n\tpublic static function compare<T>( a : T, b : T ) : Int {\n\t\treturn ( a == b ) ? 0 : (((cast a) > (cast b)) ? 1 : -1);\n\t}\n\n\tpublic static function compareMethods( f1 : Dynamic, f2 : Dynamic ) : Bool {\n\t\tif( f1 == f2 )\n\t\t\treturn true;\n\t\tif( !isFunction(f1) || !isFunction(f2) )\n\t\t\treturn false;\n\t\treturn f1.scope == f2.scope && f1.method == f2.method && f1.method != null;\n\t}\n\n\t@:access(js.Boot)\n\tpublic static function isObject( v : Dynamic ) : Bool {\n\t\tif( v == null )\n\t\t\treturn false;\n\t\tvar t = js.Syntax.typeof(v);\n\t\treturn (t == \"string\" || (t == \"object\" && v.__enum__ == null)) || (t == \"function\" && (js.Boot.isClass(v) || js.Boot.isEnum(v)) != null);\n\t}\n\n\tpublic static function isEnumValue( v : Dynamic ) : Bool {\n\t\treturn v != null && v.__enum__ != null;\n\t}\n\n\tpublic static function deleteField( o : Dynamic, field : String ) : Bool {\n\t\tif( !hasField(o,field) ) return false;\n\t\tjs.Syntax.delete(o, field);\n\t\treturn true;\n\t}\n\n\tpublic static function copy<T>( o : T ) : T {\n\t\tvar o2 : Dynamic = {};\n\t\tfor( f in Reflect.fields(o) )\n\t\t\tReflect.setField(o2,f,Reflect.field(o,f));\n\t\treturn o2;\n\t}\n\n\t@:overload(function( f : Array<Dynamic> -> Void ) : Dynamic {})\n\tpublic static function makeVarArgs( f : Array<Dynamic> -> Dynamic ) : Dynamic {\n\t\treturn function() {\n\t\t\tvar a = untyped Array.prototype.slice.call(__js__(\"arguments\"));\n\t\t\treturn f(a);\n\t\t};\n\t}\n\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nimport js.Boot;\n\n@:keepInit\n@:coreApi class Std {\n\n\tpublic static inline function is( v : Dynamic, t : Dynamic ) : Bool {\n\t\treturn @:privateAccess js.Boot.__instanceof(v,t);\n\t}\n\n\tpublic static inline function downcast<T:{},S:T>( value : T, c : Class<S> ) : S @:privateAccess {\n\t\treturn js.Syntax.instanceof(value, c) || Boot.__implements(value, c) ? cast value : null;\n\t}\n\n\t@:deprecated('Std.instance() is deprecated. Use Std.downcast() instead.')\n\tpublic static inline function instance<T:{},S:T>( value : T, c : Class<S> ) : S {\n\t\treturn downcast(value, c);\n\t}\n\n\t@:pure\n\tpublic static function string( s : Dynamic ) : String {\n\t\treturn @:privateAccess js.Boot.__string_rec(s,\"\");\n\t}\n\n\tpublic static inline function int( x : Float ) : Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\t@:pure\n\tpublic static function parseInt( x : String ) : Null<Int> {\n\t\tvar v = untyped __js__('parseInt({0}, {0} && {0}[0]==\"0\" && ({0}[1]==\"x\" || {0}[1]==\"X\") ? 16 : 10)', x);\n\t\tif( untyped __js__(\"isNaN\")(v) )\n\t\t\treturn null;\n\t\treturn cast v;\n\t}\n\n\tpublic static inline function parseFloat( x : String ) : Float {\n\t\treturn untyped __js__(\"parseFloat\")(x);\n\t}\n\n\tpublic static function random( x : Int ) : Int {\n\t\treturn x <= 0 ? 0 : Math.floor(Math.random()*x);\n\t}\n\n\tstatic function __init__() : Void untyped {\n\t\t__feature__(\"js.Boot.getClass\",String.prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"String\"] = String,String));\n\t\t__feature__(\"js.Boot.isClass\",String.__name__ = __feature__(\"Type.getClassName\",\"String\",true));\n\t\t__feature__(\"Type.resolveClass\",$hxClasses[\"Array\"] = Array);\n\t\t__feature__(\"js.Boot.isClass\",Array.__name__ = __feature__(\"Type.getClassName\",\"Array\",true));\n\t\t__feature__(\"Date.*\", {\n\t\t\t__feature__(\"js.Boot.getClass\",__js__('Date').prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"Date\"] = __js__('Date'),__js__('Date')));\n\t\t\t__feature__(\"js.Boot.isClass\",__js__('Date').__name__ = \"Date\");\n\t\t});\n\t\t__feature__(\"Int.*\",__js__('var Int = { };'));\n\t\t__feature__(\"Dynamic.*\",__js__('var Dynamic = { };'));\n\t\t__feature__(\"Float.*\",__js__('var Float = Number'));\n\t\t__feature__(\"Bool.*\",__js__('var Bool = Boolean'));\n\t\t__feature__(\"Class.*\",__js__('var Class = { };'));\n\t\t__feature__(\"Enum.*\",__js__('var Enum = { };'));\n\n#if (js_es < 5)\n\t\t__feature__(\"Array.map\",\n\t\t\tif( Array.prototype.map == null )\n\t\t\t\tArray.prototype.map = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length )\n\t\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n\t\t__feature__(\"Array.filter\",\n\t\t\tif( Array.prototype.filter == null )\n\t\t\t\tArray.prototype.filter = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length ) {\n\t\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\t\tif( f(e) ) a.push(e);\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tA String buffer is an efficient way to build a big string by appending small\n\telements together.\n\n\tIts cross-platform implementation uses String concatenation internally, but\n\tStringBuf may be optimized for different targets.\n\n\tUnlike String, an instance of StringBuf is not immutable in the sense that\n\tit can be passed as argument to functions which modify it by appending more\n\tvalues. However, the internal buffer cannot be modified.\n**/\nclass StringBuf {\n\n\tvar b:String;\n\n\t/**\n\t\tThe length of `this` StringBuf in characters.\n\t**/\n\tpublic var length(get,never) : Int;\n\n\t/**\n\t\tCreates a new StringBuf instance.\n\n\t\tThis may involve initialization of the internal buffer.\n\t**/\n\tpublic inline function new() {\n\t\tb = \"\";\n\t}\n\n\tinline function get_length() : Int {\n\t\treturn b.length;\n\t}\n\n\t/**\n\t\tAppends the representation of `x` to `this` StringBuf.\n\n\t\tThe exact representation of `x` may vary per platform. To get more\n\t\tconsistent behavior, this function should be called with\n\t\tStd.string(x).\n\n\t\tIf `x` is null, the String \"null\" is appended.\n\t**/\n\tpublic inline function add<T>( x : T ) : Void {\n\t\tb += x;\n\t}\n\n\t/**\n\t\tAppends the character identified by `c` to `this` StringBuf.\n\n\t\tIf `c` is negative or has another invalid value, the result is\n\t\tunspecified.\n\t**/\n\tpublic inline function addChar( c : Int ) : Void {\n\t\tb += String.fromCharCode(c);\n\t}\n\n\t/**\n\t\tAppends a substring of `s` to `this` StringBuf.\n\n\t\tThis function expects `pos` and `len` to describe a valid substring of\n\t\t`s`, or else the result is unspecified. To get more robust behavior,\n\t\t`this.add(s.substr(pos,len))` can be used instead.\n\n\t\tIf `s` or `pos` are null, the result is unspecified.\n\n\t\tIf `len` is omitted or null, the substring ranges from `pos` to the end\n\t\tof `s`.\n\t**/\n\tpublic inline function addSub( s : String, pos : Int, ?len : Int) : Void {\n\t\tb += (len == null ? s.substr(pos) : s.substr(pos, len));\n\t}\n\n\t/**\n\t\tReturns the content of `this` StringBuf as String.\n\n\t\tThe buffer is not emptied by this operation.\n\t**/\n\tpublic inline function toString() : String {\n\t\treturn b;\n\t}\n\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nimport haxe.iterators.StringIterator;\nimport haxe.iterators.StringKeyValueIterator;\n\n#if cpp\nusing cpp.NativeString;\n#end\n\n/**\n\tThis class provides advanced methods on Strings. It is ideally used with\n\t`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)\n\tto the `String` class.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\nclass StringTools {\n\t/**\n\t\tEncode an URL by using the standard format.\n\t**/\n\t#if (!java && !cpp && !lua && !eval) inline #end public static function urlEncode( s : String ) : String {\n\t\t#if flash\n\t\t\treturn untyped __global__[\"encodeURIComponent\"](s);\n\t\t#elseif neko\n\t\t\treturn untyped new String(_urlEncode(s.__s));\n\t\t#elseif js\n\t\t\treturn untyped encodeURIComponent(s);\n\t\t#elseif cpp\n\t\t\treturn untyped s.__URLEncode();\n\t\t#elseif java\n\t\t\treturn postProcessUrlEncode(java.net.URLEncoder.encode(s, \"UTF-8\"));\n\t\t#elseif cs\n\t\t\treturn untyped cs.system.Uri.EscapeDataString(s);\n\t\t#elseif python\n\t\t\treturn python.lib.urllib.Parse.quote(s, \"\");\n\t\t#elseif hl\n\t\t\tvar len = 0;\n\t\t\tvar b = @:privateAccess s.bytes.urlEncode(len);\n\t\t\treturn @:privateAccess String.__alloc__(b,len);\n\t\t#elseif lua\n\t\t\ts = lua.NativeStringTools.gsub(s, \"\\n\", \"\\r\\n\");\n\t\t\ts = lua.NativeStringTools.gsub(s, \"([^%w %-%_%.%~])\", function (c) {\n\t\t\t\treturn lua.NativeStringTools.format(\"%%%02X\", lua.NativeStringTools.byte(c) + '');\n\t\t\t});\n\t\t\ts = lua.NativeStringTools.gsub(s, \" \", \"+\");\n\t\t\treturn s;\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n#if java\n\tprivate static function postProcessUrlEncode( s : String ) : String {\n\t\tvar ret = new StringBuf();\n\t\tvar i = 0,\n\t\t    len = s.length;\n\t\twhile (i < len) {\n\t\t\tswitch(_charAt(s, i++)) {\n\t\t\tcase '+'.code:\n\t\t\t\tret.add('%20');\n\t\t\tcase '%'.code if (i <= len - 2):\n\t\t\t\tvar c1 = _charAt(s, i++),\n\t\t\t\t    c2 = _charAt(s, i++);\n\t\t\t\tswitch[c1, c2] {\n\t\t\t\tcase ['2'.code, '1'.code]:\n\t\t\t\t\tret.addChar('!'.code);\n\t\t\t\tcase ['2'.code, '7'.code]:\n\t\t\t\t\tret.addChar('\\''.code);\n\t\t\t\tcase ['2'.code, '8'.code]:\n\t\t\t\t\tret.addChar('('.code);\n\t\t\t\tcase ['2'.code, '9'.code]:\n\t\t\t\t\tret.addChar(')'.code);\n\t\t\t\tcase ['7'.code, 'E'.code] | ['7'.code, 'e'.code]:\n\t\t\t\t\tret.addChar('~'.code);\n\t\t\t\tcase _:\n\t\t\t\t\tret.addChar('%'.code);\n\t\t\t\t\tret.addChar(cast c1);\n\t\t\t\t\tret.addChar(cast c2);\n\t\t\t\t}\n\t\t\tcase var chr:\n\t\t\t\tret.addChar(cast chr);\n\t\t\t}\n\t\t}\n\t\treturn ret.toString();\n\t}\n#end\n\n\t/**\n\t\tDecode an URL using the standard format.\n\t**/\n\t#if (!java && !cpp && !lua && !eval) inline #end public static function urlDecode( s : String ) : String {\n\t\t#if flash\n\t\t\treturn untyped __global__[\"decodeURIComponent\"](s.split(\"+\").join(\" \"));\n\t\t#elseif neko\n\t\t\treturn untyped new String(_urlDecode(s.__s));\n\t\t#elseif js\n\t\t\treturn untyped decodeURIComponent(s.split(\"+\").join(\" \"));\n\t\t#elseif cpp\n\t\t\treturn untyped s.__URLDecode();\n\t\t#elseif java\n\t\t\ttry\n\t\t\t\treturn java.net.URLDecoder.decode(s, \"UTF-8\")\n\t\t\tcatch (e:Dynamic) throw e;\n\t\t#elseif cs\n\t\t\treturn untyped cs.system.Uri.UnescapeDataString(s);\n\t\t#elseif python\n\t\t\treturn python.lib.urllib.Parse.unquote(s);\n\t\t#elseif hl\n\t\t\tvar len = 0;\n\t\t\tvar b = @:privateAccess s.bytes.urlDecode(len);\n\t\t\treturn @:privateAccess String.__alloc__(b,len);\n\t\t#elseif lua\n\t\t\ts = lua.NativeStringTools.gsub (s, \"+\", \" \");\n\t\t\ts = lua.NativeStringTools.gsub (s, \"%%(%x%x)\",\n\t\t\t\tfunction(h) {return lua.NativeStringTools.char(lua.Lua.tonumber(h,16));});\n\t\t\ts = lua.NativeStringTools.gsub (s, \"\\r\\n\", \"\\n\");\n\t\t\treturn s;\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tEscapes HTML special characters of the string `s`.\n\n\t\tThe following replacements are made:\n\n\t\t- `&` becomes `&amp`;\n\t\t- `<` becomes `&lt`;\n\t\t- `>` becomes `&gt`;\n\n\t\tIf `quotes` is true, the following characters are also replaced:\n\n\t\t- `\"` becomes `&quot`;\n\t\t- `'` becomes `&#039`;\n\t**/\n\tpublic static function htmlEscape( s : String, ?quotes : Bool ) : String {\n\t\tvar buf = new StringBuf();\n\t\tfor (code in new haxe.iterators.StringIteratorUnicode(s)) {\n\t\t\tswitch (code) {\n\t\t\t\tcase '&'.code: buf.add(\"&amp;\");\n\t\t\t\tcase '<'.code: buf.add(\"&lt;\");\n\t\t\t\tcase '>'.code: buf.add(\"&gt;\");\n\t\t\t\tcase '\"'.code if (quotes): buf.add(\"&quot;\");\n\t\t\t\tcase '\\''.code if (quotes): buf.add(\"&#039;\");\n\t\t\t\tcase _: buf.addChar(code);\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\t/**\n\t\tUnescapes HTML special characters of the string `s`.\n\n\t\tThis is the inverse operation to htmlEscape, i.e. the following always\n\t\tholds: `htmlUnescape(htmlEscape(s)) == s`\n\n\t\tThe replacements follow:\n\n\t\t- `&amp;` becomes `&`\n\t\t- `&lt;` becomes `<`\n\t\t- `&gt;` becomes `>`\n\t\t- `&quot;` becomes `\"`\n\t\t- `&#039;` becomes `'`\n\t**/\n\tpublic static function htmlUnescape( s : String ) : String {\n\t\treturn s.split(\"&gt;\").join(\">\").split(\"&lt;\").join(\"<\").split(\"&quot;\").join('\"').split(\"&#039;\").join(\"'\").split(\"&amp;\").join(\"&\");\n\t}\n\n\t/**\n\t\tReturns `true` if `s` contains `value` and  `false` otherwise.\n\n\t\tWhen `value` is `null`, the result is unspecified.\n\t**/\n\tpublic static inline function contains(s : String, value : String) : Bool {\n\t\treturn s.indexOf(value) != -1;\n\t}\n\n\t/**\n\t\tTells if the string `s` starts with the string `start`.\n\n\t\tIf `start` is `null`, the result is unspecified.\n\n\t\tIf `start` is the empty String `\"\"`, the result is true.\n\t**/\n\tpublic static #if (cs || java || python) inline #end function startsWith( s : String, start : String ) : Bool {\n\t\t#if java\n\t\treturn (cast s : java.NativeString).startsWith(start);\n\t\t#elseif cs\n\t\treturn untyped s.StartsWith(start);\n\t\t#elseif cpp\n\t\tif (s.length<start.length)\n\t\t\treturn false;\n\t\tvar p0 = s.c_str();\n\t\tvar p1 = start.c_str();\n\t\tfor(i in 0...start.length)\n\t\t\tif ( p0.at(i) != p1.at(i) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t\t#elseif hl\n\t\treturn @:privateAccess (s.length >= start.length && s.bytes.compare(0,start.bytes,0,start.length<<1) == 0);\n\t\t#elseif python\n\t\treturn python.NativeStringTools.startswith(s, start);\n\t\t#else\n\t\treturn( s.length >= start.length && s.lastIndexOf(start, 0) == 0 );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the string `s` ends with the string `end`.\n\n\t\tIf `end` is `null`, the result is unspecified.\n\n\t\tIf `end` is the empty String `\"\"`, the result is true.\n\t**/\n\tpublic static #if (cs || java || python) inline #end function endsWith( s : String, end : String ) : Bool {\n\t\t#if java\n\t\treturn (cast s : java.NativeString).endsWith(end);\n\t\t#elseif cs\n\t\treturn untyped s.EndsWith(end);\n\t\t#elseif cpp\n\t\tif (s.length<end.length)\n\t\t\treturn false;\n\t\tvar p0 = s.c_str().add( s.length-end.length );\n\t\tvar p1 = end.c_str();\n\t\tfor(i in 0...end.length)\n\t\t\tif ( p0.at(i) != p1.at(i) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t\t#elseif hl\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn @:privateAccess (slen >= elen && s.bytes.compare((slen - elen) << 1, end.bytes, 0, elen << 1) == 0);\n\t\t#elseif python\n\t\treturn python.NativeStringTools.endswith(s, end);\n\t\t#else\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn( slen >= elen && s.indexOf(end, (slen - elen)) == (slen - elen) );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the character in the string `s` at position `pos` is a space.\n\n\t\tA character is considered to be a space character if its character code\n\t\tis 9,10,11,12,13 or 32.\n\n\t\tIf `s` is the empty String `\"\"`, or if pos is not a valid position within\n\t\t`s`, the result is false.\n\t**/\n\tpublic static function isSpace( s : String, pos : Int ) : Bool {\n\t\t#if (python || lua)\n\t\tif (s.length == 0 || pos < 0 || pos >= s.length) return false;\n\t\t#end\n\t\tvar c = s.charCodeAt( pos );\n\t\treturn (c > 8 && c < 14) || c == 32;\n\t}\n\n\t/**\n\t\tRemoves leading space characters of `s`.\n\n\t\tThis function internally calls `isSpace()` to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String `\"\"` or consists only of space characters, the\n\t\tresult is the empty String `\"\"`.\n\t**/\n\tpublic #if cs inline #end static function ltrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimStart();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,r) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 )\n\t\t\treturn s.substr(r, l-r);\n\t\telse\n\t\t\treturn s;\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves trailing space characters of `s`.\n\n\t\tThis function internally calls `isSpace()` to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String `\"\"` or consists only of space characters, the\n\t\tresult is the empty String `\"\"`.\n\t**/\n\tpublic #if cs inline #end static function rtrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimEnd();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,l-r-1) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 ){\n\t\t\treturn s.substr(0, l-r);\n\t\t}else{\n\t\t\treturn s;\n\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves leading and trailing space characters of `s`.\n\n\t\tThis is a convenience function for `ltrim(rtrim(s))`.\n\t**/\n\tpublic #if (cs || java) inline #end static function trim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.Trim();\n\t\t#elseif java\n\t\treturn (cast s : java.NativeString).trim();\n\t\t#else\n\t\treturn ltrim(rtrim(s));\n\t\t#end\n\t}\n\n\t/**\n\t\tConcatenates `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String `\"\"` or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function lpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\tvar buf = new StringBuf();\n\t\tl -= s.length;\n\t\twhile (buf.length < l) {\n\t\t\tbuf.add(c);\n\t\t}\n\t\tbuf.add(s);\n\t\treturn buf.toString();\n\t}\n\n\t/**\n\t\tAppends `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String `\"\"` or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function rpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\tvar buf = new StringBuf();\n\t\tbuf.add(s);\n\t\twhile (buf.length < l) {\n\t\t\tbuf.add(c);\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\t/**\n\t\tReplace all occurrences of the String `sub` in the String `s` by the\n\t\tString `by`.\n\n\t\tIf `sub` is the empty String `\"\"`, `by` is inserted after each character\n\t\tof `s` except the last one. If `by` is also the empty String `\"\"`, `s`\n\t\tremains unchanged.\n\n\t\tIf `sub` or `by` are null, the result is unspecified.\n\t**/\n\tpublic static function replace( s : String, sub : String, by : String ) : String {\n\t\t#if java\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn (cast s : java.NativeString).replace(sub, by);\n\t\t#elseif cs\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.Replace(sub, by);\n\t\t#else\n\t\treturn s.split(sub).join(by);\n\t\t#end\n\t}\n\n\t/**\n\t\tEncodes `n` into a hexadecimal representation.\n\n\t\tIf `digits` is specified, the resulting String is padded with \"0\" until\n\t\tits `length` equals `digits`.\n\t**/\n\tpublic static function hex( n : Int, ?digits : Int ) {\n\t\t#if flash\n\t\t\tvar n : UInt = n;\n\t\t\tvar s : String = untyped n.toString(16);\n\t\t\ts = s.toUpperCase();\n\t\t#else\n\t\t\tvar s = \"\";\n\t\t\tvar hexChars = \"0123456789ABCDEF\";\n\t\t\tdo {\n\t\t\t\ts = hexChars.charAt(n&15) + s;\n\t\t\t\tn >>>= 4;\n\t\t\t} while( n > 0 );\n\t\t#end\n\t\t#if python\n\t\tif (digits != null && s.length < digits) {\n\t\t\tvar diff = digits - s.length;\n\t\t\tfor (_ in 0...diff) {\n\t\t\t\ts = \"0\" + s;\n\t\t\t}\n\t\t}\n\t\t#else\n\t\tif( digits != null )\n\t\t\twhile( s.length < digits )\n\t\t\t\ts = \"0\"+s;\n\t\t#end\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReturns the character code at position `index` of String `s`, or an\n\t\tend-of-file indicator at if `position` equals `s.length`.\n\n\t\tThis method is faster than `String.charCodeAt()` on some platforms, but\n\t\tthe result is unspecified if `index` is negative or greater than\n\t\t`s.length`.\n\n\t\tEnd of file status can be checked by calling `StringTools.isEof()` with\n\t\tthe returned value as argument.\n\n\t\tThis operation is not guaranteed to work if `s` contains the `\\0`\n\t\tcharacter.\n\t**/\n\tpublic static #if !eval inline #end function fastCodeAt( s : String, index : Int ) : Int {\n\t\t#if neko\n\t\treturn untyped __dollar__sget(s.__s, index);\n\t\t#elseif cpp\n\t\treturn untyped s.cca(index);\n\t\t#elseif flash\n\t\treturn untyped s.cca(index);\n\t\t#elseif java\n\t\treturn ( index < s.length ) ? cast(_charAt(s, index), Int) : -1;\n\t\t#elseif cs\n\t\treturn ( cast(index, UInt) < s.length ) ? cast(s[index], Int) : -1;\n\t\t#elseif js\n\t\treturn (cast s).charCodeAt(index);\n\t\t#elseif python\n\t\treturn if (index >= s.length) -1 else python.internal.UBuiltins.ord(python.Syntax.arrayAccess(s, index));\n\t\t#elseif hl\n\t\treturn @:privateAccess s.bytes.getUI16(index << 1);\n\t\t#elseif lua\n\t\t\t#if lua_vanilla\n\t\t\treturn lua.NativeStringTools.byte(s,index+1);\n\t\t\t#else\n\t\t\treturn lua.lib.luautf8.Utf8.byte(s,index+1);\n\t\t\t#end\n\t\t#else\n\t\treturn untyped s.cca(index);\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns an iterator of the char codes.\n\n\t\tNote that char codes may differ across platforms because of different\n\t\tinternal encoding of strings in different runtimes.\n\t\tFor the consistent cross-platform UTF8 char codes see `haxe.iterators.StringIteratorUnicode`.\n\t**/\n\tpublic static inline function iterator( s : String ) : StringIterator {\n\t\treturn new StringIterator(s);\n\t}\n\n\t/**\n\t\tReturns an iterator of the char indexes and codes.\n\n\t\tNote that char codes may differ across platforms because of different\n\t\tinternal encoding of strings in different of runtimes.\n\t\tFor the consistent cross-platform UTF8 char codes see `haxe.iterators.StringKeyValueIteratorUnicode`.\n\t**/\n\tpublic static inline function keyValueIterator( s : String ) : StringKeyValueIterator {\n\t\treturn new StringKeyValueIterator(s);\n\t}\n\n\t/**\n\t\tTells if `c` represents the end-of-file (EOF) character.\n\t**/\n\t@:noUsing public static inline function isEof( c : Int ) : Bool {\n\t\t#if (flash || cpp || hl)\n\t\treturn c == 0;\n\t\t#elseif js\n\t\treturn c != c; // fast NaN\n\t\t#elseif (neko || lua || eval)\n\t\treturn c == null;\n\t\t#elseif (cs || java || python)\n\t\treturn c == -1;\n\t\t#else\n\t\treturn false;\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a String that can be used as a single command line argument\n\t\ton Unix.\n\t\tThe input will be quoted, or escaped if necessary.\n\t**/\n\t@:noCompletion\n\t@:deprecated('StringTools.quoteUnixArg() is deprecated. Use haxe.SysTools.quoteUnixArg() instead.')\n\tpublic static function quoteUnixArg(argument:String):String {\n\t\treturn inline haxe.SysTools.quoteUnixArg(argument);\n\t}\n\n\t/**\n\t\tCharacter codes of the characters that will be escaped by `quoteWinArg(_, true)`.\n\t**/\n\t@:noCompletion\n\t@:deprecated('StringTools.winMetaCharacters is deprecated. Use haxe.SysTools.winMetaCharacters instead.')\n\tpublic static var winMetaCharacters:Array<Int> = cast haxe.SysTools.winMetaCharacters;\n\n\t/**\n\t\tReturns a String that can be used as a single command line argument\n\t\ton Windows.\n\t\tThe input will be quoted, or escaped if necessary, such that the output\n\t\twill be parsed as a single argument using the rule specified in\n\t\thttp://msdn.microsoft.com/en-us/library/ms880421\n\n\t\tExamples:\n\t\t```haxe\n\t\tquoteWinArg(\"abc\") == \"abc\";\n\t\tquoteWinArg(\"ab c\") == '\"ab c\"';\n\t\t```\n\t**/\n\t@:noCompletion\n\t@:deprecated('StringTools.quoteWinArg() is deprecated. Use haxe.SysTools.quoteWinArg() instead.')\n\tpublic static function quoteWinArg(argument:String, escapeMetaCharacters:Bool):String {\n\t\treturn inline haxe.SysTools.quoteWinArg(argument, escapeMetaCharacters);\n\t}\n\n\t#if java\n\tprivate static inline function _charAt(str:String, idx:Int):java.StdTypes.Char16 return (cast str : java.NativeString).charAt(idx);\n\t#end\n\n\t#if neko\n\tprivate static var _urlEncode = neko.Lib.load(\"std\",\"url_encode\",1);\n\tprivate static var _urlDecode = neko.Lib.load(\"std\",\"url_decode\",1);\n\t#end\n\n\t#if utf16\n\tstatic inline var MIN_SURROGATE_CODE_POINT = 65536;\n\tstatic inline function utf16CodePointAt(s:String, index:Int):Int {\n\t\tvar c = StringTools.fastCodeAt(s, index);\n\t\tif (c >= 0xD800 && c <= 0xDBFF) {\n\t\t\tc = ((c -0xD7C0) << 10) | (StringTools.fastCodeAt(s, index + 1) & 0x3FF);\n\t\t}\n\t\treturn c;\n\t}\n\t#end\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tThe Timer class allows you to create asynchronous timers on platforms that\n\tsupport events.\n\n\tThe intended usage is to create an instance of the Timer class with a given\n\tinterval, set its run() method to a custom function to be invoked and\n\teventually call stop() to stop the Timer.\n\n\tNote that a running Timer may or may not prevent the program to exit\n\tautomatically when main() returns.\n\n\tIt is also possible to extend this class and override its run() method in\n\tthe child class.\n**/\nclass Timer {\n\n\t#if (flash || js)\n\t\tprivate var id : Null<Int>;\n\t#elseif java\n\t\tprivate var timer : java.util.Timer;\n\t\tprivate var task : java.util.TimerTask;\n\t#else\n\t\tprivate var event : MainLoop.MainEvent;\n\t#end\n\n\t/**\n\t\tCreates a new timer that will run every `time_ms` milliseconds.\n\n\t\tAfter creating the Timer instance, it calls `this.run` repeatedly,\n\t\twith delays of `time_ms` milliseconds, until `this.stop` is called.\n\n\t\tThe first invocation occurs after `time_ms` milliseconds, not\n\t\timmediately.\n\n\t\tThe accuracy of this may be platform-dependent.\n\t**/\n\tpublic function new( time_ms : Int ){\n\t\t#if flash\n\t\t\tvar me = this;\n\t\t\tid = untyped __global__[\"flash.utils.setInterval\"](function() { me.run(); },time_ms);\n\t\t#elseif js\n\t\t\tvar me = this;\n\t\t\tid = untyped setInterval(function() me.run(),time_ms);\n\t\t#elseif java\n\t\t\ttimer = new java.util.Timer();\n\t\t\ttimer.scheduleAtFixedRate(task = new TimerTask(this), haxe.Int64.ofInt(time_ms), haxe.Int64.ofInt(time_ms));\n\t\t#else\n\t\t\tvar dt = time_ms / 1000;\n\t\t\tevent = MainLoop.add(function() {\n\t\t\t\t@:privateAccess event.nextRun += dt;\n\t\t\t\trun();\n\t\t\t});\n\t\t\tevent.delay(dt);\n\t\t#end\n\t}\n\n\t/**\n\t\tStops `this` Timer.\n\n\t\tAfter calling this method, no additional invocations of `this.run`\n\t\twill occur.\n\n\t\tIt is not possible to restart `this` Timer once stopped.\n\t**/\n\tpublic function stop() {\n\t\t#if (flash || js)\n\t\t\tif( id == null )\n\t\t\t\treturn;\n\t\t\t#if flash\n\t\t\t\tuntyped __global__[\"flash.utils.clearInterval\"](id);\n\t\t\t#elseif js\n\t\t\t\tuntyped clearInterval(id);\n\t\t\t#end\n\t\t\tid = null;\n\t\t#elseif java\n\t\t\tif(timer != null) {\n\t\t\t\ttimer.cancel();\n\t\t\t\ttimer = null;\n\t\t\t}\n\t\t\ttask = null;\n\t\t#else\n\t\t\tif( event != null ) {\n\t\t\t\tevent.stop();\n\t\t\t\tevent = null;\n\t\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tThis method is invoked repeatedly on `this` Timer.\n\n\t\tIt can be overridden in a subclass, or rebound directly to a custom\n\t\tfunction:\n\t\t\tvar timer = new haxe.Timer(1000); // 1000ms delay\n\t\t\ttimer.run = function() { ... }\n\n\t\tOnce bound, it can still be rebound to different functions until `this`\n\t\tTimer is stopped through a call to `this.stop`.\n\t**/\n\tpublic dynamic function run() {\n\n\t}\n\n\t/**\n\t\tInvokes `f` after `time_ms` milliseconds.\n\n\t\tThis is a convenience function for creating a new Timer instance with\n\t\t`time_ms` as argument, binding its run() method to `f` and then stopping\n\t\t`this` Timer upon the first invocation.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function delay( f : Void -> Void, time_ms : Int ) {\n\t\tvar t = new haxe.Timer(time_ms);\n\t\tt.run = function() {\n\t\t\tt.stop();\n\t\t\tf();\n\t\t};\n\t\treturn t;\n\t}\n\n\t/**\n\t\tMeasures the time it takes to execute `f`, in seconds with fractions.\n\n\t\tThis is a convenience function for calculating the difference between\n\t\tTimer.stamp() before and after the invocation of `f`.\n\n\t\tThe difference is passed as argument to Log.trace(), with \"s\" appended\n\t\tto denote the unit. The optional `pos` argument is passed through.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function measure<T>( f : Void -> T, ?pos : PosInfos ) : T {\n\t\tvar t0 = stamp();\n\t\tvar r = f();\n\t\tLog.trace((stamp() - t0) + \"s\", pos);\n\t\treturn r;\n\t}\n\n\t/**\n\t\tReturns a timestamp, in seconds with fractions.\n\n\t\tThe value itself might differ depending on platforms, only differences\n\t\tbetween two values make sense.\n\t**/\n\tpublic static inline function stamp() : Float {\n\t\t#if flash\n\t\t\treturn flash.Lib.getTimer() / 1000;\n\t\t#elseif (neko || php)\n\t\t\treturn Sys.time();\n\t\t#elseif js\n\t\t\treturn js.lib.Date.now() / 1000;\n\t\t#elseif cpp\n\t\t\treturn untyped __global__.__time_stamp();\n\t\t#elseif python\n\t\t\treturn Sys.cpuTime();\n\t\t#elseif sys\n\t\t\treturn Sys.time();\n\n\t\t#else\n\t\t\treturn 0;\n\t\t#end\n\t}\n\n}\n\n#if java\n@:nativeGen\nprivate class TimerTask extends java.util.TimerTask {\n\tvar timer:Timer;\n\tpublic function new(timer:Timer):Void {\n\t\tsuper();\n\t\tthis.timer = timer;\n\t}\n\n\t@:overload override public function run():Void {\n\t\ttimer.run();\n\t}\n}\n#end\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.io;\n\n@:coreApi\nclass Bytes {\n\n\tpublic var length(default,null) : Int;\n\tvar b : js.lib.Uint8Array;\n\tvar data : js.lib.DataView;\n\n\tfunction new(data:BytesData) {\n\t\tthis.length = data.byteLength;\n\t\tthis.b = new js.lib.Uint8Array(data);\n\t\tuntyped {\n\t\t\tb.bufferValue = data; // some impl does not return the same instance in .buffer\n\t\t\tdata.hxBytes = this;\n\t\t\tdata.bytes = this.b;\n\t\t}\n\t}\n\n\tpublic inline function get( pos : Int ) : Int {\n\t\treturn b[pos];\n\t}\n\n\tpublic inline function set( pos : Int, v : Int ) : Void {\n\t\tb[pos] = v;\n\t}\n\n\tpublic function blit( pos : Int, src : Bytes, srcpos : Int, len : Int ) : Void {\n\t\tif( pos < 0 || srcpos < 0 || len < 0 || pos + len > length || srcpos + len > src.length ) throw Error.OutsideBounds;\n\t\tif( srcpos == 0 && len == src.b.byteLength )\n\t\t\tb.set(src.b,pos);\n\t\telse\n\t\t\tb.set(src.b.subarray(srcpos,srcpos+len),pos);\n\t}\n\n\tpublic function fill( pos : Int, len : Int, value : Int ) : Void {\n\t\tfor( i in 0...len )\n\t\t\tset(pos++, value);\n\t}\n\n\tpublic function sub( pos : Int, len : Int ) : Bytes {\n\t\tif( pos < 0 || len < 0 || pos + len > length ) throw Error.OutsideBounds;\n\t\treturn new Bytes(b.buffer.slice(pos+b.byteOffset,pos+b.byteOffset+len));\n\t}\n\n\tpublic function compare( other : Bytes ) : Int {\n\t\tvar b1 = b;\n\t\tvar b2 = other.b;\n\t\tvar len = (length < other.length) ? length : other.length;\n\t\tfor( i in 0...len )\n\t\t\tif( b1[i] != b2[i] )\n\t\t\t\treturn b1[i] - b2[i];\n\t\treturn length - other.length;\n\t}\n\n\tinline function initData() : Void {\n\t\tif( data == null ) data = new js.lib.DataView(b.buffer, b.byteOffset, b.byteLength);\n\t}\n\n\tpublic function getDouble( pos : Int ) : Float {\n\t\tinitData();\n\t\treturn data.getFloat64(pos, true);\n\t}\n\n\tpublic function getFloat( pos : Int ) : Float {\n\t\tinitData();\n\t\treturn data.getFloat32(pos, true);\n\t}\n\n\tpublic function setDouble( pos : Int, v : Float ) : Void {\n\t\tinitData();\n\t\tdata.setFloat64(pos, v, true);\n\t}\n\n\tpublic function setFloat( pos : Int, v : Float ) : Void {\n\t\tinitData();\n\t\tdata.setFloat32(pos, v, true);\n\t}\n\n\tpublic function getUInt16( pos : Int ) : Int {\n\t\tinitData();\n\t\treturn data.getUint16(pos, true);\n\t}\n\n\tpublic function setUInt16( pos : Int, v : Int ) : Void {\n\t\tinitData();\n\t\tdata.setUint16(pos, v, true);\n\t}\n\n\tpublic function getInt32( pos : Int ) : Int {\n\t\tinitData();\n\t\treturn data.getInt32(pos, true);\n\t}\n\n\tpublic function setInt32( pos : Int, v : Int ) : Void {\n\t\tinitData();\n\t\tdata.setInt32(pos, v, true);\n\t}\n\n\tpublic function getInt64( pos : Int ) : haxe.Int64 {\n\t\treturn Int64.make(getInt32(pos + 4),getInt32(pos));\n\t}\n\n\tpublic function setInt64( pos : Int, v : haxe.Int64 ) : Void {\n\t\tsetInt32(pos, v.low);\n\t\tsetInt32(pos + 4, v.high);\n\t}\n\n\tpublic function getString( pos : Int, len : Int, ?encoding : Encoding ) : String {\n\t\tif( pos < 0 || len < 0 || pos + len > length ) throw Error.OutsideBounds;\n\t\tif( encoding == null ) encoding = UTF8;\n\t\tvar s = \"\";\n\t\tvar b = b;\n\t\tvar i = pos;\n\t\tvar max = pos+len;\n\t\tswitch( encoding ) {\n\t\tcase UTF8:\n\t\t\tvar debug = pos > 0;\n\t\t\t// utf8-decode and utf16-encode\n\t\t\twhile( i < max ) {\n\t\t\t\tvar c = b[i++];\n\t\t\t\tif( c < 0x80 ) {\n\t\t\t\t\tif( c == 0 ) break;\n\t\t\t\t\ts += String.fromCharCode(c);\n\t\t\t\t} else if( c < 0xE0 )\n\t\t\t\t\ts += String.fromCharCode( ((c & 0x3F) << 6) | (b[i++] & 0x7F) );\n\t\t\t\telse if( c < 0xF0 ) {\n\t\t\t\t\tvar c2 = b[i++];\n\t\t\t\t\ts += String.fromCharCode( ((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (b[i++] & 0x7F) );\n\t\t\t\t} else {\n\t\t\t\t\tvar c2 = b[i++];\n\t\t\t\t\tvar c3 = b[i++];\n\t\t\t\t\tvar u = ((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 & 0x7F) << 6) | (b[i++] & 0x7F);\n\t\t\t\t\ts += String.fromCharCode(u);\n\t\t\t\t}\n\t\t\t}\n\t\tcase RawNative:\n\t\t\twhile( i < max ) {\n\t\t\t\tvar c = b[i++] | (b[i++] << 8);\n\t\t\t\ts += String.fromCharCode(c);\n\t\t\t}\n\t\t}\n\t\treturn s;\n\t}\n\n\t@:deprecated(\"readString is deprecated, use getString instead\")\n\t@:noCompletion\n\tpublic inline function readString(pos:Int, len:Int):String {\n\t\treturn getString(pos, len);\n\t}\n\n\tpublic function toString() : String {\n\t\treturn getString(0,length);\n\t}\n\n\tpublic function toHex() : String {\n\t\tvar s = new StringBuf();\n\t\tvar chars = [];\n\t\tvar str = \"0123456789abcdef\";\n\t\tfor( i in 0...str.length )\n\t\t\tchars.push(str.charCodeAt(i));\n\t\tfor( i in 0...length ) {\n\t\t\tvar c = get(i);\n\t\t\ts.addChar(chars[c >> 4]);\n\t\t\ts.addChar(chars[c & 15]);\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\tpublic inline function getData() : BytesData {\n\t\treturn untyped b.bufferValue;\n\t}\n\n\tpublic static inline function alloc( length : Int ) : Bytes {\n\t\treturn new Bytes(new BytesData(length));\n\t}\n\n\tpublic static function ofString( s : String, ?encoding : Encoding ) : Bytes {\n\t\tif( encoding == RawNative ) {\n\t\t\tvar buf = new js.lib.Uint8Array(s.length << 1);\n\t\t\tfor( i in 0...s.length ) {\n\t\t\t\tvar c : Int = StringTools.fastCodeAt(s,i);\n\t\t\t\tbuf[i << 1] = c & 0xFF;\n\t\t\t\tbuf[(i << 1)|1] = c >> 8;\n\t\t\t}\n\t\t\treturn new Bytes(buf.buffer);\n\t\t}\n\t\tvar a = new Array();\n\t\t// utf16-decode and utf8-encode\n\t\tvar i = 0;\n\t\twhile( i < s.length ) {\n\t\t\tvar c : Int = StringTools.fastCodeAt(s,i++);\n\t\t\t// surrogate pair\n\t\t\tif( 0xD800 <= c && c <= 0xDBFF )\n\t\t\t    c = (c - 0xD7C0 << 10) | (StringTools.fastCodeAt(s,i++) & 0x3FF);\n\t\t\tif( c <= 0x7F )\n\t\t\t\ta.push(c);\n\t\t\telse if( c <= 0x7FF ) {\n\t\t\t\ta.push( 0xC0 | (c >> 6) );\n\t\t\t\ta.push( 0x80 | (c & 63) );\n\t\t\t} else if( c <= 0xFFFF ) {\n\t\t\t\ta.push( 0xE0 | (c >> 12) );\n\t\t\t\ta.push( 0x80 | ((c >> 6) & 63) );\n\t\t\t\ta.push( 0x80 | (c & 63) );\n\t\t\t} else {\n\t\t\t\ta.push( 0xF0 | (c >> 18) );\n\t\t\t\ta.push( 0x80 | ((c >> 12) & 63) );\n\t\t\t\ta.push( 0x80 | ((c >> 6) & 63) );\n\t\t\t\ta.push( 0x80 | (c & 63) );\n\t\t\t}\n\t\t}\n\t\treturn new Bytes(new js.lib.Uint8Array(a).buffer);\n\t}\n\n\tpublic static function ofData( b : BytesData ) : Bytes {\n\t\tvar hb = untyped b.hxBytes;\n\t\tif( hb != null ) return hb;\n\t\treturn new Bytes(b);\n\t}\n\t\n\tpublic static function ofHex( s : String ) : Bytes {\t\t\n\t\tif ( (s.length & 1) != 0 ) throw \"Not a hex string (odd number of digits)\";\n\t\tvar a = new Array();\n\t\tvar i = 0;\n\t\tvar len = s.length >> 1;\n\t\twhile( i < len ) {\n\t\t\tvar high = StringTools.fastCodeAt(s, i*2);\n\t\t\tvar low = StringTools.fastCodeAt(s, i*2 + 1);\n\t\t\thigh = (high & 0xF) + ( (high & 0x40) >> 6 ) * 9;\n\t\t\tlow = (low & 0xF) + ( (low & 0x40) >> 6 ) * 9;\n\t\t\ta.push( ( (high << 4) | low)  & 0xFF );\n\t\t\ti++;\n\t\t}\n\n\t\treturn new Bytes(new js.lib.Uint8Array(a).buffer);\n\t}\n\n\tpublic inline static function fastGet( b : BytesData, pos : Int ) : Int {\n\t\t// this requires that we have wrapped it with haxe.io.Bytes beforehand\n\t\treturn untyped b.bytes[pos];\n\t}\n\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.crypto;\n\n/**\n\tAllows one to encode/decode String and bytes using Base64 encoding.\n**/\nclass Base64 {\n\n\tpublic static var CHARS(default,null) = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\tpublic static var BYTES(default,null) = haxe.io.Bytes.ofString(CHARS);\n\n\tpublic static function encode( bytes : haxe.io.Bytes, complement = true ) : String {\n\t\tvar str = new BaseCode(BYTES).encodeBytes(bytes).toString();\n\t\tif( complement )\n\t\t\tswitch (bytes.length % 3) {\n\t\t\tcase 1:\n\t\t\t\tstr += \"==\";\n\t\t\tcase 2:\n\t\t\t\tstr += \"=\";\n\t\t\tdefault:\n\t\t\t}\n\t\treturn str;\n\t}\n\n\tpublic static function decode( str : String, complement = true ) : haxe.io.Bytes {\n\t\tif( complement )\n\t\t\twhile( str.charCodeAt(str.length-1) == \"=\".code )\n\t\t\t\tstr = str.substr(0,-1);\n\t\treturn new BaseCode(BYTES).decodeBytes(haxe.io.Bytes.ofString(str));\n\t}\n\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.crypto;\n\n/**\n\tAllows one to encode/decode String and bytes using a power of two base dictionary.\n**/\nclass BaseCode {\n\n\tvar base : haxe.io.Bytes;\n\tvar nbits : Int;\n\tvar tbl : Array<Int>;\n\n\tpublic function new( base : haxe.io.Bytes ) {\n\t\tvar len = base.length;\n\t\tvar nbits = 1;\n\t\twhile( len > 1 << nbits )\n\t\t\tnbits++;\n\t\tif( nbits > 8 || len != 1 << nbits )\n\t\t\tthrow \"BaseCode : base length must be a power of two.\";\n\t\tthis.base = base;\n\t\tthis.nbits = nbits;\n\t}\n\n\tpublic function encodeBytes( b : haxe.io.Bytes ) : haxe.io.Bytes {\n\t\t#if (neko && !interp)\n\t\treturn haxe.io.Bytes.ofData( base_encode(b.getData(),base.getData()) );\n\t\t#else\n\t\tvar nbits = this.nbits;\n\t\tvar base = this.base;\n\t\tvar size = Std.int(b.length * 8 / nbits);\n\t\tvar out = haxe.io.Bytes.alloc(size + (((b.length * 8) % nbits == 0) ? 0 : 1) );\n\t\tvar buf = 0;\n\t\tvar curbits = 0;\n\t\tvar mask = (1 << nbits) - 1;\n\t\tvar pin = 0;\n\t\tvar pout = 0;\n\t\twhile( pout < size ) {\n\t\t\twhile( curbits < nbits ) {\n\t\t\t\tcurbits += 8;\n\t\t\t\tbuf <<= 8;\n\t\t\t\tbuf |= b.get(pin++);\n\t\t\t}\n\t\t\tcurbits -= nbits;\n\t\t\tout.set(pout++,base.get((buf >> curbits) & mask));\n\t\t}\n\t\tif( curbits > 0 )\n\t\t\tout.set(pout++,base.get((buf << (nbits - curbits)) & mask));\n\t\treturn out;\n\t\t#end\n\t}\n\n\tfunction initTable() {\n\t\tvar tbl = new Array();\n\t\tfor( i in 0...256 )\n\t\t\ttbl[i] = -1;\n\t\tfor( i in 0...base.length )\n\t\t\ttbl[base.get(i)] = i;\n\t\tthis.tbl = tbl;\n\t}\n\n\tpublic function decodeBytes( b : haxe.io.Bytes ) : haxe.io.Bytes {\n\t\t#if (neko && !interp)\n\t\treturn haxe.io.Bytes.ofData( base_decode(b.getData(),base.getData()) );\n\t\t#else\n\t\tvar nbits = this.nbits;\n\t\tvar base = this.base;\n\t\tif( this.tbl == null ) initTable();\n\t\tvar tbl = this.tbl;\n\t\tvar size = (b.length * nbits) >> 3;\n\t\tvar out = haxe.io.Bytes.alloc(size);\n\t\tvar buf = 0;\n\t\tvar curbits = 0;\n\t\tvar pin = 0;\n\t\tvar pout = 0;\n\t\twhile( pout < size ) {\n\t\t\twhile( curbits < 8 ) {\n\t\t\t\tcurbits += nbits;\n\t\t\t\tbuf <<= nbits;\n\t\t\t\tvar i = tbl[b.get(pin++)];\n\t\t\t\tif( i == -1 )\n\t\t\t\t\tthrow \"BaseCode : invalid encoded char\";\n\t\t\t\tbuf |= i;\n\t\t\t}\n\t\t\tcurbits -= 8;\n\t\t\tout.set(pout++,(buf >> curbits) & 0xFF);\n\t\t}\n\t\treturn out;\n\t\t#end\n\t}\n\n\tpublic function encodeString( s : String ) {\n\t\t#if (neko && !interp)\n\t\treturn neko.NativeString.toString( base_encode(neko.NativeString.ofString(s),base.getData()) );\n\t\t#else\n\t\treturn encodeBytes(haxe.io.Bytes.ofString(s)).toString();\n\t\t#end\n\t}\n\n\tpublic function decodeString( s : String ) {\n\t\t#if (neko && !interp)\n\t\treturn neko.NativeString.toString( base_decode(neko.NativeString.ofString(s),base.getData()) );\n\t\t#else\n\t\treturn decodeBytes(haxe.io.Bytes.ofString(s)).toString();\n\t\t#end\n\t}\n\n\tpublic static function encode( s : String, base : String ) {\n\t\tvar b = new BaseCode(haxe.io.Bytes.ofString(base));\n\t\treturn b.encodeString(s);\n\t}\n\n\tpublic static function decode( s : String, base : String ) {\n\t\tvar b = new BaseCode(haxe.io.Bytes.ofString(base));\n\t\treturn b.decodeString(s);\n\t}\n\n\t#if neko\n\tprivate static var base_encode = neko.Lib.load(\"std\",\"base_encode\",2);\n\tprivate static var base_decode = neko.Lib.load(\"std\",\"base_decode\",2);\n\t#end\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of h software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and h permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.ds;\n\nimport js.Syntax;\nimport js.Lib;\n\n@:coreApi\nclass ObjectMap<K:{ }, V> implements haxe.Constraints.IMap<K,V> {\n\n\tstatic var count:Int;\n\n\t// initialize count through __init__ magic, because these are generated\n\t// before normal static initializations for which ObjectMap should be ready to use\n\t// see https://github.com/HaxeFoundation/haxe/issues/6792\n\tstatic inline function __init__():Void count = 0;\n\n\tstatic inline function assignId(obj: { } ):Int {\n\t\treturn Syntax.code('({0}.__id__ = {1})', obj, Lib.getNextHaxeUID());\n\t}\n\n\tstatic inline function getId(obj: { } ):Int {\n\t\treturn untyped obj.__id__;\n\t}\n\n\tvar h : { };\n\n\tpublic function new() : Void {\n\t\th = { __keys__: {} };\n\t}\n\n\tpublic function set(key:K, value:V):Void untyped {\n\t\tvar id : Int = getId(key) || assignId(key);\n\t\th[id] = value;\n\t\th.__keys__[id] = key;\n\t}\n\n\tpublic inline function get(key:K):Null<V> {\n\t\treturn untyped h[getId(key)];\n\t}\n\n\tpublic inline function exists(key:K):Bool {\n\t\treturn untyped h.__keys__[getId(key)] != null;\n\t}\n\n\tpublic function remove( key : K ) : Bool {\n\t\tvar id = getId(key);\n\t\tif ( untyped h.__keys__[id] == null ) return false;\n\t\tuntyped  __js__(\"delete\")(h[id]);\n\t\tuntyped  __js__(\"delete\")(h.__keys__[id]);\n\t\treturn true;\n\t}\n\n\tpublic function keys() : Iterator<K> {\n\t\tvar a = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h.__keys__ ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\ta.push(h.__keys__[key]);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a.iterator();\n\t}\n\n\tpublic function iterator() : Iterator<V> {\n\t\treturn untyped {\n\t\t\tref : h,\n\t\t\tit : keys(),\n\t\t\thasNext : function() { return __this__.it.hasNext(); },\n\t\t\tnext : function() { var i = __this__.it.next(); return __this__.ref[getId(i)]; }\n\t\t};\n\t}\n\n\t@:runtime public inline function keyValueIterator() : KeyValueIterator<K, V> {\n\t\treturn new haxe.iterators.MapKeyValueIterator(this);\n\t}\n\n\tpublic function copy() : ObjectMap<K,V> {\n\t\tvar copied = new ObjectMap();\n\t\tfor(key in keys()) copied.set(key, get(key));\n\t\treturn copied;\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar it = keys();\n\t\tfor( i in it ) {\n\t\t\ts.add(Std.string(i));\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(i)));\n\t\t\tif( it.hasNext() )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n}","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.ds;\n\nprivate class StringMapIterator<T> {\n\tvar map : StringMap<T>;\n\tvar keys : Array<String>;\n\tvar index : Int;\n\tvar count : Int;\n\tpublic inline function new(map:StringMap<T>, keys:Array<String>) {\n\t\tthis.map = map;\n\t\tthis.keys = keys;\n\t\tthis.index = 0;\n\t\tthis.count = keys.length;\n\t}\n\tpublic inline function hasNext() {\n\t\treturn index < count;\n\t}\n\tpublic inline function next() {\n\t\treturn map.get(keys[index++]);\n\t}\n}\n\n@:coreApi class StringMap<T> implements haxe.Constraints.IMap<String,T> {\n\n\tprivate var h : Dynamic;\n\tprivate var rh : Dynamic;\n\n\tpublic inline function new() : Void {\n\t\th = {};\n\t}\n\n\tinline function isReserved(key:String) : Bool {\n\t\treturn untyped __js__(\"__map_reserved\")[key] != null;\n\t}\n\n\tpublic inline function set( key : String, value : T ) : Void {\n\t\tif( isReserved(key) )\n\t\t\tsetReserved(key, value);\n\t\telse\n\t\t\th[cast key] = value;\n\t}\n\n\tpublic inline function get( key : String ) : Null<T> {\n\t\tif( isReserved(key) )\n\t\t\treturn getReserved(key);\n\t\treturn h[cast key];\n\t}\n\n\tpublic inline function exists( key : String ) : Bool {\n\t\tif( isReserved(key) )\n\t\t\treturn existsReserved(key);\n\t\treturn h.hasOwnProperty(key);\n\t}\n\n\tfunction setReserved( key : String, value : T ) : Void {\n\t\tif( rh == null ) rh = {};\n\t\trh[cast \"$\"+key] = value;\n\t}\n\n\tfunction getReserved( key : String ) : Null<T> {\n\t\treturn rh == null ? null : rh[cast \"$\"+key];\n\t}\n\n\tfunction existsReserved( key : String ) : Bool {\n\t\tif( rh == null ) return false;\n\t\treturn (cast rh).hasOwnProperty(\"$\"+key);\n\t}\n\n\tpublic function remove( key : String ) : Bool {\n\t\tif( isReserved(key) ) {\n\t\t\tkey = \"$\" + key;\n\t\t\tif( rh == null || !rh.hasOwnProperty(key) ) return false;\n\t\t\tjs.Syntax.delete(rh, key);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tif( !h.hasOwnProperty(key) )\n\t\t\t\treturn false;\n\t\t\tjs.Syntax.delete(h, key);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tpublic function keys() : Iterator<String> {\n\t\treturn arrayKeys().iterator();\n\t}\n\n\tfunction arrayKeys() : Array<String> {\n\t\tvar out = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\tout.push(key);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\tif( rh != null ) untyped {\n\t\t\t__js__(\"for( var key in this.rh ) {\");\n\t\t\t\tif( key.charCodeAt(0) == \"$\".code )\n\t\t\t\t\tout.push(key.substr(1));\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn out;\n\t}\n\n\tpublic inline function iterator() : Iterator<T> {\n\t\treturn new StringMapIterator(this, arrayKeys());\n\t}\n\n\t@:runtime public inline function keyValueIterator() : KeyValueIterator<String, T> {\n\t\treturn new haxe.iterators.MapKeyValueIterator(this);\n\t}\n\n\tpublic function copy() : StringMap<T> {\n\t\tvar copied = new StringMap();\n\t\tfor(key in keys()) copied.set(key, get(key));\n\t\treturn copied;\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar keys = arrayKeys();\n\t\tfor( i in 0...keys.length ) {\n\t\t\tvar k = keys[i];\n\t\t\ts.add(k);\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(k)));\n\t\t\tif( i < keys.length-1 )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n\tstatic function __init__() : Void {\n\t\tuntyped __js__(\"var __map_reserved = {};\");\n\t}\n\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.io;\n\n/**\n\tThis exception is raised when reading while data is no longer available in the `haxe.io.Input`.\n**/\nclass Eof {\n\tpublic function new() {\n\t}\n\n\t@:ifFeature(\"haxe.io.Eof.*\")\n\tfunction toString() {\n\t\treturn \"Eof\";\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.io;\n\n/**\n\tAn Input is an abstract reader. See other classes in the `haxe.io` package\n\tfor several possible implementations.\n\n\tAll functions which read data throw `Eof` when the end of the stream\n\tis reached.\n**/\nclass Input {\n\n\t/**\n\t\tEndianness (word byte order) used when reading numbers.\n\n\t\tIf `true`, big-endian is used, otherwise `little-endian` is used.\n\t**/\n\tpublic var bigEndian(default,set) : Bool;\n\n\t#if cs\n\tprivate var helper:BytesData;\n\t#elseif java\n\tprivate var helper:java.nio.ByteBuffer;\n\t#end\n\n\t/**\n\t\tRead and return one byte.\n\t**/\n\tpublic function readByte() : Int {\n\t#if cpp\n\t\tthrow \"Not implemented\";\n\t#else\n\t\treturn throw \"Not implemented\";\n\t#end\n\t}\n\n\t/**\n\t\tRead `len` bytes and write them into `s` to the position specified by `pos`.\n\n\t\tReturns the actual length of read data that can be smaller than `len`.\n\n\t\tSee `readFullBytes` that tries to read the exact amount of specified bytes.\n\t**/\n\tpublic function readBytes( s : Bytes, pos : Int, len : Int ) : Int {\n\t\tvar k = len;\n\t\tvar b = #if (js || hl) @:privateAccess s.b #else s.getData() #end;\n\t\tif( pos < 0 || len < 0 || pos + len > s.length )\n\t\t\tthrow Error.OutsideBounds;\n\t\ttry {\n\t\t\twhile( k > 0 ) {\n\t\t\t\t#if neko\n\t\t\t\t\tuntyped __dollar__sset(b,pos,readByte());\n\t\t\t\t#elseif php\n\t\t\t\t\tb.set(pos, readByte());\n\t\t\t\t#elseif cpp\n\t\t\t\t\tb[pos] = untyped readByte();\n\t\t\t\t#else\n\t\t\t\t\tb[pos] = cast readByte();\n\t\t\t\t#end\n\t\t\t\tpos++;\n\t\t\t\tk--;\n\t\t\t}\n\t\t} catch (eof: haxe.io.Eof){}\n\t\treturn len-k;\n\t}\n\n\t/**\n\t\tClose the input source.\n\n\t\tBehaviour while reading after calling this method is unspecified.\n\t**/\n\tpublic function close() : Void {\n\t}\n\n\tfunction set_bigEndian( b : Bool ) : Bool {\n\t\tbigEndian = b;\n\t\treturn b;\n\t}\n\n\t/* ------------------ API ------------------ */\n\n\t/**\n\t\tRead and return all available data.\n\n\t\tThe `bufsize` optional argument specifies the size of chunks by\n\t\twhich data is read. Its default value is target-specific.\n\t**/\n\tpublic function readAll( ?bufsize : Int ) : Bytes {\n\t\tif( bufsize == null )\n\t\t#if php\n\t\t\tbufsize = 8192; // default value for PHP and max under certain circumstances\n\t\t#else\n\t\t\tbufsize = (1 << 14); // 16 Ko\n\t\t#end\n\n\t\tvar buf = Bytes.alloc(bufsize);\n\t\tvar total = new haxe.io.BytesBuffer();\n\t\ttry {\n\t\t\twhile( true ) {\n\t\t\t\tvar len = readBytes(buf,0,bufsize);\n\t\t\t\tif( len == 0 )\n\t\t\t\t\tthrow Error.Blocked;\n\t\t\t\ttotal.addBytes(buf,0,len);\n\t\t\t}\n\t\t} catch( e : Eof ) { }\n\t\treturn total.getBytes();\n\t}\n\n\t/**\n\t\tRead `len` bytes and write them into `s` to the position specified by `pos`.\n\n\t\tUnlike `readBytes`, this method tries to read the exact `len` amount of bytes.\n\t**/\n\tpublic function readFullBytes( s : Bytes, pos : Int, len : Int ) : Void {\n\t\twhile( len > 0 ) {\n\t\t\tvar k = readBytes(s,pos,len);\n\t\t\tif (k == 0)\n\t\t\t\tthrow Error.Blocked;\n\t\t\tpos += k;\n\t\t\tlen -= k;\n\t\t}\n\t}\n\n\t/**\n\t\tRead and return `nbytes` bytes.\n\t**/\n\tpublic function read( nbytes : Int ) : Bytes {\n\t\tvar s = Bytes.alloc(nbytes);\n\t\tvar p = 0;\n\t\twhile( nbytes > 0 ) {\n\t\t\tvar k = readBytes(s,p,nbytes);\n\t\t\tif( k == 0 ) throw Error.Blocked;\n\t\t\tp += k;\n\t\t\tnbytes -= k;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tRead a string until a character code specified by `end` is occurred.\n\n\t\tThe final character is not included in the resulting string.\n\t**/\n\tpublic function readUntil( end : Int ) : String {\n\t\tvar buf = new BytesBuffer();\n\t\tvar last : Int;\n\t\twhile( (last = readByte()) != end )\n\t\t\tbuf.addByte( last );\n\t\treturn buf.getBytes().toString();\n\t}\n\n\t/**\n\t\tRead a line of text separated by CR and/or LF bytes.\n\n\t\tThe CR/LF characters are not included in the resulting string.\n\t**/\n\tpublic function readLine() : String {\n\t\tvar buf = new BytesBuffer();\n\t\tvar last : Int;\n\t\tvar s;\n\t\ttry {\n\t\t\twhile( (last = readByte()) != 10 )\n\t\t\t\tbuf.addByte( last );\n\t\t\ts = buf.getBytes().toString();\n\t\t\tif( s.charCodeAt(s.length-1) == 13 ) s = s.substr(0,-1);\n\t\t} catch( e : Eof ) {\n\t\t\ts = buf.getBytes().toString();\n\t\t\tif( s.length == 0 )\n\t\t\t\t#if neko neko.Lib.rethrow #else throw #end (e);\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tRead a 32-bit floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readFloat() : Float {\n\t\treturn FPHelper.i32ToFloat(readInt32());\n\t}\n\n\t/**\n\t\tRead a 64-bit double-precision floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readDouble() : Float {\n\t\tvar i1 = readInt32();\n\t\tvar i2 = readInt32();\n\t\treturn bigEndian ? FPHelper.i64ToDouble(i2,i1) : FPHelper.i64ToDouble(i1,i2);\n\t}\n\n\t/**\n\t\tRead a 8-bit signed integer.\n\t**/\n\tpublic function readInt8() : Int {\n\t\tvar n = readByte();\n\t\tif( n >= 128 )\n\t\t\treturn n - 256;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 16-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt16() : Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar n = bigEndian ? ch2 | (ch1 << 8) : ch1 | (ch2 << 8);\n\t\tif( n & 0x8000 != 0 )\n\t\t\treturn n - 0x10000;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 16-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readUInt16() : Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\treturn bigEndian ? ch2 | (ch1 << 8) : ch1 | (ch2 << 8);\n\t}\n\n\t/**\n\t\tRead a 24-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt24() : Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\tvar n = bigEndian ? ch3 | (ch2 << 8) | (ch1 << 16) : ch1 | (ch2 << 8) | (ch3 << 16);\n\t\tif( n & 0x800000 != 0 )\n\t\t\treturn n - 0x1000000;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 24-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readUInt24() : Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\treturn bigEndian ? ch3 | (ch2 << 8) | (ch1 << 16) : ch1 | (ch2 << 8) | (ch3 << 16);\n\t}\n\n\t/**\n\t\tRead a 32-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt32() : Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\tvar ch4 = readByte();\n#if (php || python)\n\t\t// php will overflow integers.  Convert them back to signed 32-bit ints.\n\t\tvar n = bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n\t\tif (n & 0x80000000 != 0)\n\t\t\treturn ( n | 0x80000000);\n\t\telse return n;\n#elseif lua\n\t\tvar n = bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n\t\treturn lua.Boot.clamp(n);\n#else\n\t\treturn bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n#end\n\t}\n\n\t/**\n\t\tRead and `len` bytes as a string.\n\t**/\n\tpublic function readString( len : Int, ?encoding : Encoding ) : String {\n\t\tvar b = Bytes.alloc(len);\n\t\treadFullBytes(b,0,len);\n\t\t#if neko\n\t\treturn neko.Lib.stringReference(b);\n\t\t#else\n\t\treturn b.getString(0, len, encoding);\n\t\t#end\n\t}\n\n#if neko\n\tstatic var _float_of_bytes = neko.Lib.load(\"std\",\"float_of_bytes\",2);\n\tstatic var _double_of_bytes = neko.Lib.load(\"std\",\"double_of_bytes\",2);\n\tstatic function __init__() untyped {\n\t\tInput.prototype.bigEndian = false;\n\t}\n#end\n\n#if (flash || js || python)\n\tfunction getDoubleSig(bytes:Array<Int>)\n\t{\n\t\treturn (((bytes[1]&0xF) << 16) | (bytes[2] << 8) | bytes[3] ) * 4294967296. +\n\t\t\t(bytes[4] >> 7) * 2147483648 +\n\t\t\t(((bytes[4]&0x7F) << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7]);\n\t}\n#end\n\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.io;\n\n/**\n\tAn Output is an abstract write. A specific output implementation will only\n\thave to override the `writeByte` and maybe the `write`, `flush` and `close`\n\tmethods. See `File.write` and `String.write` for two ways of creating an\n\tOutput.\n**/\nclass Output {\n\n\t/**\n\t\tEndianness (word byte order) used when writing numbers.\n\n\t\tIf `true`, big-endian is used, otherwise `little-endian` is used.\n\t**/\n\tpublic var bigEndian(default, set) : Bool;\n\n\t#if java\n\tprivate var helper:java.nio.ByteBuffer;\n\t#end\n\n\t/**\n\t\tWrite one byte.\n\t**/\n\tpublic function writeByte( c : Int ) : Void {\n\t\tthrow \"Not implemented\";\n\t}\n\n\t/**\n\t\tWrite `len` bytes from `s` starting by position specified by `pos`.\n\n\t\tReturns the actual length of written data that can differ from `len`.\n\n\t\tSee `writeFullBytes` that tries to write the exact amount of specified bytes.\n\t**/\n\tpublic function writeBytes( s : Bytes, pos : Int, len : Int ) : Int {\n\t\t#if !neko\n\t\tif( pos < 0 || len < 0 || pos + len > s.length )\n\t\t\tthrow Error.OutsideBounds;\n\t\t#end\n\t\tvar b = #if js @:privateAccess s.b #else s.getData() #end;\n\t\tvar k = len;\n\t\twhile( k > 0 ) {\n\t\t\t#if neko\n\t\t\t\twriteByte(untyped __dollar__sget(b,pos));\n\t\t\t#elseif php\n\t\t\t\twriteByte(b.get(pos));\n\t\t\t#elseif cpp\n\t\t\t\twriteByte(untyped b[pos]);\n\t\t\t#elseif hl\n\t\t\t\twriteByte(b[pos]);\n\t\t\t#else\n\t\t\t\twriteByte(untyped b[pos]);\n\t\t\t#end\n\t\t\tpos++;\n\t\t\tk--;\n\t\t}\n\t\treturn len;\n\t}\n\n\t/**\n\t\tFlush any buffered data.\n\t**/\n\tpublic function flush() {\n\t}\n\n\t/**\n\t\tClose the output.\n\n\t\tBehaviour while writing after calling this method is unspecified.\n\t**/\n\tpublic function close() {\n\t}\n\n\tfunction set_bigEndian( b ) {\n\t\tbigEndian = b;\n\t\treturn b;\n\t}\n\n\t/* ------------------ API ------------------ */\n\n\t/**\n\t\tWrite all bytes stored in `s`.\n\t**/\n\tpublic function write( s : Bytes ) : Void {\n\t\tvar l = s.length;\n\t\tvar p = 0;\n\t\twhile( l > 0 ) {\n\t\t\tvar k = writeBytes(s,p,l);\n\t\t\tif( k == 0 ) throw Error.Blocked;\n\t\t\tp += k;\n\t\t\tl -= k;\n\t\t}\n\t}\n\n\t/**\n\t\tWrite `len` bytes from `s` starting by position specified by `pos`.\n\n\t\tUnlike `writeBytes`, this method tries to write the exact `len` amount of bytes.\n\t**/\n\tpublic function writeFullBytes( s : Bytes, pos : Int, len : Int ) {\n\t\twhile( len > 0 ) {\n\t\t\tvar k = writeBytes(s,pos,len);\n\t\t\tpos += k;\n\t\t\tlen -= k;\n\t\t}\n\t}\n\n\t/**\n\t\tWrite `x` as 32-bit floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function writeFloat( x : Float ) {\n\t\twriteInt32(FPHelper.floatToI32(x));\n\t}\n\n\t/**\n\t\tWrite `x` as 64-bit double-precision floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function writeDouble( x : Float ) {\n\t\tvar i64 = FPHelper.doubleToI64(x);\n\t\tif( bigEndian ) {\n\t\t\twriteInt32(i64.high);\n\t\t\twriteInt32(i64.low);\n\t\t} else {\n\t\t\twriteInt32(i64.low);\n\t\t\twriteInt32(i64.high);\n\t\t}\n\t}\n\n\t/**\n\t\tWrite `x` as 8-bit signed integer.\n\t**/\n\tpublic function writeInt8( x : Int ) {\n\t\tif( x < -0x80 || x >= 0x80 )\n\t\t\tthrow Error.Overflow;\n\t\twriteByte(x & 0xFF);\n\t}\n\n\t/**\n\t\tWrite `x` as 16-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function writeInt16( x : Int ) {\n\t\tif( x < -0x8000 || x >= 0x8000 ) throw Error.Overflow;\n\t\twriteUInt16(x & 0xFFFF);\n\t}\n\n\t/**\n\t\tWrite `x` as 16-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function writeUInt16( x : Int ) {\n\t\tif( x < 0 || x >= 0x10000 ) throw Error.Overflow;\n\t\tif( bigEndian ) {\n\t\t\twriteByte(x >> 8);\n\t\t\twriteByte(x & 0xFF);\n\t\t} else {\n\t\t\twriteByte(x & 0xFF);\n\t\t\twriteByte(x >> 8);\n\t\t}\n\t}\n\n\t/**\n\t\tWrite `x` as 24-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function writeInt24( x : Int ) {\n\t\tif( x < -0x800000 || x >= 0x800000 ) throw Error.Overflow;\n\t\twriteUInt24(x & 0xFFFFFF);\n\t}\n\n\t/**\n\t\tWrite `x` as 24-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function writeUInt24( x : Int ) {\n\t\tif( x < 0 || x >= 0x1000000 ) throw Error.Overflow;\n\t\tif( bigEndian ) {\n\t\t\twriteByte(x >> 16);\n\t\t\twriteByte((x >> 8) & 0xFF);\n\t\t\twriteByte(x & 0xFF);\n\t\t} else {\n\t\t\twriteByte(x & 0xFF);\n\t\t\twriteByte((x >> 8) & 0xFF);\n\t\t\twriteByte(x >> 16);\n\t\t}\n\t}\n\n\t/**\n\t\tWrite `x` as 32-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function writeInt32( x : Int ) {\n\t\tif( bigEndian ) {\n\t\t\twriteByte( x >>> 24 );\n\t\t\twriteByte( (x >> 16) & 0xFF );\n\t\t\twriteByte( (x >> 8) & 0xFF );\n\t\t\twriteByte( x & 0xFF );\n\t\t} else {\n\t\t\twriteByte( x & 0xFF );\n\t\t\twriteByte( (x >> 8) & 0xFF );\n\t\t\twriteByte( (x >> 16) & 0xFF );\n\t\t\twriteByte( x >>> 24 );\n\t\t}\n\t}\n\n\t/**\n\t\tInform that we are about to write at least `nbytes` bytes.\n\n\t\tThe underlying implementation can allocate proper working space depending\n\t\ton this information, or simply ignore it. This is not a mandatory call\n\t\tbut a tip and is only used in some specific cases.\n\t**/\n\tpublic function prepare( nbytes : Int ) {\n\t}\n\n\t/**\n\t\tRead all available data from `i` and write it.\n\n\t\tThe `bufsize` optional argument specifies the size of chunks by\n\t\twhich data is read and written. Its default value is 4096.\n\t**/\n\tpublic function writeInput( i : Input, ?bufsize : Int ) {\n\t\tif( bufsize == null )\n\t\t\tbufsize = 4096;\n\t\tvar buf = Bytes.alloc(bufsize);\n\t\ttry {\n\t\t\twhile( true ) {\n\t\t\t\tvar len = i.readBytes(buf,0,bufsize);\n\t\t\t\tif( len == 0 )\n\t\t\t\t\tthrow Error.Blocked;\n\t\t\t\tvar p = 0;\n\t\t\t\twhile( len > 0 ) {\n\t\t\t\t\tvar k = writeBytes(buf,p,len);\n\t\t\t\t\tif( k == 0 )\n\t\t\t\t\t\tthrow Error.Blocked;\n\t\t\t\t\tp += k;\n\t\t\t\t\tlen -= k;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch( e : Eof ) {\n\t\t}\n\t}\n\n\t/**\n\t\tWrite `s` string.\n\t**/\n\tpublic function writeString( s : String, ?encoding : Encoding ) {\n\t\t#if neko\n\t\tvar b = untyped new Bytes(s.length,s.__s);\n\t\t#else\n\t\tvar b = Bytes.ofString(s, encoding);\n\t\t#end\n\t\twriteFullBytes(b,0,b.length);\n\t}\n\n#if neko\n\tstatic function __init__() untyped {\n\t\tOutput.prototype.bigEndian = false;\n\t}\n#end\n\n}\n","package httpstatus;\n\n@:enum\nabstract HttpStatusCode(Int) from Int {\n\t\n\tvar Continue = 100;\n\tvar SwitchingProtocols = 101;\n\tvar Processing = 102;\n\tvar OK = 200;\n\tvar Created = 201;\n\tvar Accepted = 202;\n\tvar NonAuthoritativeInformation = 203;\n\tvar NoContent = 204;\n\tvar ResetContent = 205;\n\tvar PartialContent = 206;\n\tvar MultiStatus = 207;\n\tvar AlreadyReported = 208;\n\tvar IMUsed = 226;\n\tvar MultipleChoices = 300;\n\tvar MovedPermanently = 301;\n\tvar Found = 302;\n\tvar SeeOther = 303;\n\tvar NotModified = 304;\n\tvar UseProxy = 305;\n\tvar SwitchProxy = 306;\n\tvar TemporaryRedirect = 307;\n\tvar PermanentRedirect = 308;\n\tvar BadRequest = 400;\n\tvar Unauthorized = 401;\n\tvar PaymentRequired = 402;\n\tvar Forbidden = 403;\n\tvar NotFound = 404;\n\tvar MethodNotAllowed = 405;\n\tvar NotAcceptable = 406;\n\tvar ProxyAuthenticationRequired = 407;\n\tvar RequestTimeout = 408;\n\tvar Conflict = 409;\n\tvar Gone = 410;\n\tvar LengthRequired = 411;\n\tvar PreconditionFailed = 412;\n\tvar PayloadTooLarge = 413;\n\tvar URITooLong = 414;\n\tvar UnsupportedMediaType = 415;\n\tvar RangeNotSatisfiable = 416;\n\tvar ExpectationFailed = 417;\n\tvar ImATeapot = 418;\n\tvar MisdirectedRequest = 421;\n\tvar UnprocessableEntity = 422;\n\tvar Locked = 423;\n\tvar FailedDependency = 424;\n\tvar UpgradeRequired = 426;\n\tvar PreconditionRequired = 428;\n\tvar TooManyRequests = 429;\n\tvar RequestHeaderFieldsTooLarge = 431;\n\tvar UnavailableForLegalReasons = 451;\n\tvar InternalServerError = 500;\n\tvar NotImplemented = 501;\n\tvar BadGateway = 502;\n\tvar ServiceUnavailable = 503;\n\tvar GatewayTimeout = 504;\n\tvar HTTPVersionNotSupported = 505;\n\tvar VariantAlsoNegotiates = 506;\n\tvar InsufficientStorage = 507;\n\tvar LoopDetected = 508;\n\tvar NotExtended = 510;\n\tvar NetworkAuthenticationRequired = 511;\n\t\n\t@:to\n\tpublic inline function toMessage():HttpStatusMessage\n\t\treturn new HttpStatusMessage(this);\n\t\n\t@:to\n\tpublic inline function toInt():Int\n\t\treturn this;\n\t\t\n\t\n\t@:op(A>B) static function gt<T>(a:HttpStatusCode, b:HttpStatusCode):Bool;\n\t@:op(A<B) static function lt<T>(a:HttpStatusCode, b:HttpStatusCode):Bool;\n\t@:op(A>=B) static function gte<T>(a:HttpStatusCode, b:HttpStatusCode):Bool;\n\t@:op(A>=B) static function lte<T>(a:HttpStatusCode, b:HttpStatusCode):Bool;\n\t@:op(A==B) static function eq<T>(a:HttpStatusCode, b:HttpStatusCode):Bool;\n\t@:op(A!=B) static function neq<T>(a:HttpStatusCode, b:HttpStatusCode):Bool;\n\t\n\t#if tink_core\n\t@:from\n\tpublic static inline function fromErrorCode(code:tink.core.Error.ErrorCode):HttpStatusCode\n\t\treturn (code:Int);\n\t#end\n\t\n\t#if tink_web\n\t@:to\n\tpublic inline function toWebResponse():tink.web.routing.Response\n\t\treturn toOutgoingResponse();\n\t#end\n\t\n\t#if tink_http\n\t@:to\n\tpublic function toOutgoingResponse():tink.http.Response.OutgoingResponse\n\t\treturn new tink.http.Response.OutgoingResponse(\n\t\t\tnew tink.http.Response.ResponseHeader(toInt(), toMessage(), [new tink.http.Header.HeaderField(CONTENT_LENGTH, '0')]),\n\t\t\ttink.io.Source.EMPTY\n\t\t);\n\t@:from\n\tpublic static inline function fromIncomingResponse(res:tink.http.Response.IncomingResponse):HttpStatusCode\n\t\treturn res.header.statusCode;\n\t#end\n}","package tink.http;\n\nimport tink.http.Message;\nimport tink.http.Header;\nimport tink.Chunk;\nimport httpstatus.HttpStatusCode;\n\nusing tink.io.Source;\nusing tink.CoreApi;\n\ntypedef StatusCode = httpstatus.HttpStatusCode;\ntypedef Reason = httpstatus.HttpStatusMessage;\n\n@:forward\nabstract ResponseHeader(ResponseHeaderBase) from ResponseHeaderBase to ResponseHeaderBase {\n  public inline function new(statusCode, ?reason, ?fields, ?protocol:Protocol = HTTP1_1)\n    this = new ResponseHeaderBase(statusCode, reason, fields, protocol);\n    \n  @:from\n  public static inline function fromStatusCode(code:StatusCode):ResponseHeader\n    return new ResponseHeader(code);\n    \n  @:from\n  public static inline function fromHeaderFields(fields:Array<HeaderField>):ResponseHeader\n    return new ResponseHeader(OK, fields);\n    \n  inline static public function parser()\n    return ResponseHeaderBase.parser();\n}\n\nclass ResponseHeaderBase extends Header {\n  \n  public var statusCode(default, null):StatusCode;\n  public var reason(default, null):Reason;\n  public var protocol(default, null):String;\n  \n  public function new(statusCode:StatusCode, ?reason:Reason, ?fields, ?protocol:Protocol = HTTP1_1) {\n    this.statusCode = statusCode;\n    this.reason = reason == null ? statusCode : reason;\n    this.protocol = protocol;\n    super(fields);\n  }\n  \n  override function concat(fields:Array<HeaderField>):ResponseHeader\n    return new ResponseHeader(statusCode, reason, this.fields.concat(fields), protocol);\n  \n  override public function toString():String\n    return '$protocol ${statusCode.toInt()} $reason$LINEBREAK' + super.toString();\n  \n  static public function parser():tink.io.StreamParser<ResponseHeader>\n    return new HeaderParser<ResponseHeader>(function (line, headers) \n      return switch line.split(' ') {//TODO: we should probably not split here in the first place.\n        case v if(v.length >= 3):\n          Success(new ResponseHeader(Std.parseInt(v[1]), v.slice(2).join(' '), headers, v[0]));\n        default: \n          Failure(new Error(UnprocessableEntity, 'Invalid HTTP response header'));\n      }\n    );    \n}\n\nprivate class OutgoingResponseData extends Message<ResponseHeader, IdealSource> {}\n\n@:forward\nabstract OutgoingResponse(OutgoingResponseData) {\n  public inline function new(header, body) \n    this = new OutgoingResponseData(header, body);\n    \n  static public function blob(?code = OK, chunk:Chunk, contentType:String, ?headers)\n    return \n        new OutgoingResponse(\n          new ResponseHeader(\n            code, \n            code, \n            [\n              new HeaderField('Content-Type', contentType), \n              new HeaderField('Content-Length', Std.string(chunk.length))\n            ].concat(switch headers {\n              case null: [];\n              case v: v;\n            })), \n          chunk\n        );\n  \n  static public function chunked(contentType:String, ?headers, source:IdealSource) {\n    //TODO: implement\n    \n  }\n        \n  @:from static function ofString(s:String) \n    return blob(s, 'text/plain');\n    \n  @:from static function ofChunk(c:Chunk) \n    return blob(c, 'application/octet-stream');\n    \n  static public function reportError(e:Error) {\n    var code:Int = e.code;\n    if(code < 100 || code > 999) code = 500; // see: https://github.com/nodejs/node/blob/baa54a5ae78ff04a3e8d8ac97c052304a6f6c18c/lib/_http_server.js#L212\n    return new OutgoingResponse(\n      new ResponseHeader(code, code, [new HeaderField('Content-Type', 'application/json')]),\n      haxe.Json.stringify({//TODO: reconsider the wisdom of json encoding this way, since it relies on reflection\n        error: e.message,\n        details: e.data,\n        //TODO: add stack trace when it becomes available\n      })\n    );\n  }\n}\n\nclass IncomingResponse extends Message<ResponseHeader, RealSource> {\n  \n  static public function readAll(res:IncomingResponse):Promise<Chunk> \n    return res.body.all().next(function (b)\n      return \n        if (res.header.statusCode >= 400) \n          Failure(Error.withData(res.header.statusCode, res.header.reason, b.toString()))\n        else\n          Success(b)   \n    );\n            \n  static public function reportError(e:Error) {\n    return new IncomingResponse(\n      new ResponseHeader(e.code, e.code, [new HeaderField('Content-Type', 'application/json')]),\n      haxe.Json.stringify({//TODO: reconsider the wisdom of json encoding this way, since it relies on reflection\n        error: e.message,\n        details: e.data,\n        //TODO: add stack trace when it becomes available\n      })\n    );\n  }\n        \n}\n","package httpstatus;\n\nabstract HttpStatusMessage(String) from String to String {\n\t\n\tpublic inline function new(statusCode:Int) this = fromCode(statusCode);\n\t\n\t@:from\n\tpublic static function fromCode(statusCode:Int):HttpStatusMessage {\n\t\treturn switch statusCode {\n\t\t\tcase 100: 'Continue';\n\t\t\tcase 101: 'Switching Protocols';\n\t\t\tcase 102: 'Processing';\n\t\t\tcase 200: 'OK';\n\t\t\tcase 201: 'Created';\n\t\t\tcase 202: 'Accepted';\n\t\t\tcase 203: 'Non-Authoritative Information';\n\t\t\tcase 204: 'No Content';\n\t\t\tcase 205: 'Reset Content';\n\t\t\tcase 206: 'Partial Content';\n\t\t\tcase 207: 'Multi-Status';\n\t\t\tcase 208: 'Already Reported';\n\t\t\tcase 226: 'IM Used';\n\t\t\tcase 300: 'Multiple Choices';\n\t\t\tcase 301: 'Moved Permanently';\n\t\t\tcase 302: 'Found';\n\t\t\tcase 303: 'See Other';\n\t\t\tcase 304: 'Not Modified';\n\t\t\tcase 305: 'Use Proxy';\n\t\t\tcase 306: 'Switch Proxy';\n\t\t\tcase 307: 'Temporary Redirect';\n\t\t\tcase 308: 'Permanent Redirect';\n\t\t\tcase 400: 'Bad Request';\n\t\t\tcase 401: 'Unauthorized';\n\t\t\tcase 402: 'Payment Required';\n\t\t\tcase 403: 'Forbidden';\n\t\t\tcase 404: 'Not Found';\n\t\t\tcase 405: 'Method Not Allowed';\n\t\t\tcase 406: 'Not Acceptable';\n\t\t\tcase 407: 'Proxy Authentication Required';\n\t\t\tcase 408: 'Request Timeout';\n\t\t\tcase 409: 'Conflict';\n\t\t\tcase 410: 'Gone';\n\t\t\tcase 411: 'Length Required';\n\t\t\tcase 412: 'Precondition Failed';\n\t\t\tcase 413: 'Payload Too Large';\n\t\t\tcase 414: 'URI Too Long';\n\t\t\tcase 415: 'Unsupported Media Type';\n\t\t\tcase 416: 'Range Not Satisfiable';\n\t\t\tcase 417: 'Expectation Failed';\n\t\t\tcase 418: 'I\\'m a teapot';\n\t\t\tcase 421: 'Misdirected Request';\n\t\t\tcase 422: 'Unprocessable Entity';\n\t\t\tcase 423: 'Locked';\n\t\t\tcase 424: 'Failed Dependency';\n\t\t\tcase 426: 'Upgrade Required';\n\t\t\tcase 428: 'Precondition Required';\n\t\t\tcase 429: 'Too Many Requests';\n\t\t\tcase 431: 'Request Header Fields Too Large';\n\t\t\tcase 451: 'Unavailable For Legal Reasons';\n\t\t\tcase 500: 'Internal Server Error';\n\t\t\tcase 501: 'Not Implemented';\n\t\t\tcase 502: 'Bad Gateway';\n\t\t\tcase 503: 'Service Unavailable';\n\t\t\tcase 504: 'Gateway Timeout';\n\t\t\tcase 505: 'HTTP Version Not Supported';\n\t\t\tcase 506: 'Variant Also Negotiates';\n\t\t\tcase 507: 'Insufficient Storage';\n\t\t\tcase 508: 'Loop Detected';\n\t\t\tcase 510: 'Not Extended';\n\t\t\tcase 511: 'Network Authentication Required';\n\t\t\tdefault: 'Unknown Status';\n\t\t}\n\t}\n}","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js;\n\nimport js.Syntax; // import it here so it's always available in the compiler\n\nprivate class HaxeError extends js.lib.Error {\n\tvar val:Dynamic;\n\n\t@:pure\n\tpublic function new(val:Dynamic) {\n\t\tsuper();\n\t\tthis.val = val;\n\t\tif ((cast js.lib.Error).captureStackTrace) (cast js.lib.Error).captureStackTrace(this, HaxeError);\n\t}\n\n\tpublic static function wrap(val:Dynamic):js.lib.Error {\n\t\treturn if (js.Syntax.instanceof(val, js.lib.Error)) val else new HaxeError(val);\n\t}\n\n\tstatic function __init__() {\n\t\tjs.lib.Object.defineProperty((cast HaxeError).prototype, \"message\", {get: () -> (cast String)(js.Lib.nativeThis.val)});\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\n\tstatic inline function isClass(o:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isInterface(o:Class<Dynamic>) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isInterface\", o.__isInterface__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\tstatic function getClass(o:Dynamic) : Dynamic {\n\t\tif (Std.is(o, Array))\n\t\t\treturn Array;\n\t\telse {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o,s:String) {\n\t\tuntyped {\n\t\t\tif( o == null )\n\t\t\t    return \"null\";\n\t\t\tif( s.length >= 5 )\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = js.Syntax.typeof(o);\n\t\t\tif( t == \"function\" && (isClass(o) || isEnum(o)) )\n\t\t\t\tt = \"object\";\n\t\t\tswitch( t ) {\n\t\t\tcase \"object\":\n\t\t\t\t#if !js_enums_as_arrays\n\t\t\t\tif (o.__enum__) {\n\t\t\t\t\tvar e = $hxEnums[o.__enum__];\n\t\t\t\t\tvar n = e.__constructs__[o._hx_index];\n\t\t\t\t\tvar con = e[n];\n\t\t\t\t\tif (con.__params__) {\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\treturn n + \"(\" +\n\t\t\t\t\t\t\t[for (p in (con.__params__:Array<String>)) __string_rec(o[p],s)].join(\",\") + \")\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn n;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#end\n\t\t\t\tif( js.Syntax.instanceof(o, Array) ) {\n\t\t\t\t\t#if js_enums_as_arrays\n\t\t\t\t\tif( o.__enum__ ) {\n\t\t\t\t\t\tif( o.length == 2 )\n\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\tvar str = o[0]+\"(\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor( i in 2...o.length ) {\n\t\t\t\t\t\t\tif( i != 2 )\n\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i],s);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tstr += __string_rec(o[i],s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t}\n\t\t\t\t\t#end\n\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tfor( i in 0...o.length )\n\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\")+__string_rec(o[i],s);\n\t\t\t\t\tstr += \"]\";\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t\tvar tostr;\n\t\t\t\ttry {\n\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t} catch( e : Dynamic ) {\n\t\t\t\t\t// strange error on IE\n\t\t\t\t\treturn \"???\";\n\t\t\t\t}\n\t\t\t\tif( tostr != null && tostr != __js__(\"Object.toString\") && js.Syntax.typeof(tostr) == \"function\" ) {\n\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\tif( s2 != \"[object Object]\")\n\t\t\t\t\t\treturn s2;\n\t\t\t\t}\n\t\t\t\tvar str = \"{\\n\";\n\t\t\t\ts += \"\\t\";\n\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\tvar k : String = null;\n\t\t\t\t__js__(\"for( {0} in {1} ) {\", k, o);\n\t\t\t\t\tif( hasp && !o.hasOwnProperty(k) )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\" )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( str.length != 2 )\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \"+__string_rec(o[k],s);\n\t\t\t\t__js__(\"}\");\n\t\t\t\ts = s.substring(1);\n\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\treturn str;\n\t\t\tcase \"function\":\n\t\t\t\treturn \"<function>\";\n\t\t\tcase \"string\":\n\t\t\t\treturn o;\n\t\t\tdefault:\n\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static function __interfLoop(cc : Dynamic,cl : Dynamic) {\n\t\tif( cc == null )\n\t\t\treturn false;\n\t\tif( cc == cl )\n\t\t\treturn true;\n\t\tif( js.lib.Object.prototype.hasOwnProperty.call(cc, \"__interfaces__\") ) {\n\t\t\tvar intf : Dynamic = cc.__interfaces__;\n\t\t\tfor( i in 0...intf.length ) {\n\t\t\t\tvar i : Dynamic = intf[i];\n\t\t\t\tif( i == cl || __interfLoop(i,cl) )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn __interfLoop(cc.__super__,cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") @:pure private static function __instanceof(o : Dynamic,cl : Dynamic) {\n\t\tif( cl == null )\n\t\t\treturn false;\n\t\tswitch( cl ) {\n\t\tcase Int:\n\t\t\treturn js.Syntax.typeof(o) == \"number\" && js.Syntax.strictEq(o | 0, o);\n\t\tcase Float:\n\t\t\treturn js.Syntax.typeof(o) == \"number\";\n\t\tcase Bool:\n\t\t\treturn js.Syntax.typeof(o) == \"boolean\";\n\t\tcase String:\n\t\t\treturn js.Syntax.typeof(o) == \"string\";\n\t\tcase Array:\n\t\t\treturn js.Syntax.instanceof(o, Array) #if js_enums_as_arrays && o.__enum__ == null #end;\n\t\tcase Dynamic:\n\t\t\treturn o != null;\n\t\tdefault:\n\t\t\tif( o != null ) {\n\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\tif( js.Syntax.typeof(cl) == \"function\" ) {\n\t\t\t\t\tif( js.Syntax.instanceof(o, cl) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif( __interfLoop(getClass(o),cl) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if ( js.Syntax.typeof(cl) == \"object\" && __isNativeObj(cl) ) {\n\t\t\t\t\tif( js.Syntax.instanceof(o, cl) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// do not use isClass/isEnum here\n\t\t\tuntyped __feature__(\"Class.*\",if( cl == Class && o.__name__ != null ) return true);\n\t\t\tuntyped __feature__(\"Enum.*\",if( cl == Enum && o.__ename__ != null ) return true);\n\t\t\t#if js_enums_as_arrays\n\t\t\treturn o.__enum__ == cl;\n\t\t\t#else\n\t\t\treturn if (o.__enum__ != null) (untyped $hxEnums[o.__enum__]) == cl else false;\n\t\t\t#end\n\t\t}\n\t}\n\n\tstatic inline function __implements(o : Dynamic, t : Class<Dynamic>) : Bool {\n\t\treturn o != null && isInterface(t) && __interfLoop(getClass(o), t);\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o : Dynamic, t : Dynamic) {\n\t\tif (o == null || __instanceof(o, t)) return o;\n\t\telse throw \"Cannot cast \" +Std.string(o) + \" to \" +Std.string(t);\n\t}\n\n\tstatic var __toStr:js.lib.Function;\n\tstatic function __init__() {\n\t\tBoot.__toStr = (cast {}).toString;\n\t}\n\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name:String = __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) {\n\t\treturn js.Lib.global[cast name];\n\t}\n\n}\n","/*\n * Copyright (C)2014-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js.node.buffer;\n\n#if haxe4\nimport js.lib.ArrayBuffer;\nimport js.lib.Uint8Array;\nimport js.lib.Object;\n#else\nimport js.html.ArrayBuffer;\nimport js.html.Uint8Array;\n#end\n\n/**\n\tThe Buffer class is a global type for dealing with binary data directly. It can be constructed in a variety of ways.\n\n\tIt supports array access syntax to get and set the octet at index. The values refer to individual bytes,\n\tso the legal range is between 0x00 and 0xFF hex or 0 and 255.\n**/\n@:jsRequire(\"buffer\", \"Buffer\")\nextern class Buffer extends Uint8Array {\n\n\t/**\n\t\tHow many bytes will be returned when `buffer.inspect()` is called.\n\t\tThis can be overridden by user modules.\n\t\tDefault: 50\n\t**/\n\tpublic static var INSPECT_MAX_BYTES(get,set):Int;\n\tprivate inline static function get_INSPECT_MAX_BYTES():Int {\n\t\treturn js.Lib.require(\"buffer\").INSPECT_MAX_BYTES;\n\t}\n\tprivate inline static function set_INSPECT_MAX_BYTES(value:Int):Int {\n\t\treturn js.Lib.require(\"buffer\").INSPECT_MAX_BYTES = value;\n\t}\n\n\t/**\n\t\tMaximum length of a `Buffer`.\n\t**/\n\tpublic static var kMaxLength(get,never):Int;\n\tprivate inline static function get_kMaxLength():Int {\n\t\treturn js.Lib.require(\"buffer\").kMaxLength;\n\t}\n\n\t/**\n\t\tReturns `true` if the encoding is a valid encoding argument, or `false` otherwise.\n\t**/\n\tstatic function isEncoding(encoding:String):Bool;\n\n\t/**\n\t\tTests if `obj` is a `Buffer`.\n\t**/\n\tstatic function isBuffer(obj:Dynamic):Bool;\n\n\t/**\n\t\tGives the actual byte length of a string.\n\n\t\t`encoding` defaults to 'utf8'.\n\n\t\tThis is not the same as `String.length` since that\n\t\treturns the number of characters in a string.\n\t**/\n\t#if (haxe_ver >= 3.3)\n\tstatic function byteLength(string:String, ?encoding:String):Int;\n\t#end\n\n\t/**\n\t\tGives the actual byte length of a string.\n\n\t\t`encoding` defaults to 'utf8'.\n\n\t\tThis is not the same as `String.length` since that\n\t\treturns the number of characters in a string.\n\t**/\n\t#if (haxe_ver >= 3.3) @:deprecated(\"In haxe 3.3+, use Buffer.byteLength instead!\") #end\n\tinline static function _byteLength(string:String, ?encoding:String):Int return untyped Buffer['byteLength'](string, encoding);\n\n\t/**\n\t\tReturns a buffer which is the result of concatenating all the buffers in the `list` together.\n\n\t\tIf the `list` has no items, or if the `totalLength` is 0, then it returns a zero-length buffer.\n\t\tIf the `list` has exactly one item, then the first item of the `list` is returned.\n\t\tIf the `list` has more than one item, then a new `Buffer` is created.\n\n\t\tIf `totalLength` is not provided, it is read from the buffers in the `list`.\n\t\tHowever, this adds an additional loop to the function, so it is faster to provide the length explicitly.\n\t**/\n\tstatic function concat(list:Array<Buffer>, ?totalLength:Int):Buffer;\n\n\t/**\n\t\tThe same as `buf1.compare(buf2)`. Useful for sorting an Array of Buffers.\n\t**/\n\t@:native(\"compare\")\n\tstatic function compareBuffers(buf1:Buffer, buf2:Buffer):Int;\n\n\t/**\n\t\tAllocates a new buffer.\n\t**/\n\t@:overload(function(string:String, ?encoding:String):Void {})\n\t@:overload(function(buffer:Buffer):Void {})\n\t@:overload(function(arrayBuffer:ArrayBuffer, ?byteOffset:Int, ?length:Int):Void {})\n\t@:overload(function(array:Array<Int>):Void {})\n\tfunction new(size:Int):Void;\n\n\t/**\n\t\tAllocates a new `Buffer` of `size` bytes.\n\n\t\tIf `fill` is undefined, the `Buffer` will be zero-filled.\n\n\t\tCalling `Buffer.alloc(size)` can be significantly slower than the alternative `Buffer.allocUnsafe(size)`\n\t\tbut ensures that the newly created `Buffer` instance contents will never contain sensitive data.\n\t**/\n\t@:overload(function(size:Int, fill:String, ?encoding:String):Buffer {})\n\tstatic function alloc(size:Int, ?fill:Int):Buffer;\n\n\t/**\n\t\tAllocates a new non-zero-filled `Buffer` of `size` bytes.\n\n\t\tThe underlying memory for `Buffer` instances created in this way is not initialized.\n\t\tThe contents of the newly created `Buffer` are unknown and may contain sensitive data.\n\t\tUse `buf.fill(0)` to initialize such `Buffer` instances to zeroes.\n\t**/\n\tstatic function allocUnsafe(size:Int):Buffer;\n\n\t/**\n\t\tAllocates a new non-zero-filled and non-pooled `Buffer` of `size` bytes.\n\n\t\tThe underlying memory for `Buffer` instances created in this way is not initialized.\n\t\tThe contents of the newly created `Buffer` are unknown and may contain sensitive data.\n\t\tUse `buf.fill(0)` to initialize such `Buffer` instances to zeroes.\n\t**/\n\tstatic function allocUnsafeSlow(size:Int):Buffer;\n\n\t@:overload(function(buffer:Buffer):Buffer {})\n\t@:overload(function(str:String, ?encoding:String):Buffer {})\n\tstatic function from(arrayBuffer:ArrayBuffer, ?byteOffset:Int, ?length:Int):Buffer;\n\n\t/**\n\t\tReturns a JSON-representation of the `Buffer` instance.\n\t**/\n\tfunction toJSON():Dynamic;\n\n\t/**\n\t\tWrites `string` to the buffer at `offset` using the given `encoding`.\n\n\t\t`offset` defaults to 0, encoding defaults to 'utf8'. `length` is the number of bytes to write.\n\n\t\tReturns number of octets written. If buffer did not contain enough space to fit the entire `string`,\n\t\tit will write a partial amount of the `string`. `length` defaults to `buffer.length - offset`.\n\n\t\tThe method will not write partial characters.\n\t**/\n\t@:overload(function(string:String, offset:Int, length:Int, ?encoding:String):Int {})\n\t@:overload(function(string:String, offset:Int, ?encoding:String):Int {})\n\tfunction write(string:String, ?encoding:String):Int;\n\n\t/**\n\t\tDecodes and returns a string from buffer data encoded with `encoding` (defaults to 'utf8')\n\t\tbeginning at `start` (defaults to 0) and ending at `end` (defaults to `buffer.length`).\n\t**/\n\t@:overload(function(encoding:String, ?start:Int, ?end:Int):String {})\n\tfunction toString():String;\n\n\t/**\n\t\tDoes copy between buffers.\n\t\tThe source and target regions can be overlapped.\n\t\t`targetStart` and `sourceStart` default to 0. `sourceEnd` defaults to `buffer.length`.\n\t**/\n\tfunction copy(targetBuffer:Buffer, ?targetStart:Int, ?sourceStart:Int, ?sourceEnd:Int):Void;\n\n\t/**\n\t\tReturns a new buffer which references the same memory as the old,\n\t\tbut offset and cropped by the `start` (defaults to 0) and `end` (defaults to `buffer.length`) indexes.\n\t\tNegative indexes start from the end of the buffer.\n\n\t\tModifying the new buffer slice will modify memory in the original buffer!\n\t**/\n\tfunction slice(?start:Int, ?end:Int):Buffer;\n\n\t/**\n\t\tInterprets the `Buffer` as an array of unsigned 16-bit integers and swaps the byte-order in-place.\n\n\t\tThrows a `RangeError` if the `Buffer` length is not a multiple of 16 bits.\n\t\tThe method returns a reference to the `Buffer`, so calls can be chained.\n\t**/\n\tfunction swap16():Buffer;\n\n\t/**\n\t\tInterprets the `Buffer` as an array of unsigned 32-bit integers and swaps the byte-order in-place.\n\n\t\tThrows a `RangeError` if the `Buffer` length is not a multiple of 32 bits.\n\t\tThe method returns a reference to the `Buffer`, so calls can be chained.\n\t**/\n\tfunction swap32():Buffer;\n\n\t/**\n\t\tInterprets the `Buffer` as an array of 64-bit numbers and swaps the byte-order in-place.\n\n\t\tThrows a `RangeError` if the `Buffer` length is not a multiple of 64 bits.\n\t\tThe method returns a reference to the `Buffer`, so calls can be chained.\n\t**/\n\tfunction swap64():Buffer;\n\n\t/**\n\t\tReads an unsigned 8 bit integer from the buffer at the specified offset.\n\n\t\tSet `noAssert` to `true` to skip validation of `offset`.\n\t\tThis means that `offset` may be beyond the end of the buffer. Defaults to `false`.\n\t**/\n\tfunction readUInt8(offset:Int, ?noAssert:Bool):Int;\n\n\t/**\n\t\tReads an unsigned 16 bit integer from the buffer at the specified `offset` with little-endian format.\n\n\t\tSet `noAssert` to `true` to skip validation of `offset`.\n\t\tThis means that `offset` may be beyond the end of the buffer. Defaults to `false`.\n\t**/\n\tfunction readUInt16LE(offset:Int, ?noAssert:Bool):Int;\n\n\t/**\n\t\tReads an unsigned 16 bit integer from the buffer at the specified `offset` with big-endian format.\n\n\t\tSet `noAssert` to `true` to skip validation of `offset`.\n\t\tThis means that `offset` may be beyond the end of the buffer. Defaults to `false`.\n\t**/\n\tfunction readUInt16BE(offset:Int, ?noAssert:Bool):Int;\n\n\t/**\n\t\tReads an unsigned 32 bit integer from the buffer at the specified `offset` with little-endian format.\n\n\t\tSet `noAssert` to `true` to skip validation of `offset`.\n\t\tThis means that `offset` may be beyond the end of the buffer. Defaults to `false`.\n\t**/\n\tfunction readUInt32LE(offset:Int, ?noAssert:Bool):Int;\n\n\t/**\n\t\tReads an unsigned 32 bit integer from the buffer at the specified `offset` with big-endian format.\n\n\t\tSet `noAssert` to `true` to skip validation of `offset`.\n\t\tThis means that `offset` may be beyond the end of the buffer. Defaults to `false`.\n\t**/\n\tfunction readUInt32BE(offset:Int, ?noAssert:Bool):Int;\n\n\t/**\n\t\tReads a signed 8 bit integer from the buffer at the specified `offset`.\n\n\t\tSet `noAssert` to `true` to skip validation of `offset`.\n\t\tThis means that `offset` may be beyond the end of the buffer. Defaults to `false`.\n\n\t\tWorks as `readUInt8`, except buffer contents are treated as two's complement signed values.\n\t**/\n\tfunction readInt8(offset:Int, ?noAssert:Bool):Int;\n\n\t/**\n\t\tReads a signed 16 bit integer from the buffer at the specified `offset` with little-endian format.\n\n\t\tSet `noAssert` to `true` to skip validation of `offset`.\n\t\tThis means that `offset` may be beyond the end of the buffer. Defaults to `false`.\n\n\t\tWorks as `readUInt16LE`, except buffer contents are treated as two's complement signed values.\n\t**/\n\tfunction readInt16LE(offset:Int, ?noAssert:Bool):Int;\n\n\t/**\n\t\tReads a signed 16 bit integer from the buffer at the specified `offset` with big-endian format.\n\n\t\tSet `noAssert` to `true` to skip validation of `offset`.\n\t\tThis means that `offset` may be beyond the end of the buffer. Defaults to `false`.\n\n\t\tWorks as `readUInt16BE`, except buffer contents are treated as two's complement signed values.\n\t**/\n\tfunction readInt16BE(offset:Int, ?noAssert:Bool):Int;\n\n\t/**\n\t\tReads a signed 32 bit integer from the buffer at the specified `offset` with little-endian format.\n\n\t\tSet `noAssert` to `true` to skip validation of `offset`.\n\t\tThis means that `offset` may be beyond the end of the buffer. Defaults to `false`.\n\n\t\tWorks as `readUInt32LE`, except buffer contents are treated as two's complement signed values.\n\t**/\n\tfunction readInt32LE(offset:Int, ?noAssert:Bool):Int;\n\n\t/**\n\t\tReads a signed 32 bit integer from the buffer at the specified `offset` with big-endian format.\n\n\t\tSet `noAssert` to `true` to skip validation of `offset`.\n\t\tThis means that `offset` may be beyond the end of the buffer. Defaults to `false`.\n\n\t\tWorks as `readUInt32BE`, except buffer contents are treated as two's complement signed values.\n\t**/\n\tfunction readInt32BE(offset:Int, ?noAssert:Bool):Int;\n\n\t/**\n\t\tReads a 32 bit float from the buffer at the specified `offset` with little-endian format.\n\n\t\tSet `noAssert` to `true` to skip validation of `offset`.\n\t\tThis means that `offset` may be beyond the end of the buffer. Defaults to `false`.\n\t**/\n\tfunction readFloatLE(offset:Int, ?noAssert:Bool):Float;\n\n\t/**\n\t\tReads a 32 bit float from the buffer at the specified `offset` with big-endian format.\n\n\t\tSet `noAssert` to `true` to skip validation of `offset`.\n\t\tThis means that `offset` may be beyond the end of the buffer. Defaults to `false`.\n\t**/\n\tfunction readFloatBE(offset:Int, ?noAssert:Bool):Float;\n\n\t/**\n\t\tReads a 64 bit double from the buffer at the specified `offset` with little-endian format.\n\n\t\tSet `noAssert` to `true` to skip validation of `offset`.\n\t\tThis means that `offset` may be beyond the end of the buffer. Defaults to `false`.\n\t**/\n\tfunction readDoubleLE(offset:Int, ?noAssert:Bool):Float;\n\n\t/**\n\t\tReads a 64 bit double from the buffer at the specified `offset` with big-endian format.\n\n\t\tSet `noAssert` to `true` to skip validation of `offset`.\n\t\tThis means that `offset` may be beyond the end of the buffer. Defaults to `false`.\n\t**/\n\tfunction readDoubleBE(offset:Int, ?noAssert:Bool):Float;\n\n\t/**\n\t\tWrites `value` to the buffer at the specified `offset`.\n\t\tNote, `value` must be a valid unsigned 8 bit integer.\n\n\t\tSet `noAssert` to `true` to skip validation of `value` and `offset`.\n\t\tThis means that `value` may be too large for the specific function\n\t\tand `offset` may be beyond the end of the buffer leading to the values\n\t\tbeing silently dropped. This should not be used unless you are certain\n\t\tof correctness. Defaults to `false`.\n\t**/\n\tfunction writeUInt8(value:Int, offset:Int, ?noAssert:Bool):Void;\n\n\t/**\n\t\tWrites `value` to the buffer at the specified `offset` with little-endian format.\n\t\tNote, `value` must be a valid unsigned 16 bit integer.\n\n\t\tSet `noAssert` to `true` to skip validation of `value` and `offset`.\n\t\tThis means that `value` may be too large for the specific function\n\t\tand `offset` may be beyond the end of the buffer leading to the values\n\t\tbeing silently dropped. This should not be used unless you are certain\n\t\tof correctness. Defaults to `false`.\n\t**/\n\tfunction writeUInt16LE(value:Int, offset:Int, ?noAssert:Bool):Void;\n\n\t/**\n\t\tWrites `value` to the buffer at the specified `offset` with big-endian format.\n\t\tNote, `value` must be a valid unsigned 16 bit integer.\n\n\t\tSet `noAssert` to `true` to skip validation of `value` and `offset`.\n\t\tThis means that `value` may be too large for the specific function\n\t\tand `offset` may be beyond the end of the buffer leading to the values\n\t\tbeing silently dropped. This should not be used unless you are certain\n\t\tof correctness. Defaults to `false`.\n\t**/\n\tfunction writeUInt16BE(value:Int, offset:Int, ?noAssert:Bool):Void;\n\n\t/**\n\t\tWrites `value` to the buffer at the specified `offset` with little-endian format.\n\t\tNote, `value` must be a valid unsigned 32 bit integer.\n\n\t\tSet `noAssert` to `true` to skip validation of `value` and `offset`.\n\t\tThis means that `value` may be too large for the specific function\n\t\tand `offset` may be beyond the end of the buffer leading to the values\n\t\tbeing silently dropped. This should not be used unless you are certain\n\t\tof correctness. Defaults to `false`.\n\t**/\n\tfunction writeUInt32LE(value:Int, offset:Int, ?noAssert:Bool):Void;\n\n\t/**\n\t\tWrites `value` to the buffer at the specified `offset` with big-endian format.\n\t\tNote, `value` must be a valid unsigned 32 bit integer.\n\n\t\tSet `noAssert` to `true` to skip validation of `value` and `offset`.\n\t\tThis means that `value` may be too large for the specific function\n\t\tand `offset` may be beyond the end of the buffer leading to the values\n\t\tbeing silently dropped. This should not be used unless you are certain\n\t\tof correctness. Defaults to `false`.\n\t**/\n\tfunction writeUInt32BE(value:Int, offset:Int, ?noAssert:Bool):Void;\n\n\t/**\n\t\tWrites `value` to the buffer at the specified `offset`.\n\t\tNote, `value` must be a valid signed 8 bit integer.\n\n\t\tSet `noAssert` to `true` to skip validation of `value` and `offset`.\n\t\tThis means that `value` may be too large for the specific function\n\t\tand `offset` may be beyond the end of the buffer leading to the values\n\t\tbeing silently dropped. This should not be used unless you are certain\n\t\tof correctness. Defaults to `false`.\n\n\t\tWorks as `writeUInt8`, except `value` is written out as a two's complement signed integer into buffer.\n\t**/\n\tfunction writeInt8(value:Int, offset:Int, ?noAssert:Bool):Void;\n\n\t/**\n\t\tWrites `value` to the buffer at the specified `offset` with little-endian format.\n\t\tNote, value must be a valid signed 16 bit integer.\n\n\t\tSet `noAssert` to `true` to skip validation of `value` and `offset`.\n\t\tThis means that `value` may be too large for the specific function\n\t\tand `offset` may be beyond the end of the buffer leading to the values\n\t\tbeing silently dropped. This should not be used unless you are certain\n\t\tof correctness. Defaults to `false`.\n\n\t\tWorks as `writeUInt16LE`, except `value` is written out as a two's complement signed integer into buffer.\n\t**/\n\tfunction writeInt16LE(value:Int, offset:Int, ?noAssert:Bool):Void;\n\n\t/**\n\t\tWrites `value` to the buffer at the specified `offset` with big-endian format.\n\t\tNote, value must be a valid signed 16 bit integer.\n\n\t\tSet `noAssert` to `true` to skip validation of `value` and `offset`.\n\t\tThis means that `value` may be too large for the specific function\n\t\tand `offset` may be beyond the end of the buffer leading to the values\n\t\tbeing silently dropped. This should not be used unless you are certain\n\t\tof correctness. Defaults to `false`.\n\n\t\tWorks as `writeUInt16BE`, except `value` is written out as a two's complement signed integer into buffer.\n\t**/\n\tfunction writeInt16BE(value:Int, offset:Int, ?noAssert:Bool):Void;\n\n\t/**\n\t\tWrites `value` to the buffer at the specified `offset` with little-endian format.\n\t\tNote, value must be a valid signed 32 bit integer.\n\n\t\tSet `noAssert` to `true` to skip validation of `value` and `offset`.\n\t\tThis means that `value` may be too large for the specific function\n\t\tand `offset` may be beyond the end of the buffer leading to the values\n\t\tbeing silently dropped. This should not be used unless you are certain\n\t\tof correctness. Defaults to `false`.\n\n\t\tWorks as `writeUInt32LE`, except `value` is written out as a two's complement signed integer into buffer.\n\t**/\n\tfunction writeInt32LE(value:Int, offset:Int, ?noAssert:Bool):Void;\n\n\t/**\n\t\tWrites `value` to the buffer at the specified `offset` with big-endian format.\n\t\tNote, value must be a valid signed 32 bit integer.\n\n\t\tSet `noAssert` to `true` to skip validation of `value` and `offset`.\n\t\tThis means that `value` may be too large for the specific function\n\t\tand `offset` may be beyond the end of the buffer leading to the values\n\t\tbeing silently dropped. This should not be used unless you are certain\n\t\tof correctness. Defaults to `false`.\n\n\t\tWorks as `writeUInt32BE`, except `value` is written out as a two's complement signed integer into buffer.\n\t**/\n\tfunction writeInt32BE(value:Int, offset:Int, ?noAssert:Bool):Void;\n\n\t/**\n\t\tWrites `value` to the buffer at the specified `offset` with little-endian format.\n\t\tNote, behavior is unspecified if `value` is not a 32 bit float.\n\n\t\tSet `noAssert` to `true` to skip validation of `value` and `offset`.\n\t\tThis means that `value` may be too large for the specific function\n\t\tand `offset` may be beyond the end of the buffer leading to the values\n\t\tbeing silently dropped. This should not be used unless you are certain\n\t\tof correctness. Defaults to `false`.\n\t**/\n\tfunction writeFloatLE(value:Float, offset:Int, ?noAssert:Bool):Void;\n\n\t/**\n\t\tWrites `value` to the buffer at the specified `offset` with big-endian format.\n\t\tNote, behavior is unspecified if `value` is not a 32 bit float.\n\n\t\tSet `noAssert` to `true` to skip validation of `value` and `offset`.\n\t\tThis means that `value` may be too large for the specific function\n\t\tand `offset` may be beyond the end of the buffer leading to the values\n\t\tbeing silently dropped. This should not be used unless you are certain\n\t\tof correctness. Defaults to `false`.\n\t**/\n\tfunction writeFloatBE(value:Float, offset:Int, ?noAssert:Bool):Void;\n\n\t/**\n\t\tWrites `value` to the buffer at the specified `offset` with little-endian format.\n\t\tNote, `value` must be a valid 64 bit double.\n\n\t\tSet `noAssert` to `true` to skip validation of `value` and `offset`.\n\t\tThis means that `value` may be too large for the specific function\n\t\tand `offset` may be beyond the end of the buffer leading to the values\n\t\tbeing silently dropped. This should not be used unless you are certain\n\t\tof correctness. Defaults to `false`.\n\t**/\n\tfunction writeDoubleLE(value:Float, offset:Int, ?noAssert:Bool):Void;\n\n\t/**\n\t\tWrites `value` to the buffer at the specified `offset` with big-endian format.\n\t\tNote, `value` must be a valid 64 bit double.\n\n\t\tSet `noAssert` to `true` to skip validation of `value` and `offset`.\n\t\tThis means that `value` may be too large for the specific function\n\t\tand `offset` may be beyond the end of the buffer leading to the values\n\t\tbeing silently dropped. This should not be used unless you are certain\n\t\tof correctness. Defaults to `false`.\n\t**/\n\tfunction writeDoubleBE(value:Float, offset:Int, ?noAssert:Bool):Void;\n\n\t/**\n\t\tFills the buffer with the specified `value`.\n\t\tIf the `offset` (defaults to 0) and `end` (defaults to `buffer.length`)\n\t\tare not given it will fill the entire buffer.\n\n\t\tThe method returns a reference to the `Buffer`, so calls can be chained.\n\t**/\n\t@:overload(function(value:String, encoding:String):Buffer {})\n\t@:overload(function(value:String, offset:Int, encoding:String):Buffer {})\n\t@:overload(function(value:String, offset:Int, end:Int, encoding:String):Buffer {})\n\t@:overload(function(value:String, ?offset:Int, ?end:Int):Buffer {})\n\tfunction fill(value:Int, ?offset:Int, ?end:Int):Buffer;\n\n\t/**\n\t\tReturns a boolean of whether `this` and `otherBuffer` have the same bytes.\n\t**/\n\tfunction equals(otherBuffer:Buffer):Bool;\n\n\t/**\n\t\tReturns a number indicating whether `this` comes before or after or is the same as the `otherBuffer` in sort order.\n\n\t\tThe optional `targetStart`, `targetEnd`, `sourceStart`, and `sourceEnd` arguments can be used\n\t\tto limit the comparison to specific ranges within the two `Buffer` objects.\n\t**/\n\tfunction compare(otherBuffer:Buffer, ?targetStart:Int, ?targetEnd:Int, ?sourceStart:Int, ?sourceEnd:Int):Int;\n\n\t/**\n\t\tOperates similar to `Array.indexOf` in that it returns either\n\n\t\tthe starting index position of value in `Buffer` or -1 if the `Buffer` does not contain value.\n\t\tThe value can be a String, Buffer or Number. Strings are by default interpreted as UTF8.\n\t\tBuffers will use the entire `Buffer` (to compare a partial `Buffer` use buf.slice()).\n\t\tNumbers can range from 0 to 255.\n\t**/\n\t@:overload(function(value:String, byteOffset:Int, ?encoding:String):Int {})\n\t@:overload(function(value:String, ?encoding:String):Int {})\n\t@:overload(function(value:Buffer, ?byteOffset:Int):Int {})\n\tfunction indexOf(value:Int, ?byteOffset:Int):Int;\n\n\t/**\n\t\tIdentical to `indexOf`, but searches the `Buffer` from back to front instead of front to back.\n\n\t\tReturns the starting index position of value in `Buffer` or -1 if the `Buffer` does not contain value.\n\t\tThe value can be a String, Buffer or Number. Strings are by default interpreted as UTF8.\n\t\tIf `byteOffset` is provided, will return the last match that begins at or before `byteOffset`.\n\t**/\n\t@:overload(function(value:String, byteOffset:Int, ?encoding:String):Int {})\n\t@:overload(function(value:String, ?encoding:String):Int {})\n\t@:overload(function(value:Buffer, ?byteOffset:Int):Int {})\n\tfunction lastIndexOf(value:Int, ?byteOffset:Int):Int;\n\n\t// TODO: we don't have Array.includes in Haxe yet, so the doc would be lying\n\t@:overload(function(value:String, byteOffset:Int, ?encoding:String):Bool {})\n\t@:overload(function(value:String, ?encoding:String):Bool {})\n\t@:overload(function(value:Buffer, ?byteOffset:Int):Bool {})\n\tfunction includes(value:Int, ?byteOffset:Int):Bool;\n\n\t/**\n\t\tCreate `haxe.io.Bytes` object that uses the same underlying data storage as `this` buffer.\n\t\tAny modifications done using the returned object will be reflected in the `this` buffer.\n\t**/\n\tinline function hxToBytes():haxe.io.Bytes {\n\t\treturn Helper.bytesOfBuffer(this);\n\t}\n\n\t/**\n\t\tCreate `Buffer` object from `haxe.io.Bytes` using the same underlying data storage.\n\t\tAny modifications done using the returned object will be reflected in given `haxe.io.Bytes` object.\n\t**/\n\tstatic inline function hxFromBytes(b:haxe.io.Bytes):Buffer {\n\t\tvar data = @:privateAccess b.b;\n\t\treturn Buffer.from(data.buffer, data.byteOffset, b.length);\n\t}\n}\n\n@:dce\nprivate class Helper {\n\tpublic static function bytesOfBuffer(b:Buffer):haxe.io.Bytes untyped {\n\t\tvar o = Object.create(haxe.io.Bytes.prototype);\n\t\t// the following is basically a haxe.io.Bytes constructor,\n\t\t// but using given buffer instead of creating new Uint8Array\n\t\to.length = b.byteLength;\n\t\to.b = b;\n\t\tb.bufferValue = b;\n\t\tb.hxBytes = o;\n\t\tb.bytes = b;\n\t\treturn o;\n\t}\n}\n","package server;\n\nimport js.node.Process;\nimport js.node.Buffer;\nimport server.externs.express.Request;\nimport server.externs.express.Response;\nimport server.externs.express.Express;\nimport server.externs.express.Static;\nimport js.node.Path;\nimport js.Node;\n//import js.node.http.ServerResponse as Response;\n\ntypedef ExpressApp = server.externs.express.Express;\n\n\n// Bridge to do the config heavylifting directly in js/ts and the more Haxey-specific one here (tink-related)\n@:jsRequire('./setup-express-app', 'default')\nextern class SetupFromTypescript {\n  @:selfCall static function call(app: ExpressApp): ExpressApp;\n}\n\nclass Main {\n  static var app = new Express();\n\n  public static function main() {\n    var chalk = js.Lib.require('chalk');\n    /*var path = js.Lib.require('path');\n   // var html = js.Lib.require('./html');\n    \n    app.set('view engine', 'ejs');\n    app.use('/assets', new Static(Path.join(Node.__dirname, '..', '..', '..', 'assets')));\n\n    app.use(Routes.apiRouter());\n    app.use(Routes.staticRouter());\n    app.use(Routes.pagesRouter());*/\n    app.use('/tink_api', (a: Request, b: Response, next) -> { TinkAPI.main(a, b); });\n\n    app = SetupFromTypescript.call(app);\n\n    app.listen(\n      Config.SERVER_PORT,\n      () -> { \n        trace('Express server listening on port ${Config.SERVER_PORT}'); \n     });\n  }\n}\n","package server;\n\nimport tink.core.Future.JsPromiseTools;\nimport tink.http.containers.*;\nimport tink.http.Response;\nimport tink.web.routing.*;\nimport tink.http.Request;\nimport tink.io.Source;\nimport tink.io.Sink;\nimport tink.http.Response;\n\nimport ApiResult.Result;\n\n// Simple API example, not a proxy\n\nclass Root {\n    public function new() {}\n\n    @:get('/')\n    @:get('/print/$name')\n    public function hello(name = 'World'):Result\n        return  {\n            slideshow: {\n                title: 'Look!',\n                author: 'Mr. Bean',\n                date: '2018-08-08',\n                slides: [\n                    {\n                        title: 'Woohoo',\n                        type: 'silly',\n                        items: ['item_foo', 'item_bar']\n                    }\n                ]\n            }\n\n        }\n}\n\n// Kevin has samples of how to organize the API including a Stripe one, check them out\n\nclass TinkAPI {\n    public static var main = {\n        var router = new Router<Root>(new Root());\n        NodeContainer.toNodeHandler(req -> router.route(Context.ofRequest(req)).recover(OutgoingResponse.reportError));\n    }\n}\n","package tink.web.macros;\n\nimport haxe.ds.Option;\nimport haxe.macro.Context;\nimport haxe.macro.Type;\nimport haxe.macro.Expr;\nimport tink.macro.BuildCache;\nimport tink.http.Method;\nimport tink.web.macros.Route;\nimport tink.web.macros.RouteCollection;\nimport tink.web.macros.RoutePath;\nimport tink.web.macros.RouteSignature;\nimport tink.web.macros.Variant;\nimport tink.web.macros.MimeType;\nimport tink.web.routing.Response;\n\nusing tink.MacroApi;\nusing tink.CoreApi;\nusing Lambda;\n\nclass Routing { \n  \n  var routes:RouteCollection;\n  var auth:Option<{ user: Type, session: Type }>;\n  \n  var cases:Array<Case> = [];\n  var fields:Array<Field> = [];\n  \n  var depth:Int = 0;\n  var named:Array<String> = [];\n  var nameIndex:Map<String, Int> = new Map();\n  var ctx:ComplexType;\n  \n  function new(routes, auth) {\n    \n    this.routes = routes;\n    this.auth = auth;\n    firstPass();\n    ctx = \n      switch auth {\n        case Some(a):\n          var user = a.user.toComplex(),\n              session = a.session.toComplex();\n          macro : tink.web.routing.Context.AuthedContext<$user, $session>;\n        case None:\n          macro : tink.web.routing.Context;\n      }\n  }\n  \n  function firstPass() {\n    //during the first pass we skim all routes to map out their depths and named parameters\n    for (route in routes) {\n      \n      function skim(variants:Iterable<Variant>) \n        for (v in variants) {\n          \n          switch v.path.parts.length {\n            case sup if (sup > depth):\n              depth = sup;\n            default:\n          }\n          \n          for (name in v.path.query.keys())\n            if (!nameIndex.exists(name))\n              nameIndex[name] = named.push(name) - 1;\n        }\n      \n      switch route.kind {\n        case KSub(variants):\n          skim(variants);\n        case KCall(c):\n          skim(c.variants);\n      }\n      \n    } \n    \n  }\n  \n  function makeCase(field:String, funcArgs:Array<FunctionArg>, v:Variant, method:Option<Method>):Case {\n    if (v.path.deviation.missing.length > 0)\n      v.path.pos.error('Route does not capture all required variables. See warnings.');\n      \n    var pattern = [\n      switch method {\n        case Some(m): macro $i{m};\n        case None: IGNORE;\n      },\n    ];\n    \n    for (i in 0...depth * 2 + named.length * 2 + 1)\n      pattern.push(IGNORE);\n      \n    for (i in 0...v.path.parts.length)\n      pattern[i + 1 + depth] = macro true;\n      \n    if (v.path.rest == RNotAllowed)\n      pattern[depth + 1 + v.path.parts.length] = macro false;\n      \n    var captured = new Map();\n      \n    function part(p)\n      return switch p {\n        case PConst(v): \n          macro $v{v.toString()};                \n        case PCapture(name): \n          captured[name] = true;\n          macro $i{name};\n      }\n      \n    for (i in 0...v.path.parts.length)\n      pattern[i + 1] = part(v.path.parts[i]);\n      \n    for (name in v.path.query.keys()) {\n      \n      var index = nameIndex[name];\n      \n      pattern[2 + index + depth * 2] = macro true;\n      pattern[2 + index + depth * 2 + named.length] = part(v.path.query[name]);\n    }\n    \n    var callArgs = [for (a in funcArgs) \n      switch a.name {\n        case '__depth__': \n          macro $v{v.path.parts.length};\n        case 'user' | 'session': \n          macro $i{a.name};\n        default:\n          if (a == funcArgs[0] || captured[a.name]) \n            macro $i{a.name}\n          else \n            macro null;\n      }\n    ];\n\n    return { \n      values: [pattern.toArray(v.path.pos)],\n      expr: macro @:pos(v.path.pos) this.$field($a{callArgs}),\n    } \n  }  \n\n  function switchTarget() {\n    var ret = [macro ctx.header.method];\n    \n    for (i in 0...depth) \n      ret.push(macro ctx.part($v { i } ));\n      \n    for (i in 0...depth+1) \n      ret.push(macro l > $v{i});\n      \n    for (name in named) \n      ret.push(macro ctx.hasParam($v{name}));\n    \n    for (name in named) \n      ret.push(macro ctx.param($v{name}));\n      \n    return ret.toArray();\n  }\n  \n  function restrict(restricts:Array<Expr>, e:Expr) \n    return \n      switch [restricts, auth] {\n        case [[], _]: \n          e;\n        case [v, None]:\n          v[0].pos.error('restriction cannot be applied because no session handling is provided');\n        case [restricts, Some(_)]: \n          \n          for (v in restricts)\n            e = macro @:pos(v.pos) (${substituteThis(v)} : tink.core.Promise<Bool>).next(\n              function (authorized)\n                return \n                  if (authorized) $e;\n                  else new tink.core.Error(Forbidden, 'forbidden')\n            );    \n            \n          macro ctx.user.get().next(function (o) return switch o {\n            case Some(user):\n              $e;\n            case None:\n              new tink.core.Error(Unauthorized, 'not authorized');\n          });\n      }\n  \n  function generate(name:String, pos:Position) {\n    \n    secondPass();\n\n    var theSwitch = ESwitch(\n      switchTarget(), \n      cases, \n      macro @:pos(pos) new tink.core.Error(NotFound, 'Not Found: [' + ctx.header.method + '] ' + ctx.header.url.pathWithQuery)\n    ).at(pos);\n    \n    theSwitch = restrict(routes.restricts, theSwitch);\n      \n    var target = routes.type.toComplex();\n    \n    var ret = \n      macro class $name {\n        \n        var target:$target;\n        \n        public function new(target) {\n          this.target = target;\n        }\n        \n        public function route(ctx:$ctx):tink.core.Promise<tink.http.Response.OutgoingResponse> {\n          var l = ctx.pathLength;\n          return $theSwitch;\n        }\n      };\n    \n    for (f in fields)\n      ret.fields.push(f);\n    \n    return ret;    \n  }\n  \n  function routeMethod(route:Route) {\n    var separate = new Map<ParamLocation, Array<Field>>(),\n        compound = new Map<ParamLocation, Array<Named<Type>>>(),\n        pos = route.field.pos,\n        callArgs = [],\n        funcArgs:Array<FunctionArg> = [{\n          name: 'ctx',\n          type: ctx,\n        }];\n        \n    var field = route.field.name;\n            \n    var beforeBody = [function (e) return restrict(route.restricts, e)];\n    \n    for (arg in route.signature.args) {\n      \n      var argExpr = arg.name.resolve();\n\n      switch arg.kind {\n        case ACapture:\n\n          var expected = arg.type.toComplex();\n          var enumAbstract = switch arg.type {\n            case TAbstract(_.get() => {module: module, name: name, type: underlying, meta: meta, impl: impl}, _) if(meta.has(':enum')):\n              var path = ('$module.$name').split('.');\n              Some({\n                underlying: underlying, \n                fields: impl.get().statics.get()\n                  .filter(function(s) return s.meta.has(':enum') && s.meta.has(':impl'))\n                  .map(function(s) return macro $p{path.concat([s.name])})\n              });\n            case _:\n              None;\n          }\n          \n          var parsed = switch enumAbstract {\n            case Some({fields: fields, underlying: underlying}):\n              var ct = underlying.toComplex();\n              ESwitch(\n                macro (s:$ct), \n                [{expr: macro cast s, values: fields}],\n                macro throw 'Invalid value \"' + s + '\" for field: ' + $v{arg.name}\n              ).at(route.field.pos);\n            case None:\n              macro @:pos(route.field.pos) s;\n          }\n          \n          argExpr = macro @:pos(route.field.pos) switch $argExpr.parse(function (s:tink.Stringly):$expected return $parsed) {\n            case Success(v): v;\n            case Failure(e): return tink.core.Promise.lift(e);\n          }\n\n          funcArgs.push({\n            name: arg.name,\n            type: macro : tink.Stringly,\n            opt: arg.optional,\n          });\n          \n        case AParam(t, loc, PCompound):\n          \n          if (!compound.exists(loc))\n            compound[loc] = [];\n            \n          compound[loc].push(new Named(arg.name, t));\n          \n        case AParam(t, loc, PSeparate):\n          \n          if (!separate.exists(loc))\n            separate[loc] = [];\n            \n          separate[loc].push({\n            name: arg.name,\n            pos: route.field.pos,\n            kind: FVar(t.toComplex()),\n          });\n          \n        case AUser(u):        \n\n          beforeBody.push(function (e:Expr) {\n            \n            switch u.getID() {\n              case 'haxe.ds.Option':\n              default:\n                e = macro @:pos(e.pos) switch user {\n                  case Some(user): $e;\n                  case None: new tink.core.Error(Unauthorized, 'unauthorized');\n                }\n            }          \n            \n            return macro @:pos(e.pos) ctx.user.get().next(function (user) return $e);\n          });\n        case AContext:\n          var name = arg.name;\n          beforeBody.push(function (e:Expr) return macro @:pos(e.pos) {\n            var $name = ctx;\n            $e;\n          });\n        default:\n          \n          throw 'not implemented: '+arg.kind;\n      }\n      \n      callArgs.push(\n        if (arg.optional) \n          macro switch $i{arg.name} {\n            case null: null;\n            default: $argExpr;\n          }\n        else argExpr\n      );        \n    }\n     \n    var result = macro @:pos(pos) this.target.$field;\n    \n    if (route.field.type.reduce().match(TFun(_, _)))\n      result = macro @:pos(pos) $result($a{callArgs});\n    \n    result = \n      switch route.kind {\n        case KSub(s):\n          funcArgs.push({\n            name: '__depth__',\n            type: macro : Int,\n          });\n          \n          var target = route.signature.result.asSubTarget().toComplex();\n          \n          var router = switch auth {\n            case None:\n              macro @:pos(pos) new tink.web.routing.Router<$target>(__target__);\n            case Some(_.session.toComplex() => s):\n              macro @:pos(pos) new tink.web.routing.Router<$s, $target>(__target__);\n          }\n          beforeBody.push(function (e) return macro {\n            var ctx = ctx.sub(__depth__);\n            $e;\n          });\n          //trace(result.toString());\n          macro @:pos(pos) {\n            \n            tink.core.Promise.lift($result)\n              .next(function (__target__:$target) \n                return $router.route(ctx)\n              );\n          }\n        case KCall({variants: c, statusCode: statusCode, headers: headers, html: html}):\n          var headers = [for(h in headers) macro new tink.http.Header.HeaderField(${h.name}, ${h.value})];\n          switch route.signature.result.asCallResponse() {\n            case RNoise:\n              macro @:pos(pos) tink.core.Promise.lift($result).next(\n                function (_):tink.core.Promise<tink.web.routing.Response> {\n                  return tink.web.routing.Response.empty();\n                }\n              );\n            case RData(t):\n              var ct = t.toComplex();\n              var formats = [];\n              \n              switch html {\n                case Some(v):\n                  formats.push(\n                    macro @:pos(v.pos) if (ctx.accepts('text/html')) \n                      return tink.core.Promise.lift(${substituteThis(v)}(__data__)).next(\n                        function (d) return tink.web.routing.Response.textual('text/html', d)\n                      )\n                  );\n                case None:\n              }\n              \n              for (fmt in route.produces) \n                formats.push(\n                  macro @:pos(pos) if (ctx.accepts($v{fmt}))\n                    return tink.web.routing.Response.textual(\n                      $statusCode,\n                      $v{fmt},\n                      ${MimeType.writers.get([fmt], t, pos).generator}(__data__),\n                      $a{headers}\n                    )\n                );\n                \n              macro @:pos(pos) tink.core.Promise.lift($result).next(\n                function (__data__:$ct):tink.core.Promise<tink.web.routing.Response> {\n                  $b{formats};\n                  return new tink.core.Error(UnsupportedMediaType, 'Unsupported Media Type');\n                }\n              );\n            \n            case ROpaque(OParsed(res, t)):\n              // @:statusCode and @:header is ignored here, we should probably error/warn\n              var ct = res.toComplex();\n              var formats = [];\n              \n              switch html {\n                case Some(v):\n                  formats.push(\n                    macro @:pos(v.pos) if (ctx.accepts('text/html')) \n                      return tink.core.Promise.lift(${substituteThis(v)}(__data__)).next(\n                        function (d) return tink.web.routing.Response.textual('text/html', d)\n                      )\n                  );\n                case None:\n              }\n              \n              for (fmt in route.produces) \n                formats.push(\n                  macro @:pos(pos) if (ctx.accepts($v{fmt})) return ${{\n                    macro new tink.http.Response.OutgoingResponse(\n                      __data__.header.concat([new tink.http.Header.HeaderField(CONTENT_TYPE, $v{fmt})]),\n                      ${MimeType.writers.get([fmt], t, pos).generator}(__data__.body)\n                    );\n                  }});\n                \n              macro @:pos(pos) tink.core.Promise.lift($result).next(\n                function (__data__:$ct):tink.core.Promise<tink.web.routing.Response> {\n                  $b{formats};\n                  return new tink.core.Error(UnsupportedMediaType, 'Unsupported Media Type');\n                }\n              );\n              \n            case ROpaque(ORaw(_.toComplex() => t)):\n              var e = macro @:pos(pos) tink.core.Promise.lift($result)\n                .next(function (v:$t):tink.web.routing.Response return v);\n              switch [statusCode, headers] {\n                case [macro 200, []]:\n                  e;\n                case [macro 200, _]:\n                  macro $e.next(function(res) return new tink.http.Response.OutgoingResponse(\n                    res.header.concat(${macro $a{headers}}),\n                    res.body\n                  ));\n                case [_, []]:\n                  macro $e.next(function (res) return new tink.http.Response.OutgoingResponse(\n                    new tink.http.Response.ResponseHeader($statusCode, $statusCode, @:privateAccess res.header.fields, res.header.protocol),\n                    res.body\n                  ));\n                case _: \n                  macro $e.next(function (res) return new tink.http.Response.OutgoingResponse(\n                    new tink.http.Response.ResponseHeader($statusCode, $statusCode, @:privateAccess res.header.fields.concat(${macro $a{headers}}), res.header.protocol),\n                    res.body\n                  ));\n              }\n          }\n      }\n      \n    for (loc in [PBody, PQuery, PHeader]) {\n      \n      var locName = loc.getName().substr(1).toLowerCase();\n      var locVar = '__${locName}__';\n      \n      result = \n        switch [loc, route.getPayload(loc)] {\n          case [_, Empty]:\n            \n            result;\n            \n          case [PBody, SingleCompound(name, is(_, 'haxe.io.Bytes') => true)]:\n            \n            macro @:pos(pos) \n              ctx.allRaw()\n                .next(function ($name:tink.Chunk) \n                  return $result\n                );            \n                \n          case [PBody, SingleCompound(name, is(_, 'String') => true)]:\n            \n            macro @:pos(pos) \n              ctx.allRaw()\n                .next(function ($name:tink.Chunk) {\n                  var $name = $i{name}.toString();\n                  return $result;\n                });\n                \n          case [PBody, SingleCompound(name, is(_, 'tink.io.Source') => true)]:\n            \n            macro @:pos(pos) {\n              var $name = ctx.rawBody;\n              $result;\n            }\n            \n          case [_, SingleCompound(name, _.toComplex() => t)]:\n            \n            macro @:pos(pos) return ${parse(loc, route, t)}.next(function ($name) {\n              return $result;\n            });\n            \n          case [_, Mixed(separate, compound, t)]:\n            \n            function dissect() {\n              var target = locVar.resolve();\n              var parts:Array<Var> = [];\n              \n              if (separate != null)\n                for (s in separate)\n                  parts.push({ name: s.name, type: null, expr: target.field(s.name) });\n              \n              for (c in compound) \n                if (c.name != '')\n                  switch c.value.reduce().toComplex() {//TODO: deduplicate - we're getting this above already\n                    case TAnonymous(fields):\n                      parts.push({ \n                        name: c.name, \n                        type: TAnonymous(fields),\n                        expr: EObjectDecl([for (f in fields) {\n                          field: f.name,\n                          expr: target.field(f.name)\n                        }]).at(),\n                      });\n                    case v:\n                      throw 'assert';\n                  };\n                \n              return EVars(parts).at();\n            }  \n            \n            macro @:pos(pos) return ${parse(loc, route, t)}.next(function ($locVar:$t) {\n              ${dissect()};\n              return $result;\n            });\n        }\n        \n      if (loc == PBody) \n        for (f in beforeBody)\n          result = f(result);\n    }    \n    \n    var f:Function = {\n      args: funcArgs,\n      expr: macro @:pos(result.pos) return $result,\n      ret: null,\n    }\n    \n    fields.push({\n      pos: pos,\n      name: route.field.name,\n      kind: FFun(f),\n    });\n    \n    return funcArgs;\n  }\n  \n  function secondPass() \n    for (route in routes) {\n      var args = routeMethod(route);\n            \n      switch route.kind {\n        case KCall(c):\n          for (v in c.variants)\n            cases.push(makeCase(route.field.name, args, v, v.method));\n        case KSub(variants):\n          for (v in variants)  \n            cases.push(makeCase(route.field.name, args, v, None));\n      }\n    }\n  \n  static var IGNORE = macro _;\n  \n  static function substituteThis(e:Expr)\n    return switch e {\n      case macro this.$field: \n        macro @:pos(e.pos) (@:privateAccess this.target.$field);\n      case macro this: \n        macro @:pos(e.pos) (@:privateAccess this.target);\n      default:\n        e.map(substituteThis);\n    }\n  \n  static function is(t:Type, name:String)\n    return Context.getType(name).unifiesWith(t);//This is odd ... https://github.com/haxetink/tink_web/issues/69\n    \n  static function parse(loc:ParamLocation, route:Route, payload:ComplexType):Expr \n    return\n      switch loc {\n        case PBody:\n          \n          bodyParser(payload, route);\n          \n        case PHeader:\n          \n          macro @:pos(route.field.pos) tink.core.Promise.lift(\n            new tink.querystring.Parser<tink.http.Header.HeaderValue->$payload>().tryParse(ctx.headers())\n          );\n          \n        case PQuery:\n          \n          macro @:pos(route.field.pos) tink.core.Promise.lift(\n            new tink.querystring.Parser<$payload>().tryParse(ctx.header.url.query)\n          );\n      }     \n      \n  static function bodyParser(payload:ComplexType, route:Route) {\n    var cases:Array<Case> = [],\n        structured = [],\n        pos = route.field.pos;\n    \n    for (type in route.consumes) \n      switch type {\n        case 'application/x-www-form-urlencoded' #if tink_multipart | 'multipart/form-data' #end: \n          structured.push(macro @:pos(pos) $v{type});\n        default: \n          cases.push({ \n            values: [macro $v{type}],\n            expr: macro @:pos(pos) ctx.allRaw().next(\n              function (b) return ${MimeType.readers.get([type], payload.toType(pos).sure(), pos).generator}(b.toString())\n            )\n          });\n      }\n    \n    switch structured {\n      case []:\n      case v:\n        cases.unshift({ \n          values: structured, \n          expr: macro @:pos(pos) ctx.parse().next(function (pairs)\n            return new tink.querystring.Parser<tink.web.forms.FormField->$payload>().tryParse(pairs)\n          ),\n        });\n    }\n    \n    var contentType = macro @:pos(pos) switch ctx.header.contentType() {\n      case Success(v): v.fullType;\n      default: 'application/json';\n    }\n    \n    cases.push({ \n      values: [macro invalid],\n      expr: macro new tink.core.Error(NotAcceptable, 'Cannot process Content-Type '+invalid),\n    });\n    \n    return macro @:pos(pos) (\n      ${ESwitch(contentType, cases, null).at(pos)} \n        : \n      tink.core.Promise<$payload>\n    );  \n  }\n  \n  static function build(ctx:BuildContextN) {\n    \n    var auth = None;\n    \n    var target = switch ctx.types {\n      case []:\n        switch Context.getCallArguments() {\n          case null | []:\n            ctx.pos.error('You must either specify a target type as type parameter or a target object as constructor argument');\n          case [v]:\n            v.typeof().sure();\n          case _:\n            ctx.pos.error('too many arguments - only one expected');\n        }\n      case [t]: t;\n      case [s, t]:\n        var sc = s.toComplex();\n        \n        var user = \n          (macro @:pos(ctx.pos) {\n            var x:$sc = null;\n            function test<U>(s:tink.web.Session<U>):U {\n              return null;\n            }\n            test(x);\n          }).typeof().sure();\n        \n        auth = Some({ session: s, user: user });\n        t;\n      default:\n        ctx.pos.error('Invalid usage');\n    }\n    \n    return new Routing(\n      new RouteCollection(\n        target,\n        [\n          #if tink_multipart 'multipart/form-data', #end\n          'application/x-www-form-urlencoded', \n          'application/json'\n        ], \n        ['application/json']\n      ),\n      auth\n    ).generate(ctx.name, ctx.pos);\n  }\n  \n  static function apply() {\n    return BuildCache.getTypeN('tink.web.routing.Router', build);\n  }\n  \n}\n","package tink.web.macros;\n\nimport tink.http.Method;\nimport tink.web.macros.Variant;\nimport tink.web.macros.RouteSignature;\nimport tink.web.macros.RouteResult;\nimport haxe.ds.Option;\nimport haxe.macro.Type;\nimport haxe.macro.Expr;\n\nusing tink.CoreApi;\nusing tink.MacroApi;\n\nclass Route {\n  \n  public static var metas = {\n    var ret = [for (m in [GET, HEAD, OPTIONS, PUT, POST, PATCH, DELETE]) ':$m'.toLowerCase() => Some(m)];\n    ret[':all'] = None;\n    ret;\n  }  \n  \n  public var field(default, null):ClassField;\n  public var kind(default, null):RouteKind;\n  public var signature(default, null):RouteSignature;\n  public var consumes(default, null):Array<MimeType>;\n  public var produces(default, null):Array<MimeType>;\n  public var restricts(default, null):Array<Expr>;\n  \n  public function new(f, consumes, produces) {\n    field = f;\n    signature = new RouteSignature(f);\n    switch [getCall(f, signature), getSub(f, signature)] {\n      case [[], []]:\n        f.pos.error('No routes on this field'); // should not happen actually\n      case [call, []]:\n        kind = KCall({\n          variants: call,\n          statusCode: \n            switch field.meta.extract(':statusCode') {\n              case []:\n                macro 200;\n              case [{params: [v]}]:\n                v;\n              case [v]:\n                v.pos.error('@:statusCode must have one argument exactly');\n              case v:\n                v[1].pos.error('Cannot have multiple @:statusCode directives');\n            },\n          headers:\n            [for(meta in field.meta.extract(':header'))\n              switch meta {\n                case {params: [name, value]}:\n                  new NamedWith(name, value);\n                case _:\n                  meta.pos.error('@:header must have two arguments exactly');\n              }\n            ],\n          html: \n            switch field.meta.extract(':html') {\n              case []:\n                None;\n              case [{ pos: pos, params: [v] }]:\n                Some(v);\n              case [v]:\n                v.pos.error('@:html must have one argument exactly');\n              case v:\n                v[1].pos.error('Cannot have multiple @:html directives');\n            }\n        });\n      case [[], sub]:\n        kind = KSub(sub);\n      case [_, _]:\n        f.pos.error('Cannot have both routing and subrouting on the same field');\n    }\n    this.consumes = MimeType.fromMeta(f.meta, 'consumes', consumes);\n    this.produces = MimeType.fromMeta(f.meta, 'produces', produces);\n    \n    restricts = getRestricts([field.meta]);\n  }\n  \n  public function getPayload(loc:ParamLocation):RoutePayload {\n    var compound = new Array<Named<Type>>(),\n        separate = new Array<Field>();\n        \n    for (arg in signature.args) \n      switch arg.kind {\n        case AParam(t, _ == loc => true, kind):\n          switch kind {\n            case PCompound:\n              compound.push(new Named(arg.name, t));\n            case PSeparate:\n              separate.push({\n                name: arg.name,\n                pos: field.pos,\n                kind: FVar(t.toComplex()),\n              });     \n          }\n        default:\n    }\n    \n    var locName = loc.getName().substr(1).toLowerCase();    \n    \n    return \n      switch [compound, separate] {\n        case [[], []]: \n          \n          Empty;\n          \n        case [[v], []]: \n          \n          SingleCompound(v.name, v.value);\n          \n        case [[], v]: \n        \n          Mixed(separate, compound, TAnonymous(separate));\n          \n        default:\n          //trace(TAnonymous(separate).toString());\n          var fields = separate.copy();\n          \n          for (t in compound)\n            switch t.value.reduce().toComplex() {\n              case TAnonymous(f):\n                for (f in f)\n                  fields.push(f);\n              default:\n                field.pos.error('If multiple types are defined for $locName then all must be anonymous objects');\n            }          \n            \n          Mixed(separate, compound, TAnonymous(fields));\n      }\n  }\n  \n  public static function hasWebMeta(f:ClassField) {\n    if (f.meta.has(':sub')) return true;\n    for (m in metas.keys()) if (f.meta.has(m)) return true;\n    return false;\n  }\n  \n  public static function getCall(f:ClassField, sig):Array<CallVariant> {\n    return [for(m in f.meta.get()) {\n        switch metas[m.name] {\n          case null: continue;\n          case v: { method: v, path: RoutePath.make(f.name, sig, m) }\n        }\n      }\n    ];\n  }\n  \n  public static function getSub(f:ClassField, sig):Array<Variant> {\n    return [for(m in f.meta.extract(':sub')) { path: RoutePath.make(f.name, sig, m) }];\n  }\n  \n  // TODO: move this to somewhere\n  public static function getRestricts(meta:Array<MetaAccess>):Array<Expr> {\n    return [for(meta in meta) for (m in meta.extract(':restrict'))\n      switch m.params {\n        case [v]:\n          v;\n        case _:\n          m.pos.error('@:restrict must have one parameter');\n      }\n    ];\n  }\n}\n\nenum RouteKind {\n  KSub(variants:Array<Variant>);\n  KCall(call:Call);\n}\n\ntypedef Call = {\n  variants:Array<CallVariant>,\n  statusCode:Expr,\n  headers:Array<NamedWith<Expr, Expr>>,\n  html:Option<Expr>,\n}\n\nenum RoutePayload {\n  Empty;\n  Mixed(separate:Array<Field>, compound:Array<Named<Type>>, sum:ComplexType);\n  SingleCompound(name:String, type:Type);\n}","package tink.http.containers;\n\nimport tink.http.Container;\nimport tink.http.Request;\nimport tink.http.Header;\nimport tink.io.*;\nimport js.node.http.*;\n\nusing tink.CoreApi;\n\nclass NodeContainer implements Container {\n  \n  var kind:ServerKind;\n  var upgradable:Bool;\n  \n  public function new(kind:ServerKind, ?opt:{?upgradable:Bool}) {\n    this.kind = kind;\n    this.upgradable = opt != null && opt.upgradable;\n  }\n  \n  static public function toNodeHandler(handler:Handler)\n    return \n      function (req:IncomingMessage, res:ServerResponse)\n        handler.process(\n          new IncomingRequest(\n            req.socket.remoteAddress, \n            IncomingRequestHeader.fromIncomingMessage(req),\n            Plain(Source.ofNodeStream('Incoming HTTP message from ${req.socket.remoteAddress}', req)))\n        ).handle(function (out) {\n          res.writeHead(out.header.statusCode, out.header.reason, cast [for (h in out.header) [(h.name : String), h.value]]);//TODO: readable status code\n          out.body.pipeTo(Sink.ofNodeStream('Outgoing HTTP response to ${req.socket.remoteAddress}', res)).handle(function (x) {\n            res.end();\n          });\n        });\n        \n  static public function toUpgradeHandler(handler:Handler)\n    return \n      function (req:js.node.http.IncomingMessage, socket:js.node.net.Socket, head:js.node.Buffer) {\n        handler.process(\n          new IncomingRequest(\n            req.socket.remoteAddress, \n            IncomingRequestHeader.fromIncomingMessage(req),\n            Plain(Source.ofNodeStream('Incoming HTTP message from ${req.socket.remoteAddress}', socket)))\n        ).handle(function (out) {\n          out.body.prepend(out.header.toString()).pipeTo(Sink.ofNodeStream('Outgoing HTTP response to ${req.socket.remoteAddress}', socket)).handle(function (_) {\n            socket.end();\n          });\n        });\n      }\n  \n  \n  public function run(handler:Handler) \n    return Future.async(function (cb) {\n      var failures = Signal.trigger();\n      \n      var server = switch kind {\n        case Instance(server):\n          server;\n          \n        case Port(port):\n          var server = new Server();\n          server.listen(port);\n          server;\n          \n        case Host(host):\n          var server = new Server();\n          server.listen(host.port, host.name);\n          server;\n          \n        case Path(path):\n          var server = new Server();\n          server.listen(path);\n          server;\n          \n        case Fd(fd):\n          var server = new Server();\n          server.listen(fd);\n          server;\n      }\n      \n      function tinkify(e:js.Error)\n        return Error.withData(e.message, e);\n        \n      server.on('error', function (e) {\n        cb(Failed(e));\n      });\n      \n      if(upgradable)\n        server.on('upgrade', toUpgradeHandler(handler));\n      \n      function onListen() {\n        cb(Running({ \n          shutdown: function (hard:Bool) {\n            if (hard)\n              trace('Warning: hard shutdown not implemented');\n              \n            return Future.async(function (cb) {\n              server.close(function () cb(true));\n            });\n          },\n          failures: failures,//TODO: these need to be triggered\n        }));\n      }\n      \n      if(untyped server.listening) // .listening added in v5.7.0, not added to hxnodejs yet\n        onListen()\n      else\n        server.on('listening', onListen);\n      \n      server.on('request', toNodeHandler(handler));\n      server.on('error', function(e) cb(Failed(e)));\n    });\n}\n\nprivate enum ServerKindBase {\n  Instance(server:Server);\n  Port(port:Int);\n  Host(host:tink.url.Host);\n  Path(path:String);\n  Fd(fd:{fd:Int});\n}\n\nabstract ServerKind(ServerKindBase) from ServerKindBase to ServerKindBase {\n  @:from\n  public static inline function fromInstance(server:Server):ServerKind\n    return Instance(server);\n    \n  @:from\n  public static inline function fromPort(port:Int):ServerKind\n    return Port(port);\n  \n  @:from\n  public static inline function fromHost(host:tink.url.Host):ServerKind\n    return Host(host);\n  \n  @:from\n  public static inline function fromPath(path:String):ServerKind\n    return Path(path);\n  \n  @:from\n  public static inline function fromFd(fd:{fd:Int}):ServerKind\n    return Fd(fd);\n}","package tink.io;\n\nimport haxe.io.Bytes;\nimport tink.io.Sink;\nimport tink.io.StreamParser;\nimport tink.streams.IdealStream;\nimport tink.streams.RealStream;\nimport tink.streams.Stream;\n\nusing tink.io.Source;\nusing tink.CoreApi;\n\n@:forward(reduce)\nabstract Source<E>(SourceObject<E>) from SourceObject<E> to SourceObject<E> to Stream<Chunk, E> from Stream<Chunk, E> { \n  \n  public static var EMPTY(default, null):IdealSource = Empty.make();\n  \n  @:to inline function dirty():Source<Error>\n    return cast this;\n  \n  public var depleted(get, never):Bool;\n    inline function get_depleted() return this.depleted;\n\n  #if (nodejs && !macro)\n  @:noUsing static public inline function ofNodeStream(name:String, r:js.node.stream.Readable.IReadable, ?options:{ ?chunkSize: Int, ?onEnd:Void->Void }):RealSource {\n    if (options == null) \n      options = {};\n    return tink.io.nodejs.NodejsSource.wrap(name, r, options.chunkSize, options.onEnd);\n  }\n  \n  public function toNodeStream():js.node.stream.Readable.IReadable {\n    var native = @:privateAccess new js.node.stream.PassThrough(); // https://github.com/HaxeFoundation/hxnodejs/pull/91\n    \n    var source = chunked();\n    function write() {\n      source.forEach(function(chunk:Chunk) {\n        var ok = native.write(js.node.Buffer.hxFromBytes(chunk.toBytes()));\n        return ok ? Resume : Finish;\n      }).handle(function(o) switch o {\n        case Depleted:\n          native.end();\n        case Halted(rest):\n          source = rest;\n          native.once('drain', write);\n        case Failed(e):\n          native.emit('error', new js.Error(e.message));\n      });\n    }\n    \n    write();\n    \n    return native;\n  }\n  #end\n  \n  #if js\n  @:noUsing static public inline function ofJsFile(name:String, file:js.html.File, ?options:{ ?chunkSize: Int }):RealSource\n    return ofJsBlob(name, file, options);\n    \n  @:noUsing static public inline function ofJsBlob(name:String, blob:js.html.Blob, ?options:{ ?chunkSize: Int }):RealSource {\n    var chunkSize = options == null || options.chunkSize == null ? 4096 : options.chunkSize;\n    return tink.io.js.BlobSource.wrap(name, blob, chunkSize);\n  }\n  #end\n  \n  #if cs\n  @:noUsing static public inline function ofCsStream(name:String, r:cs.system.io.Stream, ?options:{ ?chunkSize: Int }):RealSource {\n    var chunkSize = options == null || options.chunkSize == null ? 4096 : options.chunkSize;\n    return tink.io.cs.CsSource.wrap(name, r, chunkSize);\n  }\n  #end\n\n  @:noUsing static public inline function ofInput(name:String, input, ?options:{ ?chunkSize: Int, ?worker:Worker }):RealSource {\n    if (options == null)\n      options = {};\n    return new tink.io.std.InputSource(name, input, options.worker.ensure(), haxe.io.Bytes.alloc(switch options.chunkSize {\n      case null: 0x10000;\n      case v: v;\n    }), 0);\n  }\n  \n  public function chunked():Stream<Chunk, E>\n    return this;\n  \n  @:from static public function ofError(e:Error):RealSource\n    return (e : Stream<Chunk, Error>);\n\n  @:from static function ofFuture(f:Future<IdealSource>):IdealSource\n    return Stream.flatten((cast f:Future<Stream<Chunk, Noise>>)); // TODO: I don't understand why this needs a cast\n    \n  @:from static function ofPromised(p:Promise<RealSource>):RealSource\n    return Stream #if cs .dirtyFlatten #else .flatten #end (p.map(function (o) return switch o {\n      case Success(s): (s:SourceObject<Error>);\n      case Failure(e): ofError(e);\n    }));\n  \n  static public function concatAll<E>(s:Stream<Chunk, E>)\n    return s.reduce(Chunk.EMPTY, function (res:Chunk, cur:Chunk) return Progress(res & cur));\n\n  public function pipeTo<EOut, Result>(target:SinkYielding<EOut, Result>, ?options):Future<PipeResult<E, EOut, Result>> \n    return target.consume(this, options);\n  \n  public inline function append(that:Source<E>):Source<E> \n    return this.append(that);\n    \n  public inline function prepend(that:Source<E>):Source<E> \n    return this.prepend(that);\n    \n  public inline function transform<A>(transformer:Transformer<E, A>):Source<A>\n    return transformer.transform(this);\n    \n  public function skip(len:Int):Source<E> {\n    return this.regroup(function(chunks:Array<Chunk>) {\n      var chunk = chunks[0];\n      if(len <= 0) return Converted(Stream.single(chunk));\n      var length = chunk.length;\n      var out = Converted(if(len < length) Stream.single(chunk.slice(len, length)) else Empty.make());\n      len -= length;\n      return out;\n    });\n  }\n    \n  public function limit(len:Int):Source<E> {\n    if(len == 0) return cast Source.EMPTY;\n    return this.regroup(function(chunks:Array<Chunk>) {\n      if(len <= 0) return Terminated(None);\n      var chunk = chunks[0];\n      var length = chunk.length;\n      var out = \n        if(len == length)\n          Terminated(Some(Stream.single(chunk)));\n        else\n          Converted(Stream.single(if(len < length) chunk.slice(0, len) else chunk));\n      len -= length;\n      return out;\n    });\n  }\n    \n  @:from static inline function ofChunk<E>(chunk:Chunk):Source<E>\n    return new Single(chunk);\n    \n  @:from static inline function ofString<E>(s:String):Source<E>\n    return ofChunk(s);\n    \n  @:from static inline function ofBytes<E>(b:Bytes):Source<E>\n    return ofChunk(b);\n    \n}\n\ntypedef SourceObject<E> = StreamObject<Chunk, E>;//TODO: make this an actual subtype to add functionality on\n\ntypedef RealSource = Source<Error>;\n\nclass RealSourceTools {\n  static public function all(s:RealSource):Promise<Chunk>\n    return Source.concatAll(s).map(function (o) return switch o {\n      case Reduced(c): Success(c);\n      case Failed(e): Failure(e);\n    });\n\n  static public function parse<R>(s:RealSource, p:StreamParser<R>):Promise<Pair<R, RealSource>>\n    return StreamParser.parse(s, p).map(function (r) return switch r {\n      case Parsed(data, rest): Success(new Pair(data, rest));\n      case Invalid(e, _) | Broke(e): Failure(e);\n    });\n    \n  static public function split(src:RealSource, delim:Chunk):SplitResult<Error> {\n    var s = parse(src, new Splitter(delim));\n    // TODO: make all these lazy\n    return {\n      before: Stream #if cs .dirtyPromise #else .promise #end(s.next(function(p):SourceObject<Error> return switch p.a {\n        case Some(chunk): (chunk:RealSource);\n        case None: src;\n      })),\n      delimiter: s.next(function(p) return switch p.a {\n        case Some(_): delim;\n        case None: new Error(NotFound, 'Delimiter not found');\n      }),\n      after: Stream #if cs .dirtyPromise #else .promise #end(s.next(function(p):SourceObject<Error> return p.b)),\n    }\n  }\n  \n  static public function parseStream<R>(s:RealSource, p:StreamParser<R>):RealStream<R>\n    return StreamParser.parseStream(s, p);\n    \n  static public function idealize(s:RealSource, rescue:Error->RealSource):IdealSource\n    return (s.chunked().idealize(rescue):StreamObject<Chunk, Noise>);\n}\n\ntypedef IdealSource = Source<Noise>;\ntypedef SplitResult<E> = {\n  before:Source<E>,\n  delimiter:Promise<Chunk>,\n  after:Source<E>,\n}\n\nclass IdealSourceTools {\n  static public function all(s:IdealSource):Future<Chunk>\n    return Source.concatAll(s).map(function (o) return switch o {\n      case Reduced(c): c;\n    });\n    \n  static public function parse<R>(s:IdealSource, p:StreamParser<R>):Promise<Pair<R, IdealSource>>\n    return StreamParser.parse(s, p).map(function (r) return switch r {\n      case Parsed(data, rest): Success(new Pair(data, rest));\n      case Invalid(e, _): Failure(e);\n    });\n    \n  static public function parseStream<R>(s:IdealSource, p:StreamParser<R>):RealStream<R>\n    return StreamParser.parseStream(s, p);\n    \n  static public function split(s:IdealSource, delim:Chunk):SplitResult<Noise> {\n    var s = RealSourceTools.split((cast s:RealSource), delim);\n    // TODO: make all these lazy\n    return {\n      before: s.before.idealize(function(e) return Source.EMPTY),\n      delimiter: s.delimiter,\n      after: s.after.idealize(function(e) return Source.EMPTY),\n    }\n  }\n}\n","package tink.http;\n\nimport tink.io.StreamParser;\nimport tink.url.Query;\nimport haxe.crypto.Base64;\nimport haxe.io.Bytes;\n\nusing tink.CoreApi;\nusing StringTools;\n\nabstract ReadonlyMap<K, V>(Map<K, V>) from Map<K, V> {\n\n  @:arrayAccess public inline function get(key:K):V\n    return this.get(key);\n\n  @:arrayAccess public inline function exists(key:K):Bool\n    return this.exists(key);\n\n  public inline function iterator():Iterator<V>\n    return this.iterator();\n\n  public inline function keys():Iterator<K>\n    return this.keys();\n\n}\n\ntypedef Extensions = ReadonlyMap<String, String>;\n\nclass ContentType {\n  public var fullType(get, never):String;\n    inline function get_fullType()\n      return '$type/$subtype';\n      \n  public var type(default, null):String = '*';\n  public var subtype(default, null):String = '*';\n  public var extensions(default, null):Extensions;\n  public var raw(default, null):String; // TODO: figure out why can't make this private (php)\n  \n  function new() { \n    extensions = new Map();\n  }\n  \n  public function toString()\n    return raw;\n  \n  static public function ofString(s:String):ContentType {\n    var ret = new ContentType();\n    \n    ret.raw = s;\n    var parsed = (s:HeaderValue).parse();\n    var value = parsed[0].value;\n    switch value.indexOf('/') {\n      case -1:\n        ret.type = value;\n      case pos:\n        ret.type = value.substring(0, pos);\n        ret.subtype = value.substring(pos + 1);\n    }\n    ret.extensions = parsed[0].extensions;\n    \n    return ret;\n  }\n}\n\nclass Header {\n\n  var fields:Array<HeaderField>;\n  \n  public function new(?fields)\n    this.fields = switch fields {\n      case null: [];\n      case v: v;\n    }\n    \n  /**\n   *  Get all headers of the given name\n   *  @param name - Header name to retrieve\n   *  @return Array of headers of the given name\n   */\n  public function get(name:HeaderName)\n    return [for (f in fields) if (f.name == name) f.value];\n  \n  /**\n   *  Get a header\n   *  @param name - Header name to retrieve\n   *  @return `Success(header)` if there is exactly one entry of the given header name, `Failure(err)` otherwise\n   */\n  public function byName(name:HeaderName)\n    return switch get(name) {\n      case []:\n        Failure(new Error(UnprocessableEntity, headerNotFound(name)));\n      case [v]:\n        Success(v);\n      case v: \n        Failure(new Error(UnprocessableEntity, 'Multiple entries for $name header'));\n    }\n    \n  /**\n   *  Get the content type header\n   */\n  public function contentType() \n    return byName(CONTENT_TYPE).map(ContentType.ofString);\n    \n  public inline function iterator()\n    return fields.iterator();\n    \n  /**\n   *  Clone this header with additional header fields\n   *  @param fields - Header fields to be added\n   *  @return Header with additional fields\n   */\n  public function concat(fields:Array<HeaderField>):Header\n    return new Header(this.fields.concat(fields));\n  \n  /**\n   *  Get content length. Assumes zero if content-length header is missing\n   */\n  public function getContentLength()\n    return switch byName(CONTENT_LENGTH) {\n      case Success(Std.parseInt(_) => null): Failure(new Error(UnprocessableEntity, 'Invalid Content-Length Header'));\n      case Success(Std.parseInt(_) => v): Success(v);\n      case Failure(e): Failure(e);\n    }\n    \n  public function accepts(type:String) {\n    var prefix = type.split('/')[0];\n    return byName(ACCEPT).map(function(v) {\n      for(entry in v.parse()) {\n        if(entry.value == '*/*' || entry.value == type) return true;\n        switch entry.value.split('/') {\n          case [p, '*'] if(prefix == p): return true;\n          default: // continue\n        }\n      }\n      return false;\n    });\n  }\n\n  private var LINEBREAK(get, never):String; \n    inline function get_LINEBREAK() return '\\r\\n';\n\n  public function toString() \n    return [for (f in fields) f.toString()].join(LINEBREAK) + LINEBREAK + LINEBREAK;\n    \n  inline function headerNotFound(name)\n    return 'No $name header found';\n}\n\ntypedef HeaderValueComponent = {\n  var value(default, never):String;\n  var extension(default, null):Extensions;\n}\n\nabstract HeaderValue(String) from String to String {\n  \n  public function getExtension():Map<String, String>\n    return parse()[0].extensions;\n  \n  /**\n   *  Parse the value of this header in to `{value:String, extensions:Map<String, String>}` form\n   */\n  public function parse()\n    return parseWith(function(_, params) return [for(p in params) p.name => switch p.value.toString() {\n      case quoted if (quoted.charCodeAt(0) == '\"'.code): quoted.substr(1, quoted.length - 2);//TODO: find out how exactly escaping and what not works\n      case v: v;\n    }]);\n    \n  /**\n   *  Parse the value of this header, using the given function to parse the extensions\n   *  @param parseExtension - function to parse the extension\n   */\n  public function parseWith<T>(parseExtension:String->Iterator<QueryStringParam>->T)\n    return [for(v in this.split(',')) {\n      v = v.trim();\n      var i = switch v.indexOf(';') {\n        case -1: v.length;\n        case i: i;\n      }\n      var value = v.substr(0, i);\n      {\n        value: value,\n        extensions: parseExtension(value, Query.parseString(v, ';', i + 1)),\n      }\n    }];\n    \n  public static function basicAuth(username:String, password:String)\n    return 'Basic ' + Base64.encode(Bytes.ofString('$username:$password')).toString();\n  \n  static var DAYS = 'Sun,Mon,Tue,Wen,Thu,Fri,Sat'.split(',');\n  static var MONTHS = 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(',');\n  @:from static public function ofDate(d:Date):HeaderValue\n    return DateTools.format(d, DAYS[d.getDay()] + \", %d \" + MONTHS[d.getMonth()] + \" %Y %H:%M:%S GMT\");\n  \n  @:from static public function ofInt(i:Int):HeaderValue\n    return Std.string(i);\n\n  \n}\n\n@:enum abstract HeaderName(String) to String {\n  \n  var REFERER                          = 'referer';\n  var HOST                             = 'host';\n\n  var SET_COOKIE                       = 'set-cookie';\n  var COOKIE                           = 'cookie';\n\n  var CONTENT_TYPE                     = 'content-type';\n  var CONTENT_LENGTH                   = 'content-length';\n  var CONTENT_DISPOSITION              = 'content-disposition';\n\n  var ACCEPT                           = 'accept';\n  var ACCEPT_ENCODING                  = 'accept-encoding';\n\n  var TRANSFER_ENCODING                = 'transfer-encoding';\n\n  var LOCATION                         = 'location';\n  var AUTHORIZATION                    = 'authorization';\n\n  var ORIGIN                           = 'origin';\n  var VARY                             = 'vary';\n  \n  var CACHE_CONTROL                    = 'cache-control';\n  var EXPIRES                          = 'expires';\n\n  var ACCESS_CONTROL_REQUEST_METHOD    = 'access-control-request-method';\n  var ACCESS_CONTROL_REQUEST_HEADERS   = 'access-control-request-headers';\n  var ACCESS_CONTROL_ALLOW_ORIGIN      = 'access-control-allow-origin';\n  var ACCESS_CONTROL_ALLOW_CREDENTIALS = 'access-control-allow-credentials';\n  var ACCESS_CONTROL_EXPOSE_HEADERS    = 'access-control-expose-headers';\n  var ACCESS_CONTROL_MAX_AGE           = 'access-control-max-age';\n  var ACCESS_CONTROL_ALLOW_METHODS     = 'access-control-allow-methods';\n  var ACCESS_CONTROL_ALLOW_HEADERS     = 'access-control-allow-headers';\n  \n  inline function new(s) this = s;\n  \n  @:from static inline function ofString(s:String)\n    return new HeaderName(s.toLowerCase());\n}\n\n#if tink_json\n@:jsonParse(function(json) return tink.http.Header.HeaderField.ofString(json))\n@:jsonStringify(function(field:tink.http.Header.HeaderField) return field.toString())\n#end\nclass HeaderField extends NamedWith<HeaderName, HeaderValue> {\n  \n  public function toString() \n    return \n      if (value == null) name \n      else '$name: $value';//urlencode?\n    \n  static public function ofString(s:String)\n    return switch s.indexOf(':') {\n      case -1: \n        new HeaderField(s, null);\n      case v: \n        var name = s.substr(0, v);\n        new HeaderField(name, s.substr(v + 1).trim()); //urldecode?\n    }\n  \n  /**\n   * Constructs a Set-Cookie header. Please note that cookies are HttpOnly by default. \n   * You can opt out of that behavior by setting `options.scriptable` to true.\n   */  \n  static public function setCookie(key:String, value:String, ?options: { ?expires: Date, ?domain: String, ?path: String, ?secure: Bool, ?scriptable: Bool}) {\n    \n    if (options == null) \n      options = { };\n      \n    var buf = new StringBuf();\n    \n    inline function addPair(name, value) {\n      if(value == null) return;\n      buf.add(\"; \");\n      buf.add(name);\n      buf.add(value);\n    }\n    \n    buf.add(key.urlEncode() + '=' + value.urlEncode());\n    \n    if (options.expires != null) \n      addPair(\"expires=\", (options.expires:HeaderValue));\n    \n    addPair(\"domain=\", options.domain);\n    addPair(\"path=\", options.path);\n    \n    if (options.secure) addPair(\"secure\", \"\");\n    if (options.scriptable != true) addPair(\"HttpOnly\", \"\");\n    \n    return new HeaderField(SET_COOKIE, buf.toString());\n  }\n}\n\nclass HeaderParser<T> extends BytewiseParser<T> {\n  var header:T;\n  var fields:Array<HeaderField>;\n  var buf:StringBuf;\n  var last:Int = -1;\n  \n  var makeHeader:String->Array<HeaderField>->Outcome<T, Error>;\n  \n  public function new(makeHeader) {\n    this.buf = new StringBuf();\n    this.makeHeader = makeHeader;\n  }\n  \n  static var INVALID = Failed(new Error(UnprocessableEntity, 'Invalid HTTP header'));  \n        \n  override function read(c:Int):ParseStep<T> \n    return\n      switch [last, c] {\n        case [_, -1]:\n          \n          nextLine();\n\n        case ['\\r'.code, '\\n'.code]:\n          \n          nextLine();\n            \n        case ['\\r'.code, '\\r'.code]:\n          \n          buf.addChar(last);\n          Progressed;\n          \n        case ['\\r'.code, other]:\n          \n          buf.addChar(last);\n          buf.addChar(other);\n          last = -1;\n          Progressed;\n          \n        case [_, '\\r'.code]:\n          \n          last = '\\r'.code;\n          Progressed;\n          \n        case [_, other]:\n          \n          last = other;\n          buf.addChar(other);\n          Progressed;\n      }\n      \n  function nextLine() {\n    var line = buf.toString();\n    \n    buf = new StringBuf();\n    last = -1;\n    \n    return\n      switch line {\n        case '':\n          if (header == null)\n            Progressed;\n          else\n            Done(header);\n        default:\n          if (header == null)\n            switch makeHeader(line, fields = []) {\n              case Success(null):\n                Done(this.header = null);\n              case Success(v): \n                this.header = v;\n                Progressed;\n              case Failure(e):\n                Failed(e);\n            }\n          else {\n            fields.push(HeaderField.ofString(line));\n            Progressed;\n          }\n      }      \n    }\n  \n}\n","package tink.http;\n\nimport haxe.crypto.Base64;\nimport tink.http.Message;\nimport tink.http.Header;\nimport tink.http.Protocol;\nimport tink.url.Query;\nimport tink.Url;\n\nusing tink.CoreApi;\nusing tink.io.StreamParser;\nusing tink.io.Source;\n\nclass RequestHeader extends Header {\n  \n  public var method(default, null):Method;\n  public var url(default, null):Url;\n  public var protocol(default, null):Protocol;\n\n  public function new(method:Method, url:Url, protocol:Protocol = HTTP1_1, fields) {\n    this.method = method;\n    this.url = url;\n    this.protocol = protocol;\n    super(fields);\n  }  \n\n  override function concat(fields:Array<HeaderField>):RequestHeader\n    return new RequestHeader(method, url, protocol, this.fields.concat(fields));\n\n  override public function toString()\n    return '$method ${url.pathWithQuery} $protocol$LINEBREAK'+super.toString();\n\n}\n\nclass IncomingRequestHeader extends RequestHeader {\n  \n  var cookies:Map<String, String>;\n  \n  function getCookies() {\n    if (cookies == null)\n      cookies = [for (header in get('cookie')) for (entry in Query.parseString(header, ';')) entry.name => entry.value.toString()];\n      \n    return cookies;\n  }\n  \n  override function concat(fields:Array<HeaderField>):IncomingRequestHeader\n    return new IncomingRequestHeader(method, url, protocol, this.fields.concat(fields));\n  \n  /**\n   *  List all cookie names\n   */\n  public function cookieNames()\n    return cookies.keys();\n  \n  /**\n   *  Get a single cookie\n   */\n  public function getCookie(name:String)\n    return getCookies()[name];\n    \n  /**\n   *  Get the Authorization header as an Enum\n   */\n  public function getAuth()\n    return getAuthWith(function(s, p) return switch s {\n      case 'Basic':\n        var decoded = try Base64.decode(p).toString() catch(e:Dynamic) return Failure(Error.withData('Error in decoding basic auth', e));\n        switch decoded.indexOf(':') {\n          case -1: Failure(new Error('Cannot parse username and password because \":\" is missing'));\n          case i: Success(Basic(decoded.substr(0, i), decoded.substr(i + 1)));\n        }\n      case 'Bearer':\n        Success(Bearer(p));\n      case s:\n        Success(Others(s, p));\n    });\n  \n  public function getAuthWith<T>(parser:String->String->Outcome<T, Error>):Outcome<T, Error>\n    return byName(AUTHORIZATION).flatMap(function(v:String) return switch v.indexOf(' ') {\n        case -1:\n          Failure(new Error(UnprocessableEntity, 'Invalid Authorization Header'));\n        case i:\n          parser(v.substr(0, i), v.substr(i + 1));\n    });\n  \n  /**\n   *  Get a StreamParser which can parse a Source into an IncomingRequestHeader\n   */\n  static public function parser():StreamParser<IncomingRequestHeader>\n    return new HeaderParser<IncomingRequestHeader>(function (line, headers) \n      return switch line.split(' ') {\n        case [method, url, protocol]:\n          Success(new IncomingRequestHeader(cast method, url, protocol, headers));\n        default: \n          Failure(new Error(UnprocessableEntity, 'Invalid HTTP header'));\n      }\n    );\n    \n  #if nodejs\n  static public function fromIncomingMessage(req:js.node.http.IncomingMessage) {\n    return new IncomingRequestHeader(\n      cast req.method,\n      req.url,\n      'HTTP/' + req.httpVersion,\n      [for (i in 0...Std.int(req.rawHeaders.length / 2)) \n        new HeaderField(req.rawHeaders[2 * i], req.rawHeaders[2 * i +1])\n      ]\n    );\n  }\n  #end\n}\n\nclass OutgoingRequestHeader extends RequestHeader {\n  override function concat(fields:Array<HeaderField>):OutgoingRequestHeader\n    return new OutgoingRequestHeader(method, url, protocol, this.fields.concat(fields));\n}\n\nclass OutgoingRequest extends Message<OutgoingRequestHeader, IdealSource> {}\n\nclass IncomingRequest extends Message<IncomingRequestHeader, IncomingRequestBody> {\n  \n  public var clientIp(default, null):String;\n  \n  public function new(clientIp, header, body) {\n    this.clientIp = clientIp;\n    super(header, body);\n  }\n  \n  static public function parse(clientIp, source:RealSource) \n    return\n      source.parse(IncomingRequestHeader.parser())\n        .next(function (parts) return new IncomingRequest(\n          clientIp,\n          parts.a,\n          Plain(switch parts.a.getContentLength() {\n            case Success(len):\n              parts.b.limit(len);\n            case Failure(_):\n              switch [parts.a.method, parts.a.byName(TRANSFER_ENCODING)] {\n                case [GET | OPTIONS, _]: Source.EMPTY;\n                case [_, Success((_:String).split(',').map(StringTools.trim) => encodings)] if(encodings.indexOf('chunked') != -1): Chunked.decode(parts.b);\n                case _: return new Error(411, 'Content-Length header missing');\n              }\n          })\n        ));\n}\n\nenum IncomingRequestBody {\n  Plain(source:RealSource);\n  Parsed(parts:StructuredBody);\n}\n\nenum Authorization {\n  Basic(user:String, pass:String);\n  Bearer(token:String);\n  Others(scheme:String, param:String);\n}","package tink.url;\n\nimport haxe.DynamicAccess;\nimport tink.core.Named;\n\nusing StringTools;\n\nabstract Query(String) from String to String {  \n  \n  public inline function parse() \n    return iterator();\n    \n  public function with(values:Map<Portion, Portion>):Query {\n    var ret = new QueryStringBuilder();\n    \n    var insert = [for(key in values.keys()) key];\n    \n    for(p in iterator()) {\n      if(values.exists(p.name)) {\n        ret.add(p.name, values[p.name]);\n        insert.remove(p.name);\n      } else {\n        ret.add(p.name, p.value);\n      }\n    }\n    \n    for(name in insert) ret.add(name, values[name]);\n    \n    return ret.toString();\n  }\n  \n  \n  @:to public inline function iterator() \n    return parseString(this);\n  \n  @:to public function toMap():Map<String, Portion>\n    return [for (p in iterator()) (p.name:String).toString() => p.value]; // cast to string explicitly to help 3.2.1 cpp\n  \n  @:from static function ofObj(v:Dynamic<String>):Query {\n    var ret = new QueryStringBuilder(),\n        v:DynamicAccess<String> = v;\n        \n    for (k in v.keys())\n      ret.add(k, v[k]);\n      \n    return ret.toString();\n  }    \n  \n  public inline function toString():String\n    return this;\n    \n  static public inline function build():QueryStringBuilder \n    return new QueryStringBuilder();\n   \n  static public inline function parseString(s:String, sep:String = '&', set:String = '=', pos:Int = 0)\n    return new QueryStringParser(s, sep, set, pos);\n    \n}\n\nabstract QueryStringBuilder(Array<String>) {\n  \n  public inline function new() {\n    this = [];\n  }\n  \n  public inline function add(name:Portion, value:Portion):QueryStringBuilder {\n    this.push(name.raw + '=' + value.raw);\n    return cast this;\n  }\n  \n  public inline function toString(?sep:String = '&')\n    return this.join(sep);\n    \n  public function copy():QueryStringBuilder\n    return cast this.copy();\n}\n\ntypedef QueryStringParam = Named<Portion>;\n\nprivate class QueryStringParser {\n  \n  var s:String;\n  var sep:String;\n  var set:String;\n  var pos:Int;\n  \n  public function new(s, sep, set, pos) {\n    this.s = switch s {\n      case null: '';\n      default: s;\n    }\n    this.sep = sep;\n    this.set = set;\n    this.pos = pos;\n  }\n  \n  public function hasNext() \n    return pos < s.length;\n    \n  public function next() {\n    var next = s.indexOf(sep, pos);\n    \n    if (next == -1)\n      next = s.length;\n    \n    var split = s.indexOf(set, pos);\n    var start = pos;\n      \n    pos = next + sep.length;\n    \n    return \n      if (split == -1 || split > next)\n        new QueryStringParam(trimmedSub(s, start, next), '');\n      else\n        new QueryStringParam(trimmedSub(s, start, split), trimmedSub(s, split + set.length, next));\n  }\n\n  static function trimmedSub(s:String, start:Int, end:Int) {\n    \n    if(start >= s.length) return new Portion('');\n    \n    while (s.fastCodeAt(start) < 33) \n      start++;\n    \n    if (end < s.length - 1)\n      while (s.fastCodeAt(end-1) < 33) \n        end--;\n      \n    return new Portion(s.substring(start, end));\n  }  \n  \n}\n","package tink;\n\nimport tink.url.*;\n\nusing StringTools;\n\n@:forward\nabstract Url(UrlParts) {\n  \n  static inline var SCHEME = 2;\n  static inline var PAYLOAD = 3;\n  static inline var AUTH = 6;\n  static inline var HOSTNAMES = 7;\n  static inline var PATH = 8;\n  static inline var QUERY = 10;\n  static inline var HASH = 12;\n  \n  public var pathWithQuery(get, never):String;\n    inline function get_pathWithQuery()\n      return if(this.query == null) this.path else this.path + '?' + this.query;\n  \n  inline function new(parts)\n    this = parts;\n    \n  public function resolve(that:Url):Url\n    return\n      if (that.scheme != null) that;\n      else if (that.host != null)\n        if (that.scheme != null) that;\n        else {\n          var copy = Reflect.copy(that);\n          @:privateAccess copy.scheme = this.scheme;\n          return copy;\n        }\n      else {\n        var parts:UrlParts = {\n          path: this.path.join(that.path),\n          payload: '',\n          scheme: this.scheme,\n          query: that.query,\n          auth: this.auth,\n          host: this.host,\n          hash: that.hash\n        }\n        \n        makePayload(parts);\n        \n        return new Url(parts);\n      }\n      \n  static function makePayload(parts:UrlParts) {\n    \n    var payload = '';\n            \n    switch parts {\n      case { host: null, auth: null }:\n      case { auth: null, host: host }:\n        payload += '//$host';\n      case { auth: auth, host: null }:\n        payload += '//$auth';\n      case { auth: auth, host: host } :\n        payload += '//$auth$host'; \n    }\n    \n    payload += parts.path;\n    \n    switch parts.query {\n      case null:\n      case v: payload += '?$v';\n    }\n    \n    switch parts.hash {\n      case null:\n      case v: payload += '#$v';\n    }\n    \n    @:privateAccess parts.payload = payload.toString();\n  }\n  \n  @:to public function toString()\n    return switch this.scheme {\n      case null: this.payload;\n      default: '${this.scheme}:${this.payload}';\n    }\n  \n  @:from static function fromString(s:String):Url return parse(s);\n  static function noop(_) {}\n  static public function parse(s:String, ?onError:String->Void):Url {\n    \n    if (s == null) \n      return parse('');\n\n    if (onError == null)\n      onError = noop;\n\n    s = s.trim();\n    \n    if (s.startsWith('data:')) //this is kind of a fast-path\n      return new Url( { scheme: 'data', payload: s.substr(5) } );\n    \n    var FORMAT = ~/^(([a-zA-Z][a-zA-Z0-9\\-+.]*):)?((\\/\\/(([^@\\/]+)@)?([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?)$/;\n    var HOST = ~/^(\\[(.*)\\]|([^:]*))(:(.*))?$/;  \n    //Ideally the above would be a constant. Unfortunately that would compromise thread safety.\n    \n    FORMAT.match(s);\n    \n    var hosts = switch FORMAT.matched(HOSTNAMES) {\n        case null: [];\n        case v:\n            [for(host in v.split(',')) {\n              HOST.match(host);\n              var host = switch [HOST.matched(3), HOST.matched(2)] {\n                  case [ipv4, null]: ipv4;\n                  case [null, ipv6]: '[$ipv6]';\n                  case _: \n                    onError('invalid host $host'); \n                    null;\n              }\n              var port = switch HOST.matched(5) {\n                  case null: null;\n                  case v: \n                      switch Std.parseInt(v) {\n                          case null: \n                            onError('invalid port $v'); \n                            null;\n                          case p: p;\n                      }\n              }\n              new Host(host, port);\n            }];\n    }\n    var path = FORMAT.matched(PATH);\n    \n    if (hosts.length > 0 && path.charAt(0) != '/')\n      path = '/$path';\n      \n    return new Url({\n      scheme: FORMAT.matched(SCHEME),\n      payload: FORMAT.matched(PAYLOAD),\n      host: hosts[0],\n      hosts: hosts,\n      auth: cast FORMAT.matched(AUTH),\n      path: path,\n      query: FORMAT.matched(QUERY),\n      hash: FORMAT.matched(HASH)\n    });    \n  }\n\n  static public function make(parts:UrlArgs):Url {\n    var parts:UrlParts = {\n      payload: '',\n      path: parts.path,\n      query: parts.query,\n      host: parts.host,\n      hosts: parts.hosts,\n      auth: parts.auth,\n      scheme: parts.scheme,\n      hash: parts.hash,\n    };\n    makePayload(parts);\n    return new Url(parts);\n  }\n  \n  #if tink_json\n  @:from public static function fromRepresentation(v:tink.json.Representation<String>)\n    return Url.parse(v.get());\n  @:to public function toRepresentation():tink.json.Representation<String>\n    return new tink.json.Representation(toString());\n  #end\n}\n\nprivate typedef UrlParts = {>UrlArgs,\n  var payload(default, null):String;\n}\n\nprivate typedef UrlArgs = {\n  @:optional var path(default, null):Path;\n  @:optional var query(default, null):Query;\n  @:optional var host(default, null):Host;\n  @:optional var hosts(default, null):Iterable<Host>;\n  @:optional var auth(default, null):Auth;\n  @:optional var scheme(default, null):String;\n  @:optional var hash(default, null):String;\n}\n","package tink.url;\n\n/**\n * Represents a host, i.e. a hostname and an additional port.\n * May be accessed when null.\n */\nabstract Host(String) to String {\n  public var name(get, never):Null<String>;\n  public var port(get, never):Null<Int>;\n  \n  public function new(name:String, ?port:Int)\n    this = \n      if (port == null) name;\n      else if (port > 65535 || port <= 0) throw 'Invalid port';\n      else '$name:$port';\n      \n  function get_name()\n    return\n      if (this == null) null;\n      else switch this.split(']') {\n          case [v]: v.split(':')[0]; // ipv4\n          case [v, _]: v + ']'; // ipv6\n          default: throw 'assert';\n      }\n      \n  function get_port()\n    return\n      if (this == null) null;\n      else \n        switch this.split(']') {\n          case [v] | [_, v]: \n              switch v.split(':')[1] {\n                  case null: null;\n                  case p: Std.parseInt(p);\n              }\n          default: throw 'assert';\n        }\n  \n public inline function toString():String\n    return this;\n}","package tink.url;\n\nusing haxe.io.Path;\nusing StringTools;\n\nabstract Path(String) to String {\n  \n  public function parts():PortionArray\n    return [for (p in this.split('/')) if (p != '') new Portion(p)];//TODO: consider using a cache\n  \n  public var absolute(get, never):Bool;\n    inline function get_absolute()\n      return this.charAt(0) == '/';\n      \n  public var isDir(get, never):Bool;\n    inline function get_isDir()\n      return this.charAt(this.length - 1) == '/';\n    \n  inline function new(s) \n    this = s;\n    \n  public function join(that:Path):Path\n    return \n      if (that == '') cast this;\n      else if (that.absolute) that;\n      else //it's a little heavy to run through the WHOLE normalization here, but eh ... pull requests welcome\n        if (isDir) ofString(this + (that : String));\n        else switch this.lastIndexOf('/') {\n          case -1: that;\n          case v: this.substr(0, v + 1) + that;\n        }\n  \n  @:from static public function ofString(s:String) {//TODO: consider what to do with invalid paths, e.g. '....'\n    return new Path(normalize(s));\n  }\n  \n  static public function normalize(s:String) {\n    s = s.replace('\\\\', '/').trim();\n    if (s == '.')\n      return './';\n      \n    var isDir = s.endsWith('/..') || s.endsWith('/') || s.endsWith('/.');\n    \n    var parts = [],\n        isAbsolute = s.startsWith('/'),\n        up = 0;\n    \n    for (part in s.split('/'))\n      switch part.trim() {\n        case '':\n        case '.':\n        case '..': \n          if (parts.pop() == null) up++;\n        case v: parts.push(v);\n      }\n      \n    if (isAbsolute)\n      parts.unshift('');\n    else\n      for (i in 0...up)\n        parts.unshift('..');\n    \n    if (isDir)\n      parts.push('');\n      \n    \n    return parts.join('/');\n  }\n  \n  public inline function toString():String\n    return this;\n  \n  static public var root(default, null):Path = new Path('/');\n}","package tink.core;\n\ntypedef Named<V> = NamedWith<String, V>;\n\n@:pure\nclass NamedWith<N, V> {\n  \n  public var name(default, null):N;\n  public var value(default, null):V;\n  \n  public function new(name, value) {\n    this.name = name;\n    this.value = value;\n  }\n  \n}","package tink.streams;\n\nimport tink.streams.IdealStream;\n\nusing tink.CoreApi;\n\n@:forward\nabstract Stream<Item, Quality>(StreamObject<Item, Quality>) from StreamObject<Item, Quality> to StreamObject<Item, Quality> {\n  \n  public var depleted(get, never):Bool;\n    inline function get_depleted() \n      return this.depleted;\n  \n  @:to function dirty():Stream<Item, Error>\n    return cast this;\n    \n  static public function single<Item, Quality>(i:Item):Stream<Item, Quality>\n    return new Single(i);\n    \n  @:from static public function ofIterator<Item, Quality>(i:Iterator<Item>):Stream<Item, Quality> {\n    return Generator.stream(function next(step) step(if(i.hasNext()) Link(i.next(), Generator.stream(next)) else End));\n  }\n    \n  #if cs\n  // This is to mitigate an error in the c# generator that it generates paramterized calls\n  // with type parameters which is not defined in scope\n  // similar to https://github.com/HaxeFoundation/haxe/issues/6833\n  @:from static public function dirtyFlatten<Item>(f:Future<Stream<Item, Error>>):Stream<Item, Error>\n    return new FutureStream(f);\n  #end\n    \n  @:from static public function flatten<Item, Quality>(f:Future<Stream<Item, Quality>>):Stream<Item, Quality>\n    return new FutureStream(f);\n  \n  #if cs\n  // This is to mitigate an error in the c# generator that it generates paramterized calls\n  // with type parameters which is not defined in scope\n  // similar to https://github.com/HaxeFoundation/haxe/issues/6833\n  @:from static public function dirtyPromise<Item>(f:Promise<Stream<Item, Error>>):Stream<Item, Error>\n    return dirtyFlatten(f.map(function (o) return switch o {\n      case Success(s): s;\n      case Failure(e): ofError(e);\n    }));\n  #end\n  \n  @:from static inline function promiseIdeal<Item>(f:Promise<IdealStream<Item>>):Stream<Item, Error>\n    return cast promise(f);\n  \n  @:from static inline function promiseReal<Item>(f:Promise<RealStream<Item>>):Stream<Item, Error>\n    return cast promise(f);\n  \n  @:from static public function promise<Item, Quality>(f:Promise<Stream<Item, Quality>>):Stream<Item, Error>\n    return flatten(f.map(function (o) return switch o {\n      case Success(s): s.dirty();\n      case Failure(e): ofError(e);\n    }));\n    \n  @:from static public function ofError<Item>(e:Error):Stream<Item, Error>\n    return new ErrorStream(e);\n    \n}\n\nenum RegroupStatus<Quality> {\n  Flowing:RegroupStatus<Quality>;\n  Errored(e:Error):RegroupStatus<Error>;\n  Ended:RegroupStatus<Quality>;\n}\n\nenum RegroupResult<Out, Quality> {\n  Converted(data:Stream<Out, Quality>):RegroupResult<Out, Quality>;\n  Terminated(data:Option<Stream<Out, Quality>>):RegroupResult<Out, Quality>;\n  Untouched:RegroupResult<Out, Quality>;\n  Errored(e:Error):RegroupResult<Out, Error>;\n}\n\n@:forward\nabstract Regrouper<In, Out, Quality>(RegrouperBase<In, Out, Quality>) from RegrouperBase<In, Out, Quality> to RegrouperBase<In, Out, Quality> {\n  @:from\n  public static function ofIgnorance<In, Out, Quality>(f:Array<In>->Future<RegroupResult<Out, Quality>>):Regrouper<In, Out, Quality>\n    return {apply: function(i, _) return f(i)};\n  @:from\n  public static function ofIgnoranceSync<In, Out, Quality>(f:Array<In>->RegroupResult<Out, Quality>):Regrouper<In, Out, Quality>\n    return {apply: function(i, _) return Future.sync(f(i))};\n  @:from\n  public static function ofFunc<In, Out, Quality>(f:Array<In>->RegroupStatus<Quality>->Future<RegroupResult<Out, Quality>>):Regrouper<In, Out, Quality>\n    return {apply: f};\n  @:from\n  public static function ofFuncSync<In, Out, Quality>(f:Array<In>->RegroupStatus<Quality>->RegroupResult<Out, Quality>):Regrouper<In, Out, Quality>\n    return {apply: function(i, s) return Future.sync(f(i, s))};\n}\n\nprivate typedef RegrouperBase<In, Out, Quality> = {\n  function apply(input:Array<In>, status:RegroupStatus<Quality>):Future<RegroupResult<Out, Quality>>;\n}\n\nprivate class RegroupStream<In, Out, Quality> extends CompoundStream<Out, Quality> {\n  public function new(source:Stream<In, Quality>, f:Regrouper<In, Out, Quality>, ?prev) {\n    if(prev == null) prev = Empty.make();\n    \n    var ret = null;\n    var terminated = false;\n    var buf = [];\n    var next = Stream.flatten(source.forEach(function(item) {\n      buf.push(item);\n      return f.apply(buf, Flowing).map(function (o):Handled<Error> return switch o {\n        case Converted(v):\n          ret = v;\n          Finish;\n        case Terminated(v):\n          ret = v.or(Empty.make);\n          terminated = true;\n          Finish;\n        case Untouched:\n          Resume;\n        case Errored(e):\n          Clog(e);\n      });\n    }).map(function(o):Stream<Out, Quality> return switch o {\n      case Failed(e): Stream.ofError(e);\n      case Depleted if(buf.length == 0): Empty.make();\n      case Depleted:\n        Stream.flatten(f.apply(buf, Ended).map(function(o) return switch o {\n          case Converted(v): v;\n          case Terminated(v): v.or(Empty.make);\n          case Untouched: Empty.make();\n          case Errored(e): cast Stream.ofError(e);\n        }));\n      case Halted(_) if(terminated): ret;\n      case Halted(rest): new RegroupStream(rest, f, ret);\n      case Clogged(e, rest): cast new CloggedStream(e, cast rest);\n    }));\n    // TODO: get rid of those casts in this function\n    \n    super([prev, next]);\n  }\n}\n\nenum Handled<Safety> {\n  BackOff:Handled<Safety>;\n  Finish:Handled<Safety>;\n  Resume:Handled<Safety>;\n  Clog(e:Error):Handled<Error>;\n}\n\nenum Conclusion<Item, Safety, Quality> {\n  Halted(rest:Stream<Item, Quality>):Conclusion<Item, Safety, Quality>;\n  Clogged(error:Error, at:Stream<Item, Quality>):Conclusion<Item, Error, Quality>;\n  Failed(error:Error):Conclusion<Item, Safety, Error>;\n  Depleted:Conclusion<Item, Safety, Quality>;\n}\n\nenum ReductionStep<Safety, Result> {\n  Progress(result:Result):ReductionStep<Safety, Result>;\n  Crash(e:Error):ReductionStep<Error, Result>;\n}\n\nenum Reduction<Item, Safety, Quality, Result> {\n  Crashed(error:Error, at:Stream<Item, Quality>):Reduction<Item, Error, Quality, Result>;\n  Failed(error:Error):Reduction<Item, Safety, Error, Result>;  \n  Reduced(result:Result):Reduction<Item, Safety, Quality, Result>;\n}\n\nprivate class CloggedStream<Item> extends StreamBase<Item, Error> {\n  \n  var rest:Stream<Item, Error>;\n  var error:Error;\n  \n  public function new(rest, error) {\n    this.rest = rest;\n    this.error = error;\n  }\n  \n  override function next():Future<Step<Item, Error>>\n    return Future.sync(Step.Fail(error));\n    \n  override public function forEach<Safety>(handler:Handler<Item,Safety>):Future<Conclusion<Item, Safety, Error>>\n    return Future.sync(cast Conclusion.Clogged(error, rest));\n  \n}\n\nprivate class ErrorStream<Item> extends StreamBase<Item, Error> {\n  \n  var error:Error;\n  \n  public function new(error)\n    this.error = error;\n  \n  override function next():Future<Step<Item, Error>>\n    return Future.sync(Step.Fail(error));\n    \n  override public function forEach<Safety>(handler:Handler<Item,Safety>):Future<Conclusion<Item, Safety, Error>>\n    return Future.sync(Conclusion.Failed(error));\n  \n}\n\ninterface StreamObject<Item, Quality> {\n  /**\n   *  `true` if there is no data in this stream\n   */\n  var depleted(get, never):Bool;\n  function next():Future<Step<Item, Quality>>;\n  /**\n   *  Create a new stream by performing an N-to-M mapping\n   */\n  function regroup<Ret>(f:Regrouper<Item, Ret, Quality>):Stream<Ret, Quality>;\n  /**\n   *  Create a new stream by performing an 1-to-1 mapping\n   */\n  function map<Ret>(f:Mapping<Item, Ret, Quality>):Stream<Ret, Quality>;\n  /**\n   *  Create a filtered stream\n   */\n  function filter(f:Filter<Item, Quality>):Stream<Item, Quality>;\n  function retain():Void->Void;\n  /**\n   *  Create an IdealStream.\n   *  The stream returned from the `rescue` function will be recursively rescued by the same `rescue` function\n   */\n  function idealize(rescue:Error->Stream<Item, Quality>):IdealStream<Item>;\n  /**\n   *  Append another stream after this\n   */\n  function append(other:Stream<Item, Quality>):Stream<Item, Quality>;\n  /**\n   *  Prepend another stream before this\n   */\n  function prepend(other:Stream<Item, Quality>):Stream<Item, Quality>;\n  function blend(other:Stream<Item, Quality>):Stream<Item, Quality>;\n  function decompose(into:Array<Stream<Item, Quality>>):Void;\n  /**\n   *  Iterate this stream.\n   *  The handler should return one of the following values (or a `Future` of it)\n   *  - Backoff: stop the iteration before the current item\n   *  - Finish: stop the iteration after the current item\n   *  - Resume: continue the iteration\n   *  - Clog(error): produce an error\n   *  @return A conclusion that indicates how the iteration was ended\n   *  - Depleted: there are no more data in the stream\n   *  - Failed(err): the stream produced an error\n   *  - Halted(rest): the iteration was halted by `Backoff` or `Finish`\n   *  - Clogged(err): the iteration was halted by `Clog(err)`\n   */\n  function forEach<Safety>(handle:Handler<Item, Safety>):Future<Conclusion<Item, Safety, Quality>>;\n  /**\n   *  Think Lambda.fold()\n   */\n  function reduce<Safety, Result>(initial:Result, reducer:Reducer<Item, Safety, Result>):Future<Reduction<Item, Safety, Quality, Result>>;\n}\n\nclass Empty<Item, Quality> extends StreamBase<Item, Quality> {\n  \n  function new() {}\n  \n  override function get_depleted()\n    return true;\n    \n  override function next():Future<Step<Item, Quality>>\n    return Future.sync(Step.End);\n    \n  override public function forEach<Safety>(handler:Handler<Item, Safety>):Future<Conclusion<Item, Safety, Quality>> \n    return Future.sync(Depleted);\n    \n  static var inst = new Empty<Dynamic, Dynamic>();  \n    \n  static public inline function make<Item, Quality>():Stream<Item, Quality>\n    return (cast inst : Stream<Item, Quality>);\n  \n}\n\nabstract Mapping<In, Out, Quality>(Regrouper<In, Out, Quality>) to Regrouper<In, Out, Quality> {\n  \n  inline function new(o)\n    this = o;\n    \n  @:from static function ofNext<In, Out>(n:Next<In, Out>):Mapping<In, Out, Error>\n    return new Mapping({\n      apply: function (i:Array<In>, _) return n(i[0]).next(function(o) return Converted(Stream.single(o))).recover(Errored),\n    });\n    \n  @:from static function ofAsync<In, Out, Quality>(f:In->Future<Out>):Mapping<In, Out, Quality>\n    return new Mapping({\n      apply: function (i:Array<In>, _) return f(i[0]).map(function(o) return Converted(Stream.single(o))),\n    });\n    \n  @:from static function ofSync<In, Out>(f:In->Outcome<Out, Error>):Mapping<In, Out, Error>\n    return new Mapping({\n      apply: function (i:Array<In>, _) return Future.sync(switch f(i[0]) {\n        case Success(v): Converted(Stream.single(v));\n        case Failure(e): Errored(e);\n      }),\n    });\n    \n  @:from static function ofPlain<In, Out, Quality>(f:In->Out):Mapping<In, Out, Quality>\n    return new Mapping({\n      apply: function (i:Array<In>, _) return Future.sync(Converted(Stream.single(f(i[0])))),\n    });\n    \n}\n\nabstract Filter<T, Quality>(Regrouper<T, T, Quality>) to Regrouper<T, T, Quality> {\n  \n  inline function new(o)\n    this = o;    \n  \n  @:from static function ofNext<T>(n:Next<T, Bool>):Filter<T, Error>\n    return new Filter({\n      apply: function (i:Array<T>, _) return n(i[0]).next(function (matched) return Converted(if (matched) Stream.single(i[0]) else Empty.make())).recover(Errored),\n    });\n    \n  @:from static function ofAsync<T, Quality>(f:T->Future<Bool>):Filter<T, Quality>\n    return new Filter({\n      apply: function (i:Array<T>, _) return f(i[0]).map(function (matched) return Converted(if (matched) Stream.single(i[0]) else Empty.make())),\n    });\n    \n  @:from static function ofSync<T>(f:T->Outcome<Bool, Error>):Filter<T, Error>\n    return new Filter({\n      apply: function (i:Array<T>, _) return Future.sync(switch f(i[0]) {\n        case Success(v): Converted(if(v)Stream.single(i[0]) else Empty.make());\n        case Failure(e): Errored(e);\n      }),\n    });\n    \n  @:from static function ofPlain<T, Quality>(f:T->Bool):Filter<T, Quality>\n    return new Filter({\n      apply: function (i:Array<T>, _) return Future.sync(Converted(if (f(i[0])) Stream.single(i[0]) else Empty.make())),\n    });\n  \n}\n\nclass StreamBase<Item, Quality> implements StreamObject<Item, Quality> {\n  \n  public var depleted(get, never):Bool;\n    function get_depleted() return false;\n  \n  var retainCount = 0;\n  \n  public function retain() {\n    retainCount++;\n    var retained = true;\n    return function () {\n      if (retained) {\n        retained = false;\n        if (--retainCount == 0)\n          destroy();\n      }\n    }\n  }\n      \n  public function next():Future<Step<Item, Quality>> {\n    throw 'not implemented';\n    // var item = null;\n    // return this.forEach(function(i) {\n    //   item = i;\n    //   return Finish;\n    // }).map(function(o):Step<Item, Quality> return switch o {\n    //   case Depleted: End;\n    //   case Halted(rest): Link(item, rest);\n    //   case Failed(e): Fail(e);\n    // });\n  }\n  \n  public function regroup<Ret>(f:Regrouper<Item, Ret, Quality>):Stream<Ret, Quality> \n    return new RegroupStream(this, f);\n  \n  public function map<Ret>(f:Mapping<Item, Ret, Quality>):Stream<Ret, Quality> \n    return regroup(f);\n  \n  public function filter(f:Filter<Item, Quality>):Stream<Item, Quality>\n    return regroup(f);\n  \n  function destroy() {}  \n    \n  public function append(other:Stream<Item, Quality>):Stream<Item, Quality>\n    return \n      if (depleted) other;\n      else CompoundStream.of([this, other]);\n  \n  public function prepend(other:Stream<Item, Quality>):Stream<Item, Quality>\n    return \n      if (depleted) other;\n      else CompoundStream.of([other, this]);\n  \n  public function blend(other:Stream<Item, Quality>):Stream<Item, Quality>\n    return \n      if (depleted) other;\n      else new BlendStream(this, other);\n    \n  public function decompose(into:Array<Stream<Item, Quality>>) \n    if (!depleted)\n      into.push(this);\n      \n  public function idealize(rescue:Error->Stream<Item, Quality>):IdealStream<Item> \n    return \n      if (depleted) Empty.make();\n      else new IdealizeStream(this, rescue);\n\n  public function reduce<Safety, Result>(initial:Result, reducer:Reducer<Item, Safety, Result>):Future<Reduction<Item, Safety, Quality, Result>> \n    return Future.async(function (cb:Reduction<Item, Safety, Quality, Result>->Void) {\n      forEach(function (item)\n        return reducer.apply(initial, item).map(\n          function (o):Handled<Safety> return switch o {\n            case Progress(v): initial = v; Resume;\n            case Crash(e): Clog(e);\n          })\n      ).handle(function (c) switch c {\n        case Failed(e): cb(Failed(e));\n        case Depleted: cb(Reduced(initial));\n        case Halted(_): throw \"assert\";\n        case Clogged(e, rest): cb(Crashed(e, rest));\n      });\n    }, true);\n\n  public function forEach<Safety>(handler:Handler<Item, Safety>):Future<Conclusion<Item, Safety, Quality>> \n    return throw 'not implemented';\n    \n}\n\nclass IdealizeStream<Item, Quality> extends IdealStreamBase<Item> {\n  var target:Stream<Item, Quality>;\n  var rescue:Error->Stream<Item, Quality>;\n  \n  public function new(target, rescue) {\n    this.target = target;\n    this.rescue = rescue;\n  }\n  \n  override function get_depleted()\n    return target.depleted;\n  \n  override function next():Future<Step<Item, Noise>>\n    return target.next().flatMap(function(v) return switch v {\n      case Fail(e): rescue(e).idealize(rescue).next();\n      default: Future.sync(cast v);\n    });\n    \n  override public function forEach<Safety>(handler:Handler<Item, Safety>):Future<Conclusion<Item, Safety, Noise>>\n    return \n      Future.async(function (cb:Conclusion<Item, Safety, Noise>->Void)\n        target.forEach(handler).handle(function (end) switch end {\n          case Depleted: \n            cb(Depleted);\n          case Halted(rest): \n            cb(Halted(rest.idealize(rescue)));\n          case Clogged(e, at): \n            cb(Clogged(e, at.idealize(rescue)));\n          case Failed(e): \n            rescue(e).idealize(rescue).forEach(handler).handle(cb);\n        })\n      );\n  \n}\n\nclass Single<Item, Quality> extends StreamBase<Item, Quality> {\n  var value:Lazy<Item>;\n  \n  public function new(value) \n    this.value = value;\n    \n  override function next():Future<Step<Item, Quality>>\n    return Future.sync(Link(value.get(), Empty.make()));\n    \n  override public function forEach<Safety>(handle:Handler<Item,Safety>)\n    return handle.apply(value).map(function (step):Conclusion<Item, Safety, Quality> return switch step {\n      case BackOff:\n        Halted(this);\n      case Finish:\n        Halted(Empty.make());\n      case Resume:\n        Depleted;\n      case Clog(e):\n        Clogged(e, this);\n    });\n}\n\nabstract Handler<Item, Safety>(Item->Future<Handled<Safety>>) {\n  inline function new(f) \n    this = f;\n\n  public inline function apply(item):Future<Handled<Safety>>\n    return this(item);\n    \n  @:from static function ofSafeSync<Item>(f:Item->Handled<Noise>):Handler<Item, Noise>\n    return new Handler(function (i) return Future.sync(f(i)));\n    \n  @:from static function ofUnknownSync<Item, Q>(f:Item->Handled<Q>):Handler<Item, Q>\n    return new Handler(function (i) return Future.sync(f(i)));\n    \n  @:from static function ofSafe<Item>(f:Item->Future<Handled<Noise>>):Handler<Item, Noise>\n    return new Handler(f);\n    \n  @:from static function ofUnknown<Item, Q>(f:Item->Future<Handled<Q>>):Handler<Item, Q>\n    return new Handler(f);\n}\n\nabstract Reducer<Item, Safety, Result>(Result->Item->Future<ReductionStep<Safety, Result>>) {\n  inline function new(f) \n    this = f;\n\n  public inline function apply(res, item):Future<ReductionStep<Safety, Result>>\n    return this(res, item);\n    \n  @:from static function ofSafeSync<Item, Result>(f:Result->Item->ReductionStep<Noise, Result>):Reducer<Item, Noise, Result>\n    return new Reducer(function (res, cur) return Future.sync(f(res, cur)));\n    \n  @:from static function ofUnknownSync<Item, Q, Result>(f:Result->Item->ReductionStep<Q, Result>):Reducer<Item, Q, Result>\n    return new Reducer(function (res, cur) return Future.sync(f(res, cur)));\n    \n  @:from static function ofSafe<Item, Result>(f:Result->Item->Future<ReductionStep<Noise, Result>>):Reducer<Item, Noise, Result>\n    return new Reducer(f);\n\n  @:from static function ofPlainSync<Item, Result>(f:Result->Item->Result):Reducer<Item, Noise, Result>\n    return new Reducer(function (res, cur) return Future.sync(Progress(f(res, cur))));\n    \n  @:from static function ofUnknown<Item, Q, Result>(f:Result->Item->Future<ReductionStep<Q, Result>>):Reducer<Item, Q, Result>\n    return new Reducer(f);\n\n  @:from static function ofPromiseBased<Item, Result>(f:Result->Item->Promise<Result>)\n    return new Reducer(function (res, cur) return f(res, cur).map(function (s) return switch s {\n      case Success(r): Progress(r);\n      case Failure(e): Crash(e);\n    }));\n    \n}\n\n#if (java || cs)\nprivate abstract Parts<I, Q>(Array<Dynamic>) {\n  public var length(get, never):Int;\n    inline function get_length() return this.length;\n\n  public function new(parts:Array<Stream<I, Q>>)\n    this = parts;\n\n  @:arrayAccess function get(index:Int):Stream<I, Q>\n    return this[index];\n\n  @:arrayAccess function set(index:Int, value:Stream<I, Q>):Stream<I, Q>\n    return this[index] = value;\n\n  public function copy():Parts<I, Q>\n    return new Parts(cast this.copy());\n\n  public function slice(start:Int, ?end:Int):Parts<I, Q>\n    return new Parts(cast this.slice(start, end));\n  \n  @:from static function ofArray<I, Q>(a:Array<Stream<I, Q>>)\n    return new Parts<I, Q>(a);\n}\n#else\nprivate typedef Parts<I, Q> = Array<Stream<I, Q>>;\n#end\n\nprivate class CompoundStream<Item, Quality> extends StreamBase<Item, Quality> {\n  \n  var parts:Parts<Item, Quality>;\n  \n  function new(parts)\n    this.parts = parts;\n    \n  override function get_depleted()\n    return switch parts.length {\n      case 0: true;\n      case 1: parts[0].depleted;\n      default: false;\n    }\n    \n  override function next():Future<Step<Item, Quality>> {\n    return if(parts.length == 0) Future.sync(Step.End);\n    else parts[0].next().flatMap(function(v) return switch v {\n      case End if(parts.length > 1): parts[1].next();\n      case Link(v, rest):\n        var copy = parts.copy();\n        copy[0] = rest;\n        Future.sync(Link(v, new CompoundStream(copy)));\n      default: Future.sync(v);\n    });\n  }\n  \n  override public function decompose(into:Array<Stream<Item, Quality>>):Void \n    for (p in parts)\n      p.decompose(into);\n  \n  override public function forEach<Safety>(handler:Handler<Item, Safety>):Future<Conclusion<Item, Safety, Quality>> \n    return Future.async(consumeParts.bind(cast parts, handler, _));\n      \n  static function consumeParts<Item, Quality, Safety>(parts:Parts<Item, Quality>, handler:Handler<Item, Safety>, cb:Conclusion<Item, Safety, Quality>->Void) \n    if (parts.length == 0)\n      cb(Depleted);\n    else\n      (parts[0]:Stream<Item, Quality>).forEach(handler).handle(function (o) switch o {\n        case Depleted:\n          \n          consumeParts(parts.slice(1), handler, cb);\n          \n        case Halted(rest):\n          \n          parts = parts.copy();\n          parts[0] = rest;\n          cb(Halted(new CompoundStream(parts)));\n          \n        case Clogged(e, at):\n          \n          if (at.depleted)\n            parts = parts.slice(1);\n          else {\n            parts = parts.copy();\n            parts[0] = at;\n          }\n          \n          cb(Clogged(e, new CompoundStream(parts)));\n          \n        case Failed(e):\n          \n          cb(Failed(e));\n                    \n      });  \n      \n  static public function of<Item, Quality>(streams:Array<Stream<Item, Quality>>):Stream<Item, Quality> {\n    \n    var ret = [];\n    \n    for (s in streams)\n      s.decompose(ret);\n      \n    return \n      if (ret.length == 0) Empty.make();\n      else new CompoundStream(ret);\n  }      \n  \n}\n\nclass FutureStream<Item, Quality> extends StreamBase<Item, Quality> {\n  var f:Future<Stream<Item, Quality>>;\n  public function new(f)\n    this.f = f;\n    \n  override function next():Future<Step<Item, Quality>>\n    return f.flatMap(function(s) return s.next());\n    \n  override public function forEach<Safety>(handler:Handler<Item, Safety>) {\n    return Future.async(function (cb) {\n      f.handle(function (s) s.forEach(handler).handle(cb));\n    });\n  }\n}\n\nclass BlendStream<Item, Quality> extends Generator<Item, Quality> {\n  \n  public function new(a:Stream<Item, Quality>, b:Stream<Item, Quality>) {\n    var first = null;\n    \n    function wait(s:Stream<Item, Quality>) {\n      return s.next().map(function(o) {\n        if(first == null) first = s;\n        return o;\n      });\n    }\n    \n    var n1 = wait(a);\n    var n2 = wait(b);\n    \n    super(Future.async(function(cb) {\n      n1.first(n2).handle(function(o) switch o {\n        case Link(item, rest):\n          cb(Link(item, new BlendStream(rest, first == a ? b : a)));\n        case End:\n          (first == a ? n2 : n1).handle(cb);\n        case Fail(e):\n          cb(Fail(e));\n      });\n    }));\n    \n  }\n}\n\n\nclass Generator<Item, Quality> extends StreamBase<Item, Quality> {\n  var upcoming:Future<Step<Item, Quality>>;\n  \n  function new(upcoming) \n    this.upcoming = upcoming;\n    \n  override function next():Future<Step<Item, Quality>>\n    return upcoming;\n  \n  override public function forEach<Safety>(handler:Handler<Item, Safety>)\n    return Future.async(function (cb:Conclusion<Item, Safety, Quality>->Void) \n      upcoming.handle(function (e) switch e {\n        case Link(v, then):\n          handler.apply(v).handle(function (s) switch s {\n            case BackOff:\n              cb(Halted(this));\n            case Finish:\n              cb(Halted(then));\n            case Resume:\n              then.forEach(handler).handle(cb);\n            case Clog(e):\n              cb(Clogged(e, this));\n          });\n        case Fail(e):\n          cb(Failed(e));\n        case End:\n          cb(Depleted);\n      }),\n  true\n    );\n  \n  static public function stream<I, Q>(step:(Step<I, Q>->Void)->Void) {\n    return new Generator(Future.async(step, true));\n  }\n    \n}\n\nenum Step<Item, Quality> {\n  Link(value:Item, next:Stream<Item, Quality>):Step<Item, Quality>;\n  Fail(e:Error):Step<Item, Error>;\n  End:Step<Item, Quality>;\n}\n\nclass SignalStream<Item, Quality> extends Generator<Item, Quality> {\n\tpublic function new(signal:Signal<Yield<Item, Quality>>) {\n\t\tsuper(signal.nextTime().map(function(o):Step<Item, Quality> return switch o {\n\t\t\tcase Data(data): Link(data, new SignalStream(signal));\n\t\t\tcase Fail(e): Fail(e);\n\t\t\tcase End: End;\n\t\t}));\n\t}\n}\n\nenum Yield<Item, Quality> {\n\tData(data:Item):Yield<Item, Quality>;\n\tFail(e:Error):Yield<Item, Error>;\n\tEnd:Yield<Item, Quality>;\n}\n","package tink.io.nodejs;\n\nimport tink.streams.Stream;\n\nusing tink.CoreApi;\n\nclass NodejsSource extends Generator<Chunk, Error> {\n  \n  function new(target:WrappedReadable) \n    super(Future.async(function (cb) {\n      target.read().handle(function (o) cb(switch o {\n        case Success(null): End;\n        case Success(chunk): Link(chunk, new NodejsSource(target));\n        case Failure(e): Fail(e);\n      }));\n    }, true));    \n  \n  static public function wrap(name, native, chunkSize, onEnd)\n    return new NodejsSource(new WrappedReadable(name, native, chunkSize, onEnd));\n  \n}","package tink.io.nodejs;\n\nimport js.node.Buffer;\nimport js.node.stream.Readable.IReadable;\n\nusing tink.CoreApi;\n\nclass WrappedReadable {\n\n  var native:IReadable;\n  var name:String;\n  var end:Surprise<Null<Chunk>, Error>;\n  var chunkSize:Int;\n      \n  public function new(name, native, chunkSize, onEnd) {\n    this.name = name;\n    this.native = native;\n    this.chunkSize = chunkSize;\n    end = Future.async(function (cb) {\n      native.once('end', function () cb(Success(null)));\n      native.once('error', function (e:{ code:String, message:String }) cb(Failure(new Error('${e.code} - Failed reading from $name because ${e.message}'))));      \n    });\n    if (onEnd != null)\n      end.handle(function () \n        js.Node.process.nextTick(onEnd)\n      );\n  }\n\n  public function read():Promise<Null<Chunk>>\n    return Future.async(function (cb) {\n      function attempt() {\n        try \n          switch native.read(chunkSize) {\n            case null:\n              native.once('readable', attempt);\n            case chunk:\n              var buf:Buffer = \n                if (Std.is(chunk, String))\n                  new Buffer((chunk:String))\n                else\n                  chunk;\n                  \n              cb(Success((new WrappedBuffer(buf) : Chunk)));\n          }\n        catch (e:Dynamic) {\n          cb(Failure(Error.withData('Error while reading from $name', e)));\n        }\n      }\n                    \n      attempt();\n      //end.handle(cb);\n    }).first(end);\n}","package tink.core;\r\n\r\nusing tink.CoreApi;\r\n\r\n#if js\r\nimport #if haxe4 js.lib.Error #else js.Error #end as JsError;\r\nimport #if haxe4 js.lib.Promise #else js.Promise #end as JsPromise;\r\n#end\r\n\r\n@:forward(handle, gather, eager)\r\nabstract Future<T>(FutureObject<T>) from FutureObject<T> to FutureObject<T> {\r\n  \r\n  public static var NULL:Future<Dynamic> = Future.sync(null);\r\n  public static var NOISE:Future<Noise> = Future.sync(Noise);\r\n  public static var NEVER:Future<Dynamic> = (NeverFuture.inst:FutureObject<Dynamic>);\r\n\r\n  public inline function new(f:Callback<T>->CallbackLink) \r\n    this = new SimpleFuture(f);  \r\n  \r\n  /**\r\n   *  Creates a future that contains the first result from `this` or `other`\r\n   */\r\n  public function first(other:Future<T>):Future<T> { // <-- consider making it lazy by default ... also pull down into FutureObject\r\n    var ret = Future.trigger();\r\n    var l1 = this.handle(ret.trigger);\r\n    var l2 = other.handle(ret.trigger);\r\n    var ret = ret.asFuture();\r\n    if (l1 != null)\r\n      ret.handle(l1);\r\n    if (l2 != null)\r\n      ret.handle(l2);\r\n    return ret;\r\n  }\r\n  \r\n  /**\r\n   *  Creates a new future by applying a transform function to the result.\r\n   *  Different from `flatMap`, the transform function of `map` returns a sync value\r\n   */\r\n  public inline function map<A>(f:T->A, ?gather = true):Future<A> {\r\n    var ret = this.map(f);\r\n    return\r\n      if (gather) ret.gather();\r\n      else ret;\r\n  }\r\n  \r\n  /**\r\n   *  Creates a new future by applying a transform function to the result.\r\n   *  Different from `map`, the transform function of `flatMap` returns a `Future`\r\n   */\r\n  public inline function flatMap<A>(next:T->Future<A>, ?gather = true):Future<A> {\r\n    var ret = this.flatMap(next);\r\n    return\r\n      if (gather) ret.gather();\r\n      else ret;    \r\n  }  \r\n  \r\n  /**\r\n   *  Like `map` and `flatMap` but with a polymorphic transformer and return a `Promise`\r\n   *  @see `Next`\r\n   */\r\n  public function next<R>(n:Next<T, R>):Promise<R>\r\n    return this.flatMap(function (v) return n(v));\r\n  \r\n  /**\r\n   *  Merges two futures into one by applying the merger function on the two future values\r\n   */\r\n  public function merge<A, R>(other:Future<A>, merger:T->A->R, ?gather = true):Future<R> \r\n    return flatMap(function (t:T) {\r\n      return other.map(function (a:A) return merger(t, a), false);\r\n    }, gather);\r\n  \r\n  /**\r\n   *  Flattens `Future<Future<A>>` into `Future<A>`\r\n   */\r\n  static public function flatten<A>(f:Future<Future<A>>):Future<A> \r\n    return new NestedFuture(f);\r\n  \r\n  #if js\r\n  /**\r\n   *  Casts a js Promise into a Surprise\r\n   */\r\n  @:from static public function ofJsPromise<A>(promise:JsPromise<A>):Surprise<A, Error>\r\n    return Future.async(function(cb) promise.then(function(a) cb(Success(a))).catchError(function(e:JsError) cb(Failure(Error.withData(e.message, e)))));\r\n  #end\r\n  \r\n  @:from static inline function ofAny<T>(v:T):Future<T>\r\n    return Future.sync(v);\r\n  \r\n  /**\r\n   *  Casts a Surprise into a Promise\r\n   */\r\n  static inline public function asPromise<T>(s:Surprise<T, Error>):Promise<T>\r\n    return s;\r\n  \r\n  /**\r\n   *  Merges multiple futures into Future<Array<A>>\r\n   */\r\n  static public function ofMany<A>(futures:Array<Future<A>>, ?gather:Bool = true) {\r\n    var ret = sync([]);\r\n    for (f in futures)\r\n      ret = ret.flatMap(\r\n        function (results:Array<A>) \r\n          return f.map(\r\n            function (result) \r\n              return results.concat([result]),\r\n            false\r\n          ),\r\n        false\r\n      );\r\n    return \r\n      if (gather) ret.gather();\r\n      else ret;\r\n  }\r\n  \r\n  @:deprecated('Implicit cast from Array<Future> is deprecated, please use `ofMany` instead. Please create an issue if you find it useful, and don\\'t want this cast removed.')\r\n  @:from static function fromMany<A>(futures:Array<Future<A>>):Future<Array<A>> \r\n    return ofMany(futures);\r\n  \r\n  //TODO: use this as `sync` for 2.0\r\n  @:noUsing static inline public function lazy<A>(l:Lazy<A>):Future<A>\r\n    return new SyncFuture(l);    \r\n  \r\n  /**\r\n   *  Creates a sync future.\r\n   *  Example: `var i = Future.sync(1); // Future<Int>`\r\n   */\r\n  @:noUsing static inline public function sync<A>(v:A):Future<A> \r\n    return new SyncFuture(v); \r\n    \r\n  /**\r\n   *  Creates an async future\r\n   *  Example: `var i = Future.async(function(cb) cb(1)); // Future<Int>`\r\n   */\r\n  #if python @:native('make') #end\r\n  @:noUsing static public function async<A>(f:(A->Void)->Void, ?lazy = false):Future<A> \r\n    if (lazy) \r\n      return new LazyTrigger(f);\r\n    else {\r\n      var op = trigger();\r\n      var wrapped:Callback<A->Void> = f;\r\n      wrapped.invoke(op.trigger);\r\n      return op;      \r\n    }    \r\n    \r\n  /**\r\n   *  Same as `first`\r\n   */\r\n  @:noCompletion @:op(a || b) static public function or<A>(a:Future<A>, b:Future<A>):Future<A>\r\n    return a.first(b);\r\n    \r\n  /**\r\n   *  Same as `first`, but use `Either` to handle the two different types\r\n   */\r\n  @:noCompletion @:op(a || b) static public function either<A, B>(a:Future<A>, b:Future<B>):Future<Either<A, B>>\r\n    return a.map(Either.Left, false).first(b.map(Either.Right, false));\r\n      \r\n  /**\r\n   *  Uses `Pair` to merge two futures\r\n   */\r\n  @:noCompletion @:op(a && b) static public function and<A, B>(a:Future<A>, b:Future<B>):Future<Pair<A, B>>\r\n    return a.merge(b, function (a, b) return new Pair(a, b));\r\n  \r\n  @:noCompletion @:op(a >> b) static public function _tryFailingFlatMap<D, F, R>(f:Surprise<D, F>, map:D->Surprise<R, F>)\r\n    return f.flatMap(function (o) return switch o {\r\n      case Success(d): map(d);\r\n      case Failure(f): Future.sync(Failure(f));\r\n    });\r\n\r\n  @:noCompletion @:op(a >> b) static public function _tryFlatMap<D, F, R>(f:Surprise<D, F>, map:D->Future<R>):Surprise<R, F> \r\n    return f.flatMap(function (o) return switch o {\r\n      case Success(d): map(d).map(Success);\r\n      case Failure(f): Future.sync(Failure(f));\r\n    });\r\n    \r\n  @:noCompletion @:op(a >> b) static public function _tryFailingMap<D, F, R>(f:Surprise<D, F>, map:D->Outcome<R, F>)\r\n    return f.map(function (o) return o.flatMap(map));\r\n\r\n  @:noCompletion @:op(a >> b) static public function _tryMap<D, F, R>(f:Surprise<D, F>, map:D->R)\r\n    return f.map(function (o) return o.map(map));    \r\n  \r\n  @:noCompletion @:op(a >> b) static public function _flatMap<T, R>(f:Future<T>, map:T->Future<R>)\r\n    return f.flatMap(map);\r\n\r\n  @:noCompletion @:op(a >> b) static public function _map<T, R>(f:Future<T>, map:T->R)\r\n    return f.map(map);\r\n\r\n  /**\r\n   *  Creates a new `FutureTrigger`\r\n   */\r\n  @:noUsing static public inline function trigger<A>():FutureTrigger<A> \r\n    return new FutureTrigger();  \r\n    \r\n  @:noUsing static public function delay<T>(ms:Int, value:Lazy<T>):Future<T>\r\n    return Future.async(function(cb) haxe.Timer.delay(function() cb(value.get()), ms));\r\n\r\n}\r\n\r\nprivate interface FutureObject<T> {\r\n\r\n  function map<R>(f:T->R):Future<R>;\r\n  function flatMap<R>(f:T->Future<R>):Future<R>;\r\n  /**\r\n   *  Registers a callback to handle the future result.\r\n   *  If the result is already available, the callback will be invoked immediately.\r\n   *  @return A `CallbackLink` instance that can be used to cancel the callback, no effect if the callback is already invoked \r\n   */\r\n  function handle(callback:Callback<T>):CallbackLink;\r\n  /**\r\n   *  Caches the result to ensure the underlying tranform is performed once only.\r\n   *  Useful for tranformed futures, such as product of `map` and `flatMap`\r\n   *  so that the transformation function will not be invoked for every callback\r\n   */\r\n  function gather():Future<T>;\r\n  /**\r\n   *  Makes this future eager.\r\n   *  Futures are lazy by default, i.e. it does not try to fetch the result until someone `handle` it\r\n   */\r\n  function eager():Future<T>;\r\n}\r\n\r\nprivate class NeverFuture<T> implements FutureObject<T> {\r\n  public static var inst(default, null):NeverFuture<Dynamic> = new NeverFuture();\r\n  function new() {}\r\n  public function map<R>(f:T->R):Future<R> return cast inst;\r\n  public function flatMap<R>(f:T->Future<R>):Future<R> return cast inst;\r\n  public function handle(callback:Callback<T>):CallbackLink return null;\r\n  public function gather():Future<T> return cast inst;\r\n  public function eager():Future<T> return cast inst;\r\n}\r\n\r\nprivate class SyncFuture<T> implements FutureObject<T> {\r\n  \r\n  var value:Lazy<T>;\r\n\r\n  public inline function new(value)\r\n    this.value = value;\r\n\r\n  public inline function map<R>(f:T->R):Future<R>\r\n    return new SyncFuture(value.map(f));\r\n\r\n  public inline function flatMap<R>(f:T->Future<R>):Future<R>\r\n    return new SimpleFuture({\r\n      var l = value.map(f);\r\n      function (cb) return l.get().handle(cb);\r\n    });\r\n\r\n  public function handle(cb:Callback<T>):CallbackLink {\r\n    cb.invoke(value);\r\n    return null;\r\n  }\r\n\r\n  public function eager()\r\n    return this;\r\n\r\n  public function gather()\r\n    return this;\r\n}\r\n\r\nprivate class SimpleFuture<T> implements FutureObject<T> {\r\n  \r\n  var f:Callback<T>->CallbackLink;\r\n  var gathered:Future<T>;\r\n\r\n  public inline function new(f) \r\n    this.f = f;\r\n\r\n  public inline function handle(callback:Callback<T>):CallbackLink\r\n    return f(callback);\r\n\r\n  public inline function map<R>(f:T->R):Future<R>\r\n    return new SimpleFuture(function (cb) {\r\n      return handle(function (v) cb.invoke(f(v)));\r\n    });\r\n\r\n  public inline function flatMap<R>(f:T->Future<R>):Future<R>\r\n    return Future.flatten(map(f));\r\n\r\n  public inline function gather():Future<T> \r\n    return\r\n      if (gathered != null) gathered;\r\n      else gathered = FutureTrigger.gatherFuture((this:Future<T>));\r\n\r\n  public inline function eager():Future<T> {\r\n    var ret = gather();\r\n    ret.handle(function () {});\r\n    return ret;\r\n  }\r\n}\r\n\r\nprivate class NestedFuture<T> implements FutureObject<T> {\r\n  var outer:Future<Future<T>>;\r\n  var gathered:Future<T>;\r\n\r\n  public inline function new(outer)\r\n    this.outer = outer;\r\n\r\n  public inline function map<R>(f:T->R):Future<R>\r\n    return outer.flatMap(function (inner) return inner.map(f));\r\n\r\n  public inline function flatMap<R>(f:T->Future<R>):Future<R>\r\n    return outer.flatMap(function (inner) return inner.flatMap(f));\r\n  \r\n  public inline function gather():Future<T> \r\n    return\r\n      if (gathered != null) gathered;\r\n      else gathered = FutureTrigger.gatherFuture((this:Future<T>));\r\n\r\n  public inline function eager():Future<T> {\r\n    var ret = gather();\r\n    ret.handle(function () {});\r\n    return ret;\r\n  }\r\n  \r\n  public function handle(cb:Callback<T>) {\r\n    var ret = null;\r\n    ret = outer.handle(function (inner:Future<T>) {\r\n      ret = inner.handle(function (result) cb.invoke(result));\r\n    });\r\n    return ret;\r\n  }\r\n}\r\n\r\nclass FutureTrigger<T> implements FutureObject<T> {\r\n  var result:T;\r\n  var list:CallbackList<T>;\r\n\r\n  public function new() \r\n    this.list = new CallbackList();\r\n  \r\n  public function handle(callback:Callback<T>):CallbackLink\r\n    return switch list {\r\n      case null: \r\n        callback.invoke(result);\r\n        null;\r\n      case v:\r\n        v.add(callback);\r\n    }\r\n\r\n  public function map<R>(f:T->R):Future<R>\r\n    return switch list {\r\n      case null: Future.sync(f(result));\r\n      case v:\r\n        var ret = new FutureTrigger();\r\n        list.add(function (v) ret.trigger(f(v)));\r\n        ret;\r\n    }\r\n\r\n  public function flatMap<R>(f:T->Future<R>):Future<R>\r\n    return switch list {\r\n      case null: f(result);\r\n      case v:\r\n        var ret = new FutureTrigger();\r\n        list.add(function (v) f(v).handle(ret.trigger));\r\n        ret;\r\n    }\r\n\r\n  public inline function gather()\r\n    return this;\r\n\r\n  public function eager()\r\n    return this;\r\n\r\n  public inline function asFuture():Future<T>\r\n    return this;\r\n\r\n  @:noUsing static public function gatherFuture<T>(f:Future<T>):Future<T> {\r\n    var op = null;\r\n    return new Future<T>(function (cb:Callback<T>) {\r\n      if (op == null) {\r\n        op = new FutureTrigger();\r\n        f.handle(op.trigger);\r\n        f = null;        \r\n      }\r\n      return op.handle(cb);\r\n    });  \r\n  }\r\n\r\n  /**\r\n   *  Triggers a value for this future\r\n   */\r\n  public function trigger(result:T):Bool\r\n    return\r\n      if (list == null) false;\r\n      else {\r\n        var list = this.list;\r\n        this.list = null;\r\n        this.result = result;\r\n        list.invoke(result);\r\n        list.clear();//free callback links          \r\n        true;\r\n      }\r\n}\r\n\r\nprivate class LazyTrigger<T> extends FutureTrigger<T> {\r\n  var op:Callback<T->Void>;\r\n\r\n  public function new(op) {\r\n    #if debug\r\n      if (op == null) throw 'invalid argument';\r\n    #end\r\n    this.op = op;\r\n    super();\r\n  }\r\n\r\n  override public function eager() {\r\n    if (op != null) {\r\n      var op = op;\r\n      this.op = null;\r\n      op.invoke(trigger);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  override public function map<R>(f:T->R):Future<R> \r\n    return \r\n      if (op == null) super.map(f);\r\n      else Future.async(function (cb) {\r\n        handle(function (v) cb(f(v)));\r\n      }, true);\r\n\r\n  override public function flatMap<R>(f:T->Future<R>):Future<R>  \r\n    return \r\n      if (op == null) super.flatMap(f);\r\n      else Future.async(function (cb) {\r\n        handle(function (v) f(v).handle(cb));\r\n      }, true);\r\n\r\n  override public function handle(cb) {\r\n    eager();\r\n    return super.handle(cb);\r\n  }\r\n}\r\n\r\ntypedef Surprise<D, F> = Future<Outcome<D, F>>;\r\n\r\n#if js\r\nclass JsPromiseTools {\r\n  static inline public function toSurprise<A>(promise:JsPromise<A>):Surprise<A, Error>\r\n    return Future.ofJsPromise(promise);\r\n  static inline public function toPromise<A>(promise:JsPromise<A>):Promise<A>\r\n    return Future.ofJsPromise(promise);\r\n}\r\n#end\r\n","package tink.core;\r\n\r\nabstract Lazy<T>(LazyObject<T>) from LazyObject<T> {\r\n\r\n  @:to public inline function get():T\r\n    return this.get();\r\n\r\n  @:from static public inline function ofFunc<T>(f:Void->T):Lazy<T>\r\n    return new LazyFunc(f);\r\n\r\n  public inline function map<A>(f:T->A):Lazy<A>\r\n    return this.map(f);\r\n\r\n  public inline function flatMap<A>(f:T->Lazy<A>):Lazy<A>\r\n    return this.flatMap(f);\r\n\r\n  @:from @:noUsing static inline function ofConst<T>(c:T):Lazy<T>\r\n    return new LazyConst(c);\r\n}\r\n\r\nprivate interface LazyObject<T> {\r\n  function get():T;\r\n  function map<R>(f:T->R):Lazy<R>;\r\n  function flatMap<R>(f:T->Lazy<R>):Lazy<R>;\r\n}\r\n\r\nprivate class LazyConst<T> implements LazyObject<T> {\r\n\r\n  var value:T;\r\n\r\n  public inline function new(value)\r\n    this.value = value;\r\n\r\n  public inline function get()\r\n    return value;\r\n\r\n  public inline function map<R>(f:T->R):Lazy<R>\r\n    return new LazyFunc(function () return f(value));\r\n\r\n  public inline function flatMap<R>(f:T->Lazy<R>):Lazy<R>\r\n    return new LazyFunc(function () return f(value).get());\r\n}\r\n\r\nprivate class LazyFunc<T> implements LazyObject<T> {\r\n  var f:Void->T;\r\n  var result:T;\r\n  #if debug var busy = false; #end\r\n\r\n  public function new(f) this.f = f;\r\n\r\n  public function get() {\r\n    #if debug if (busy) throw new Error('circular lazyness');#end\r\n    if (f != null) {\r\n      #if debug busy = true;#end\r\n      result = f();\r\n      f = null;\r\n      #if debug busy = false;#end\r\n    }\r\n    return result;\r\n  }\r\n\r\n  public inline function map<R>(f:T->R):Lazy<R>\r\n    return new LazyFunc(function () return f(get()));\r\n\r\n  public inline function flatMap<R>(f:T->Lazy<R>):Lazy<R>\r\n    return new LazyFunc(function () return f(get()).get());\r\n}\r\n","package tink.core;\r\n\r\nabstract Callback<T>(T->Void) from (T->Void) {\r\n  \r\n  inline function new(f) \r\n    this = f;\r\n  \r\n  @:to inline function toFunction()\r\n    return this;\r\n    \r\n  static var depth = 0;\r\n  static inline var MAX_DEPTH = #if (interp && !eval) 100 #elseif python 200 #else 500 #end;\r\n  public function invoke(data:T):Void\r\n    if (depth < MAX_DEPTH) {\r\n      depth++;\r\n      (this)(data); //TODO: consider handling exceptions here (per opt-in?) to avoid a failing callback from taking down the whole app\r\n      depth--;\r\n    }\r\n    else Callback.defer(invoke.bind(data));\r\n  \r\n  // This seems useful, but most likely is not. \r\n  @:deprecated('Implicit cast from Callback<Noise> is deprecated. Please create an issue if you find it useful, and don\\'t want this cast removed.')\r\n  @:to static function ignore<T>(cb:Callback<Noise>):Callback<T>\r\n    return function (_) cb.invoke(Noise);\r\n    \r\n  @:from static function fromNiladic<A>(f:Void->Void):Callback<A> //inlining this seems to cause recursive implicit casts\r\n    return #if js cast f #else function (_) f() #end;\r\n  \r\n  @:from static function fromMany<A>(callbacks:Array<Callback<A>>):Callback<A> \r\n    return\r\n      function (v:A) \r\n        for (callback in callbacks)\r\n          callback.invoke(v);\r\n          \r\n  @:noUsing static public function defer(f:Void->Void) {\r\n    #if macro\r\n      f();\r\n    #elseif tink_runloop\r\n      tink.RunLoop.current.work(f);\r\n    #elseif hxnodejs\r\n      js.Node.process.nextTick(f);\r\n    #elseif luxe\r\n      Luxe.timer.schedule(0, f);\r\n    #elseif snow\r\n      snow.api.Timer.delay(0, f);\r\n    #elseif java\r\n      haxe.Timer.delay(f, 1);//TODO: find something that leverages the platform better\r\n    #elseif ((haxe_ver >= 3.3) || js || flash || openfl)\r\n      haxe.Timer.delay(f, 0);\r\n    #else\r\n      f();\r\n    #end\r\n  }\r\n}\r\nprivate interface LinkObject {\r\n  function cancel():Void;\r\n}\r\n\r\nabstract CallbackLink(LinkObject) from LinkObject {\r\n\r\n  inline function new(link:Void->Void) \r\n    this = new SimpleLink(link);\r\n\r\n  public inline function cancel():Void \r\n    if (this != null) this.cancel();\r\n  \r\n  //@:deprecated('Use cancel() instead')\r\n  public inline function dissolve():Void \r\n    cancel();\r\n\r\n  static function noop() {}\r\n  \r\n  @:to inline function toFunction():Void->Void\r\n    return if (this == null) noop else this.cancel;\r\n    \r\n  @:to inline function toCallback<A>():Callback<A> \r\n    return function (_) this.cancel();\r\n    \r\n  @:from static inline function fromFunction(f:Void->Void) \r\n    return new CallbackLink(f);\r\n\r\n  @:op(a & b) static public inline function join(a:CallbackLink, b:CallbackLink):CallbackLink\r\n    return new LinkPair(a, b);\r\n    \r\n  @:from static public function fromMany(callbacks:Array<CallbackLink>)\r\n    return fromFunction(function () for (cb in callbacks) cb.cancel());\r\n}\r\n\r\nprivate class SimpleLink implements LinkObject {\r\n  var f:Void->Void;\r\n\r\n  public inline function new(f) \r\n    this.f = f;\r\n\r\n  public inline function cancel()\r\n    if (f != null) {\r\n      f();\r\n      f = null;\r\n    }\r\n}\r\n\r\nprivate class LinkPair implements LinkObject {\r\n  \r\n  var a:CallbackLink;\r\n  var b:CallbackLink;\r\n  var dissolved:Bool = false;\r\n  public function new(a, b) {\r\n    this.a = a;\r\n    this.b = b;\r\n  }\r\n\r\n  public function cancel() \r\n    if (!dissolved) {\r\n      dissolved = true;\r\n      a.cancel();\r\n      b.cancel();\r\n      a = null;\r\n      b = null;\r\n    }\r\n}\r\n\r\nprivate class ListCell<T> implements LinkObject {\r\n  \r\n  var list:Array<ListCell<T>>;\r\n  var cb:Callback<T>;\r\n\r\n  public function new(cb, list) {\r\n    if (cb == null) throw 'callback expected but null received';\r\n    this.cb = cb;\r\n    this.list = list;\r\n  }\r\n\r\n  public inline function invoke(data)\r\n    if (cb != null) \r\n      cb.invoke(data);\r\n\r\n  public function clear() {\r\n    list = null;\r\n    cb = null;\r\n  }\r\n\r\n  public function cancel() \r\n    switch list {\r\n      case null:\r\n      case v: clear(); v.remove(this);\r\n    }\r\n}\r\n\r\nabstract CallbackList<T>(Array<ListCell<T>>) {\r\n  \r\n  public var length(get, never):Int;\r\n  \r\n  inline public function new():Void\r\n    this = [];\r\n  \r\n  inline function get_length():Int \r\n    return this.length;  \r\n  \r\n  public function add(cb:Callback<T>):CallbackLink {\r\n    var node = new ListCell(cb, this);\r\n    this.push(node);\r\n    return node;\r\n  }\r\n    \r\n  public function invoke(data:T) \r\n    for (cell in this.copy()) \r\n      cell.invoke(data);\r\n      \r\n  public function clear():Void \r\n    for (cell in this.splice(0, this.length)) \r\n      cell.clear();\r\n\r\n  public function invokeAndClear(data:T)\r\n    for (cell in this.splice(0, this.length)) \r\n      cell.invoke(data);\r\n\r\n}\r\n","package tink.core;\r\n\r\nimport tink.core.Outcome;\r\nimport haxe.CallStack;\r\n\r\n#if js\r\nimport #if haxe4 js.lib.Error #else js.Error #end as JsError;\r\n#end\r\n\r\ntypedef Pos = \r\n  #if macro\r\n    haxe.macro.Expr.Position;\r\n  #elseif tink_core_no_error_pos\r\n    {};\r\n  #else\r\n    haxe.PosInfos;\r\n  #end\r\n\r\n//TODO: there's huge overlap with haxe.macro.Error\r\ntypedef Error = TypedError<Dynamic>;\r\n\r\n@:enum abstract ErrorCode(Int) from Int to Int {\r\n  var BadRequest = 400;\r\n  var Unauthorized = 401;\r\n  var PaymentRequired = 402;\r\n  var Forbidden = 403;\r\n  var NotFound = 404;\r\n  var MethodNotAllowed = 405;\r\n  var Gone = 410;\r\n  var NotAcceptable = 406;\r\n  var Timeout = 408;\r\n  var Conflict = 409;\r\n  var UnsupportedMediaType = 415;\r\n  var OutOfRange = 416;\r\n  var ExpectationFailed = 417;\r\n  var I_am_a_Teapot = 418;\r\n  var AuthenticationTimeout = 419;\r\n  var UnprocessableEntity = 422;\r\n\r\n  var InternalError = 500;\r\n  var NotImplemented = 501;\r\n  var ServiceUnavailable = 503;\r\n  var InsufficientStorage = 507;\r\n  var BandwidthLimitExceeded = 509;\r\n\r\n}\r\n\r\nclass TypedError<T> {\r\n  public var message(default, null):String;//It might make sense for the message to be lazy\r\n  public var code(default, null):ErrorCode;\r\n  public var data(default, null):T;\r\n  public var pos(default, null):Null<Pos>;\r\n  public var callStack(default, null):Stack;\r\n  public var exceptionStack(default, null):Stack;\r\n  var isTinkError = true;\r\n  \r\n  public function new(?code:ErrorCode = InternalError, message, ?pos) {\r\n    this.code = code;\r\n    this.message = message;\r\n    this.pos = pos;\r\n    this.exceptionStack = #if error_stack try CallStack.exceptionStack() catch(e:Dynamic) #end [];\r\n    this.callStack = #if error_stack try CallStack.callStack() catch(e:Dynamic) #end [];\r\n  }\r\n  function printPos()\r\n    return\r\n      #if macro\r\n        Std.string(pos);\r\n      #elseif tink_core_no_error_pos\r\n        ;\r\n      #else\r\n        pos.className+'.'+pos.methodName+':'+pos.lineNumber;\r\n      #end\r\n      \r\n  public function toString() {\r\n    var ret = 'Error#$code: $message';\r\n    #if !tink_core_no_error_pos\r\n    if (pos != null)\r\n      ret += \" @ \"+printPos();\r\n    #end\r\n    return ret;\r\n  }\r\n  \r\n  public function throwSelf():Dynamic\r\n    return\r\n      #if macro\r\n        #if tink_macro\r\n          tink.macro.Positions.error(pos, message);\r\n        #else\r\n          haxe.macro.Context.error(message, if (pos == null) haxe.macro.Context.currentPos() else pos);\r\n        #end\r\n      #else\r\n        rethrow(this);\r\n      #end\r\n    \r\n  static public function withData(?code:ErrorCode, message:String, data:Dynamic, ?pos:Pos):Error {\r\n    return typed(code, message, data, pos);\r\n  }\r\n  \r\n  static public function typed<A>(?code:ErrorCode, message:String, data:A, ?pos:Pos):TypedError<A> {\r\n    var ret = new TypedError(code, message, pos);\r\n    ret.data = data;\r\n    return ret;\r\n  }\r\n  \r\n  #if js\r\n  static public inline function ofJsError(e:JsError, ?pos:Pos):Error \r\n    return Error.withData(500, e.message, e, pos);\r\n  #end\r\n  \r\n  @:noUsing static public function asError(v:Dynamic):Null<Error> {\r\n    return \r\n      #if js\r\n        if (v != null && (cast v:Error).isTinkError) cast v;\r\n        else null;\r\n      #else\r\n        Std.instance(v, Error);\r\n      #end\r\n  }\r\n  static public function catchExceptions<A>(f:Void->A, ?report:Dynamic->Error, ?pos:Pos)\r\n    return\r\n      try \r\n        Success(f())\r\n      catch (e:Dynamic)\r\n        Failure(\r\n          switch asError(e) {\r\n            case null:\r\n              if (report == null)\r\n                Error.withData('Unexpected Error', e, pos)\r\n              else\r\n                report(e);\r\n              case e: e;\r\n          }\r\n        );\r\n  \r\n  static public function reporter(?code:ErrorCode, message:String, ?pos:Pos):Dynamic->Error \r\n    return \r\n      function (e:Dynamic) return Error.withData(code, message, e, pos);\r\n      \r\n  static public inline function rethrow(any:Dynamic):Dynamic {\r\n    #if neko\r\n      neko.Lib.rethrow(any);\r\n    #elseif php\r\n      php.Lib.rethrow(any);\r\n    #elseif cpp\r\n      cpp.Lib.rethrow(any);\r\n    #else\r\n      throw any;\r\n    #end\r\n    return any;\r\n  }\r\n\r\n  static public function tryFinally<T>(f:Void->T, cleanup:Void->Void):T {\r\n    #if js\r\n      untyped __js__('try { return f(); } finally { cleanup(); }');\r\n      return null;\r\n    #else\r\n    try {\r\n      var ret = f();\r\n      cleanup();\r\n      return ret;\r\n    }\r\n    catch (e:Dynamic) {\r\n      cleanup();\r\n      return rethrow(e);\r\n    }\r\n    #end\r\n  }\r\n}\r\n\r\n@:forward\r\nabstract Stack(Array<StackItem>) from Array<StackItem> to Array<StackItem> {\r\n  @:to\r\n  public inline function toString():String\r\n    return \r\n      #if error_stack\r\n        CallStack.toString(this);\r\n      #else\r\n        'Error stack not available. Compile with -D error_stack.';\r\n      #end\r\n}","package tink.http;\n\nclass Message<H:Header, B> {\n  \n  public var header(default, null):H;\n  public var body(default, null):B;\n  \n  public function new(header, body) {\n    this.header = header;\n    this.body = body;\n  }\n    \n}","package tink.io;\n\nimport tink.Chunk;\nimport tink.io.PipeOptions;\nimport tink.streams.Stream;\n\nusing tink.io.Source;\nusing tink.CoreApi;\n\ntypedef Sink<FailingWith> = SinkYielding<FailingWith, Noise>;\ntypedef RealSink = Sink<Error>;\ntypedef IdealSink = Sink<Noise>;\n\n@:forward\nabstract SinkYielding<FailingWith, Result>(SinkObject<FailingWith, Result>) \n  from SinkObject<FailingWith, Result> \n  to SinkObject<FailingWith, Result> {\n    \n  public static var BLACKHOLE(default, null):IdealSink = Blackhole.inst;\n\n  public function end():Promise<Bool>\n    return\n      if (this.sealed) false;\n      else this.consume(Source.EMPTY, { end: true }).map(function (r) return switch r {\n        case AllWritten | SinkEnded(_): Success(true);\n        case SinkFailed(e, _): Failure(e);\n      });\n      \n  @:to function dirty():Sink<Error>\n    return cast this;\n    \n  @:from static function ofError(e:Error):RealSink\n    return new ErrorSink(e);\n\n  @:from static function ofPromised(p:Promise<RealSink>):RealSink\n    return new FutureSink(p.map(function(o) return switch o {\n      case Success(v): v;\n      case Failure(e): ofError(e);\n    }));\n\n  #if (nodejs && !macro)\n  static public inline function ofNodeStream(name, r:js.node.stream.Writable.IWritable):RealSink\n    return tink.io.nodejs.NodejsSink.wrap(name, r);\n  #end\n  \n  #if cs\n  static public inline function ofCsStream(name, r:cs.system.io.Stream):RealSink\n    return tink.io.cs.CsSink.wrap(name, r);\n  #end\n\n  static public function ofOutput(name:String, target:haxe.io.Output, ?options:{ ?worker:Worker }):RealSink\n    return new tink.io.std.OutputSink(name, target, switch options {\n      case null | { worker: null }: Worker.get();\n      case { worker: w }: w;\n    });\n\n\n}\n\nprivate class Blackhole extends SinkBase<Noise, Noise> {\n  public static var inst(default, null):Blackhole = new Blackhole();\n  \n  function new() {}\n\n  override public function consume<EIn>(source:Stream<Chunk, EIn>, options:PipeOptions):Future<PipeResult<EIn, Noise, Noise>>\n    return source.forEach(function(_) return Resume).map(function(o):PipeResult<EIn, Noise, Noise> return switch o {\n      case Depleted: AllWritten;\n      case Halted(_): throw 'unreachable';\n      case Failed(e): SourceFailed(e);\n    });\n}\n\nprivate class FutureSink<FailingWith, Result> extends SinkBase<FailingWith, Result> {\n  var f:Future<SinkYielding<FailingWith, Result>>;\n  public function new(f)\n    this.f = f;\n\n  override public function consume<EIn>(source:Stream<Chunk, EIn>, options:PipeOptions):Future<PipeResult<EIn, FailingWith, Result>>\n    return f.flatMap(function (sink) return sink.consume(source, options));\n}\n\nprivate class ErrorSink<Result> extends SinkBase<Error, Result> {\n  \n  var error:Error;\n\n  public function new(error)\n    this.error = error;\n\n  override function get_sealed() \n    return false;\n\n  override public function consume<EIn>(source:Stream<Chunk, EIn>, options:PipeOptions):Future<PipeResult<EIn, Error, Result>>\n    return Future.sync(cast PipeResult.SinkFailed(error, source));//TODO: there's something rotten here - the cast should be unnecessary\n}\n\ninterface SinkObject<FailingWith, Result> {\n  var sealed(get, never):Bool;\n  function consume<EIn>(source:Stream<Chunk, EIn>, options:PipeOptions):Future<PipeResult<EIn, FailingWith, Result>>;\n  \n  //function idealize(recover:Error->SinkObject<FailingWith>):IdealSink;\n}\n\nclass SinkBase<FailingWith, Result> implements SinkObject<FailingWith, Result> {\n  \n  public var sealed(get, never):Bool;\n    function get_sealed() return true;\n  \n  public function consume<EIn>(source:Stream<Chunk, EIn>, options:PipeOptions):Future<PipeResult<EIn, FailingWith, Result>>\n    return throw 'not implemented';\n    \n  //public function idealize(onError:Callback<Error>):IdealSink;\n    \n  //public function idealize(onError:Callback<Error>):IdealSink\n    //return new IdealizedSink(this, onError);\n}\n\n//\n//class IdealizedSink extends IdealSinkBase {\n  //var target:Sink;\n  //var onError:Callback<Error>;\n  //\n  //public function new(target, onError) {\n    //this.target = target;\n    //this.onError = onError;\n  //}\n  //\n  //override public function consumeSafely(source:IdealSource, options:PipeOptions):Future<IdealSource>\n    //return Future.async(function (cb) \n      //target.consume(source, options).handle(function (c) {\n        //switch c.error {\n          //case Some(e): onError.invoke(e);\n          //default:\n        //}\n        //cb(c.rest);\n      //})\n    //);\n  //\n  //override public function endSafely():Future<Bool> {\n    //return target.end().recover(function (_) return Future.sync(false));\n  //}\n//}","package tink.io.nodejs;\n\nimport js.node.Buffer;\nimport tink.io.Sink;\nimport tink.streams.Stream;\n\nusing tink.io.PipeResult;\nusing tink.CoreApi;\n\nclass NodejsSink extends SinkBase<Error, Noise> { \n\n  var target:WrappedWritable;\n  \n  function new(target) \n    this.target = target;\n    \n  override public function consume<EIn>(source:Stream<Chunk, EIn>, options:PipeOptions):Future<PipeResult<EIn, Error, Noise>> {\n    \n    //TODO: consider using native behavior is source is native and options.destructive is set to true\n    \n    var ret = source.forEach(function (c) \n      return target.write(c).map(function (w) return switch w {\n        case Success(true): Resume;\n        case Success(false): BackOff;\n        case Failure(e): Clog(e);\n      })\n    );\n    \n    if (options.end)\n      ret.handle(function (end) target.end());\n    \n    return ret.map(function (c) return c.toResult(Noise));\n  }\n    \n  static public function wrap(name, native)\n    return new NodejsSink(new WrappedWritable(name, native));\n    \n\n}","package tink.io.nodejs;\n\nimport js.node.Buffer;\nimport js.node.stream.Writable;\nusing tink.CoreApi;\n\nclass WrappedWritable {\n  \n  var ended:Promise<Bool>;\n  var name:String;\n  var native:IWritable;\n      \n  public function new(name, native) {\n    \n    this.name = name;\n    this.native = native;\n    \n    this.ended = Future.async(function (cb) {\n      native.once('end', function () cb(Success(false)));\n      native.once('finish', function () cb(Success(false)));\n      native.once('close', function () cb(Success(false)));\n      native.on('error', function (e:{ code:String, message:String }) cb(Failure(new Error('${e.code}: ${e.message}'))));            \n    });\n    \n  }\n  \n  public function end():Promise<Bool> {\n    var didEnd = false;\n    \n    ended.handle(function () didEnd = true).dissolve();\n    \n    if (didEnd)\n      return false;\n    \n    native.end();\n    \n    return ended.next(function (_) return true);\n  }\n  \n  public function write(chunk:Chunk):Promise<Bool> \n    return Future.async(function (cb) {\n      if(chunk.length == 0) {\n        cb(Success(true));\n        return;\n      }\n      var buf = \n        if (Buffer.isBuffer(untyped chunk.buffer)) untyped chunk.buffer;\n        else Buffer.hxFromBytes(chunk.toBytes());//TODO: the above branch is ugly and this one is wasteful\n      native.write(buf, cb.bind(Success(true)));\n    }).first(ended);\n}","package tink.web.routing;\n\nimport haxe.io.Bytes;\nimport tink.Chunk;\nimport tink.http.Header;\nimport tink.http.Request;\nimport tink.http.StructuredBody;\nimport tink.querystring.Pairs;\nimport tink.streams.Stream;\nimport tink.url.Portion;\nimport tink.url.Query;\nimport tink.web.forms.FormField;\n\nusing tink.io.Source;\nusing StringTools;\nusing tink.CoreApi;\n\nabstract Path(Array<Portion>) from Array<Portion> to Array<Portion> {\n  @:to public function toString():String\n    return '/'+[for (p in this) (p:String)].join('/');\n}\n\nclass Context {\n  \n  var request:IncomingRequest;\n  \n  public var depth(default, null):Int;\n  public var parent(default, null):Context;\n\n  var parts:Array<Portion>;\n  var params:Map<String, Portion>;\n    \n  public var header(get, never):IncomingRequestHeader;\n    inline function get_header()\n      return request.header;\n      \n  public var accepts(default, null):String->Bool;\n  \n  \n  public function allRaw():Promise<Chunk>\n    return rawBody.all();\n    \n  public var rawBody(get, never):RealSource;\n    inline function get_rawBody():RealSource\n      return switch this.request.body {\n        case Plain(s): s;\n        default: new Error(NotImplemented, 'not implemented');//TODO: implement\n      }\n      \n  public function headers():Pairs<tink.http.Header.HeaderValue> {\n    return [for (f in header) new Named(toCamelCase(f.name), f.value)];\n  }\n      \n  static function toCamelCase(header:HeaderName) {//TODO: should go some place else\n    var header:String = header;\n    var ret = new StringBuf(),  \n        pos = 0,\n        max = header.length;\n       \n    while (pos < max) {\n      switch header.fastCodeAt(pos++) {\n        case '-'.code:\n          if (pos < max) \n            ret.add(header.charAt(pos++).toLowerCase());\n        case v: \n          ret.addChar(v);\n      }\n    }\n      \n    return ret.toString();\n  }\n  \n  public function parse():Promise<Array<Named<FormField>>>\n    return switch this.request.body {\n      case Parsed(parts): parts;\n      case Plain(src):\n        function parseForm()\n          return \n            src.all().next(\n              function (chunk):Array<Named<FormField>> return [for (part in (chunk.toString() : Query)) new Named(part.name, Value(part.value))]);\n        #if tink_multipart\n        switch tink.multipart.Multipart.check(this.request) {\n          case Some(result):\n            return Future.async(function(cb:Callback<Outcome<Array<Named<FormField>>, Error>>) {\n              var contentType = result.a;\n              var body = result.b.idealize(function(e) {\n                cb.invoke(Failure(e));\n                return Source.EMPTY;\n              });\n              var parser:tink.multipart.Parser = // TODO: make this configurable\n                #if busboy\n                  new tink.multipart.parsers.BusboyParser(contentType.toString());\n                #else\n                  new tink.multipart.parsers.TinkParser(contentType.extensions['boundary']);\n                #end\n              parser.parse(body).collect().handle(cb);\n            });\n          case None:\n            parseForm();\n        }    \n        #else\n          parseForm();\n        #end  \n    }\n      \n  public var pathLength(get, never):Int;\n    inline function get_pathLength()\n      return this.parts.length - this.depth;\n  \n  public function getPrefix():Path\n    return this.parts.slice(0, this.depth);\n    \n  public function getPath():Path\n    return this.parts.slice(this.depth);     \n  \n  public function hasParam(name:String)\n    return this.params.exists(name);\n  \n  public function part(index:Int):Stringly\n    return if(this.depth + index >= this.parts.length) '' else this.parts[this.depth + index];\n   \n  public function param(name:String):Stringly\n    return this.params[name];\n\n  function new(parent, accepts, request, depth, parts, params) {\n    this.parent = parent;\n    this.accepts = accepts;\n    this.request = request;\n    this.depth = depth;\n    this.parts = parts;\n    this.params = params;\n  }\n  \n  public function sub(descend:Int):Context \n    return new Context(this, this.accepts, this.request, this.depth + descend, this.parts, this.params);\n  \n  static public function ofRequest(request:IncomingRequest)\n    return new Context(\n      null,\n      parseAcceptHeader(request.header),\n      request, \n      0,\n      request.header.url.path.parts(), \n      request.header.url.query\n    );\n    \n  static public function authed<U, S:Session<U>>(request:IncomingRequest, getSession:IncomingRequestHeader->S) \n    return new AuthedContext<U, S>(\n      null,\n      parseAcceptHeader(request.header),\n      request, \n      0,\n      request.header.url.path.parts(), \n      request.header.url.query,\n      getSession.bind(request.header)\n    );\n   \n  static function parseAcceptHeader(h:Header)\n    return switch h.get(ACCEPT) {\n      case []: acceptsAll;\n      case values:\n        var accepted = [for (v in values) for (part in v.parse()) part.value => true];\n        if (accepted['*/*']) acceptsAll;\n        else function (t) return accepted.exists(t);\n    }\n    \n  static function acceptsAll(s:String) return true;\n  \n}\n\n@:allow(tink.web.routing)\nclass AuthedContext<U, S:Session<U>> extends Context {\n  \n  public var session(default, null):Lazy<S>;\n  public var user(default, null):Lazy<Promise<Option<U>>>;\n  \n  function new(parent, accepts, request, depth, parts, params, session, ?user) {\n    \n    this.session = session;\n    this.user = switch user {\n      case null:\n        session.map(function (s) return s.getUser());\n      case v: v;\n    }\n    \n    super(parent, accepts, request, depth, parts, params);\n  }\n  \n  override public function sub(descend:Int):AuthedContext<U, S> {\n    return new AuthedContext(this, accepts, request, depth + descend, parts, params, session, user);\n  }\n}\n\nabstract RequestReader<A>(Context->Promise<A>) from Context->Promise<A> {\n  \n  @:from static function ofStringReader<A>(read:String->Outcome<A, Error>):RequestReader<A>\n    return \n      function (ctx:Context):Promise<A>\n        return \n          ctx.allRaw().next(function (body) return read(body.toString()));\n            \n  @:from static function ofSafeStringReader<A>(read:String->A):RequestReader<A>\n    return ofStringReader(function (s) return Success(read(s)));\n    \n}\n","package tink.url;\n\nusing tink.CoreApi;\nusing StringTools;\n\nabstract Portion(String) {\n  \n  public var raw(get, never):String;\n    inline function get_raw()\n      return this;\n      \n  public inline function new(v:String)\n    this = v;\n    \n  @:to function stringly():tink.Stringly\n    return toString();\n      \n  @:to public function toString()\n    return \n      if (this == null) null;\n      else this.urlDecode();\n    \n  @:from static function ofString(s:String)\n    return new Portion(if (s == null) '' else s.urlEncode());\n    \n  #if macro\n  @:to public function toExpr()\n    return macro new tink.url.Portion($v{this});\n  #end\n}","package tink.core;\r\n\r\nusing tink.CoreApi;\r\n\r\n#if js\r\nimport #if haxe4 js.lib.Promise #else js.Promise #end as JsPromise;\r\n#end\r\n\r\nabstract Promise<T>(Surprise<T, Error>) from Surprise<T, Error> to Surprise<T, Error> {\r\n  \r\n  public static var NULL:Promise<Dynamic> = Future.sync(Success(null));\r\n  public static var NOISE:Promise<Noise> = Future.sync(Success(Noise));\r\n  public static var NEVER:Promise<Dynamic> = Future.NEVER;\r\n  \r\n  public inline function new(f:(T->Void)->(Error->Void)->Void, lazy = false) {\r\n    this = Future.async(function(cb) {\r\n      f(function(v) cb(Success(v)), function(e) cb(Failure(e)));\r\n    }, lazy);\r\n  }\r\n  \r\n  public inline function eager():Promise<T>\r\n    return this.eager();\r\n\r\n  public inline function map<R>(f:Outcome<T, Error>->R):Future<R>\r\n    return this.map(f);\r\n\r\n  public inline function flatMap<R>(f:Outcome<T, Error>->Future<R>):Future<R>\r\n    return this.flatMap(f);\r\n\r\n  public inline function tryRecover(f:Next<Error, T>):Promise<T>\r\n    return this.flatMap(function (o) return switch o {\r\n      case Success(d): Future.sync(o);\r\n      case Failure(e): f(e);\r\n    });\r\n\r\n  public inline function recover(f:Recover<T>):Future<T>\r\n    return this.flatMap(function (o) return switch o {\r\n      case Success(d): Future.sync(d);\r\n      case Failure(e): f(e);\r\n    });\r\n  \r\n  public function mapError(f:Error->Error):Promise<T>\r\n    return this.map(function(o) return switch o {\r\n      case Success(_): o;\r\n      case Failure(e): Failure(f(e));\r\n    });\r\n        \r\n  public inline function handle(cb:Callback<Outcome<T, Error>>):CallbackLink\r\n    return this.handle(cb);\r\n    \r\n  @:to public function noise():Promise<Noise>\r\n    return (this:Promise<T>).next(function (v) return Noise);\r\n    \r\n  @:to public function isSuccess():Future<Bool>\r\n    return this.map(function (o) return o.isSuccess());\r\n    \r\n  public function next<R>(f:Next<T, R>, ?gather = true):Promise<R> \r\n    return this.flatMap(function (o) return switch o {\r\n        case Success(d): f(d);\r\n        case Failure(f): Future.sync(Failure(f));\r\n      }, gather);\r\n  \r\n  public inline function swap<R>(v:R):Promise<R> \r\n    return this >> function(_) return v;\r\n  \r\n  public inline function swapError(e:Error):Promise<T> \r\n    return mapError(function(_) return e);\r\n    \r\n  public function merge<A, R>(other:Promise<A>, merger:Combiner<T, A, R>, ?gather = true):Promise<R> \r\n    return next(function (t) return other.next(function (a) return merger(t, a), false), gather);\r\n    \r\n  @:noCompletion @:op(a && b) static public function and<A, B>(a:Promise<A>, b:Promise<B>):Promise<Pair<A, B>>\r\n    return a.merge(b, function (a, b) return new Pair(a, b)); // TODO: a.merge(b, Pair.new); => File \"src/typing/type.ml\", line 555, characters 9-15: Assertion failed\r\n    \r\n  /**\r\n   * Given an Iterable (e.g. Array) of Promises, handle them one by one with the `yield` function until one of them yields `Some` value\r\n   * and the returned promise will resolve that value. If all of them yields `None`, the returned promise will resolve to the `fallback` promise.\r\n   * In a nutshell, it is the async version of the following code:\r\n   * ```haxe\r\n   * for(promise in promises) {\r\n   *   switch yield(promise) {\r\n   *     case Some(v): return v;\r\n   *     case None:\r\n   *   }\r\n   * }\r\n   * return fallback;\r\n   * ```\r\n   * @param promises An Iterable (e.g. Array) of Promises\r\n   * @param yield A function used to handle the promises and should return an Option\r\n   * @param fallback A value to be used when all yields `None`\r\n   * @return Promise<T>\r\n   */\r\n  static public function iterate<A, R>(promises:Iterable<Promise<A>>, yield:Next<A, Option<R>>, fallback:Promise<R>, ?lazy):Promise<R> {\r\n    return Future.async(function(cb) {\r\n      var iter = promises.iterator();\r\n      function next() {\r\n        if(iter.hasNext())\r\n          iter.next().handle(function(o) switch o {\r\n            case Success(v):\r\n              yield(v).handle(function(o) switch o {\r\n                case Success(Some(ret)): cb(Success(ret));\r\n                case Success(None): next();\r\n                case Failure(e): cb(Failure(e));\r\n              });\r\n            case Failure(e):\r\n              cb(Failure(e));\r\n          })\r\n        else\r\n          fallback.handle(cb);\r\n      }\r\n      next();\r\n    }, lazy);\r\n  }\r\n  \r\n  /**\r\n   * Retry a promise generator repeatedly\r\n   * \r\n   * @param gen A function that returns a `Promise`, this function will be called multiple times during the retry process\r\n   * @param next A callback to be called when an attempt failed. An object will be received containing the info of the last attempt:\r\n   *   `attempt` is the number of attempts tried, starting from `1`\r\n   *   `error` is the error produced from the last attempt\r\n   *   `elasped` is the amount of time (in ms) elapsed since the beginning of the `retry` call\r\n   * \r\n   *   If this function's returned promised resolves to an `Error`, this retry will abort with such error. Otherwise if it resolves to a `Success(Noise)`, the retry will continue.\r\n   * \r\n   *   Some usage examples:\r\n   *     - wait longer for later attempts and stop after a limit:\r\n   *     ```haxe\r\n   *     function (info) return switch info.attempt {\r\n   *         case 10: info.error;\r\n   *         case v: Future.delay(v * 1000, Noise);\r\n   *     }\r\n   *     ```\r\n   * \r\n   *     - bail out on error codes that are fatal:\r\n   *     ```haxe\r\n   *     function (info) return switch info.error.code {\r\n   *       case Forbidden : info.error; // in this case new attempts probably make no sense \r\n   *       default: Future.delay(1000, Noise);\r\n   *     }\r\n   *     ```\r\n   * \r\n   *     - and also actually timeout:\r\n   *     ```haxe\r\n   *     // with using DateTools\r\n   *     function (info) return \r\n   *       if (info.elapsed > 2.minutes()) info.error \r\n   *       else Future.delay(1000, Noise);\r\n   *     ```\r\n   * \r\n   * @return Promise<T>\r\n   */\r\n  static public function retry<T>(gen:Void->Promise<T>, next:Next<{ attempt: Int, error:Error, elapsed:Float }, Noise>):Promise<T> {\r\n    function stamp() return haxe.Timer.stamp() * 1000;\r\n    var start = stamp();\r\n    return (function attempt(count:Int) {\r\n      return gen().tryRecover(\r\n        function (error) {\r\n          return next({ attempt: count, error: error, elapsed: stamp() - start })\r\n            .next(function (_) return attempt(count + 1));\r\n        }\r\n      );\r\n    })(1);\r\n  }\r\n  \r\n  #if js\r\n  @:from static public inline function ofJsPromise<A>(promise:JsPromise<A>):Promise<A>\r\n    return Future.ofJsPromise(promise);\r\n  #end\r\n  \r\n  // TODO: investigate why inlining this will cause all kinds of type error all over the place (downstream libraries)\r\n  @:from static function ofSpecific<T, E>(s:Surprise<T, TypedError<E>>):Promise<T>\r\n    return (s : Surprise<T, Error>);\r\n    \r\n  @:from static inline function ofFuture<T>(f:Future<T>):Promise<T>\r\n    return f.map(Success);\r\n    \r\n  @:from static inline function ofOutcome<T>(o:Outcome<T, Error>):Promise<T>\r\n    return Future.sync(o);\r\n    \r\n  @:from static inline function ofError<T>(e:Error):Promise<T>\r\n    return ofOutcome(Failure(e));\r\n\r\n  @:from static inline function ofData<T>(d:T):Promise<T>\r\n    return ofOutcome(Success(d));\r\n    \r\n  public static inline function lazy<T>(p:Lazy<Promise<T>>):Promise<T>\r\n    return Future.async(function(cb) p.get().handle(cb), true);\r\n\r\n  static public function inParallel<T>(a:Array<Promise<T>>, ?concurrency:Int, ?lazy:Bool):Promise<Array<T>> \r\n    return \r\n      if(a.length == 0) Future.sync(Success([]))\r\n      else Future.async(function (cb) {\r\n        var result = [], \r\n            pending = a.length,\r\n            links:CallbackLink = null,\r\n            linkArray = [],\r\n            sync = false,\r\n            i = 0,\r\n            iter = a.iterator(),\r\n            next = null;\r\n            \r\n        function done(o) {\r\n          if (links == null) sync = true;\r\n          else links.cancel();\r\n          cb(o);\r\n        }\r\n\r\n        function fail(e:Error) {\r\n          pending = 0;\r\n          done(Failure(e));\r\n        }\r\n        \r\n        inline function hasNext() {\r\n          return iter.hasNext() && pending > 0;\r\n        }\r\n        \r\n        function set(index, value) {\r\n          result[index] = value;\r\n          if (--pending == 0) \r\n            done(Success(result));\r\n          else if(hasNext())\r\n            next();\r\n        }\r\n        \r\n        next = function() {\r\n          var index = i++;\r\n          linkArray.push(iter.next().handle(function (o) switch o {\r\n            case Success(v): set(index, v);\r\n            case Failure(e): fail(e);\r\n          }));\r\n        }\r\n        \r\n        while(hasNext() && (concurrency == null || concurrency-- > 0)) {\r\n          next();\r\n        }\r\n          \r\n        links = linkArray;\r\n\r\n        if (sync) \r\n          links.cancel();\r\n      }, lazy);\r\n  \r\n  static public function inSequence<T>(a:Array<Promise<T>>):Promise<Array<T>> {\r\n    \r\n    function loop(index:Int):Promise<Array<T>>\r\n      return \r\n        if (index == a.length) [];\r\n        else\r\n          a[index].next(\r\n            function (head) return loop(index+1).next(\r\n              function (tail) return [head].concat(tail)\r\n            )\r\n          );\r\n          \r\n\r\n    return loop(0);\r\n  }\r\n\t\t\t  \r\n  #if (!java || jvm)\r\n  static public function cache<T>(gen:Void->Promise<Pair<T, Future<Noise>>>):Void->Promise<T> {\r\n    var p = null;\r\n    return function() {\r\n      var ret = p;\r\n      if(ret == null) {\r\n        var sync = false;\r\n        ret = gen().next(function(o) {\r\n          o.b.handle(function(_) {\r\n            sync = true;\r\n            p = null;\r\n          });\r\n          return o.a;\r\n        });\r\n        if(!sync) p = ret;\r\n      }\r\n      return ret.map(function(o) {\r\n        if(!o.isSuccess()) p = null;\r\n        return o;\r\n      });\r\n    }\r\n  }\r\n  #end\r\n\t  \r\n  @:noUsing \r\n  static public inline function lift<T>(p:Promise<T>)\r\n    return p;\r\n    \r\n  /**\r\n   *  Creates a new `PromiseTrigger`\r\n   */\r\n  @:noUsing\r\n  static public inline function trigger<A>():PromiseTrigger<A> \r\n    return new PromiseTrigger(); \r\n  \r\n  @:noUsing\r\n  static public inline function resolve<A>(v:A):Promise<A> \r\n    return Future.sync(Success(v));\r\n  \r\n  @:noUsing\r\n  static public inline function reject<A>(e:Error):Promise<A> \r\n    return Future.sync(Failure(e));\r\n}\r\n\r\n@:callable\r\nabstract Next<In, Out>(In->Promise<Out>) from In->Promise<Out> {\r\n      \r\n  @:from static function ofSafe<In, Out>(f:In->Outcome<Out, Error>):Next<In, Out> \r\n    return function (x) return f(x);\r\n    \r\n  @:from static function ofSync<In, Out>(f:In->Future<Out>):Next<In, Out> \r\n    return function (x) return f(x);\r\n    \r\n  @:from static function ofSafeSync<In, Out>(f:In->Out):Next<In, Out> \r\n    return function (x) return f(x);\r\n    \r\n  @:op(a * b) static function _chain<A, B, C>(a:Next<A, B>, b:Next<B, C>):Next<A, C>\r\n    return function (v) return a(v).next(b);\r\n  \r\n}\r\n\r\n@:callable\r\nabstract Recover<T>(Error->Future<T>) from Error->Future<T> {\r\n  @:from static function ofSync<T>(f:Error->T):Recover<T>\r\n    return function (e) return Future.sync(f(e));\r\n}\r\n\r\n@:callable\r\nabstract Combiner<In1, In2, Out>(In1->In2->Promise<Out>) from In1->In2->Promise<Out> {\r\n      \r\n  @:from static function ofSafe<In1, In2, Out>(f:In1->In2->Outcome<Out, Error>):Combiner<In1, In2, Out> \r\n    return function (x1, x2) return f(x1, x2);\r\n    \r\n  @:from static function ofSync<In1, In2, Out>(f:In1->In2->Future<Out>):Combiner<In1, In2, Out> \r\n    return function (x1, x2) return f(x1, x2);\r\n    \r\n  @:from static function ofSafeSync<In1, In2, Out>(f:In1->In2->Out):Combiner<In1, In2, Out> \r\n    return function (x1, x2) return f(x1, x2);\r\n\t\r\n}\r\n\r\n@:forward\r\nabstract PromiseTrigger<T>(FutureTrigger<Outcome<T, Error>>) from FutureTrigger<Outcome<T, Error>> to FutureTrigger<Outcome<T, Error>> {\r\n  public inline function new() this = Future.trigger();\r\n  public inline function resolve(v:T) return this.trigger(Success(v));\r\n  public inline function reject(e:Error) return this.trigger(Failure(e));\r\n  @:to public inline function asPromise():Promise<T> return this.asFuture();\r\n}","package tink.chunk;\r\n\r\nclass ChunkBase {\r\n  var flattened:Array<ByteChunk>;\r\n  public function getCursor() {\r\n    if (flattened == null) \r\n      flatten(this.flattened = []);\r\n    return ChunkCursor.create(flattened.copy());\r\n  }\r\n  public function flatten(into:Array<ByteChunk>) {}\r\n}","package tink.chunk;\r\n\r\nimport haxe.io.Bytes;\r\nimport haxe.io.BytesData;\r\n\r\nclass ByteChunk extends ChunkBase implements ChunkObject {\r\n  //TODO: on JS this pretty much reinvents the wheel\r\n  \r\n  var data:BytesData;\r\n  var from:Int;\r\n  var to:Int;\r\n  \r\n  var wrapped(get, null):Bytes;\r\n    inline function get_wrapped() {\r\n      if (wrapped == null)\r\n        wrapped = Bytes.ofData(data);\r\n      return wrapped;\r\n    }\r\n  \r\n  function new(data, from, to) {\r\n    this.data = data;\r\n    this.from = from;\r\n    this.to = to;\r\n  }\r\n  \r\n  public inline function getByte(index:Int)\r\n    return Bytes.fastGet(data, from + index);\r\n  \r\n  override public function flatten(into:Array<ByteChunk>) \r\n    into.push(this);\r\n  \r\n  public inline function getLength():Int \r\n    return to - from;\r\n  \r\n  public function getSlice(from:Int, to:Int) { \r\n    if (to > this.getLength())\r\n      to = this.getLength();\r\n      \r\n    if (from < 0)\r\n      from = 0;\r\n      \r\n    return\r\n      if (to <= from) null;\r\n      else if (to == this.getLength() && from == 0) this;\r\n      else new ByteChunk(data, this.from + from, to + this.from);\r\n  }\r\n    \r\n  public function slice(from:Int, to:Int):Chunk \r\n    return\r\n      switch getSlice(from, to) {\r\n        case null: Chunk.EMPTY;\r\n        case v: v;\r\n      }\r\n  \r\n  public function blitTo(target:Bytes, offset:Int):Void \r\n    target.blit(offset, wrapped, from, getLength());\r\n  \r\n  public function toBytes():Bytes \r\n    return wrapped.sub(from, getLength());\r\n  \r\n  public function toString():String \r\n    return wrapped.getString(from, getLength());\r\n  \r\n  static public function of(b:Bytes):Chunk {\r\n    if (b.length == 0)\r\n      return Chunk.EMPTY;\r\n    var ret = new ByteChunk(b.getData(), 0, b.length);\r\n    ret.wrapped = b;\r\n    return ret;\r\n  }\r\n  \r\n}","package tink;\r\n\r\nimport haxe.io.Bytes;\r\nimport haxe.io.BytesData;\r\nimport tink.chunk.*;\r\n\r\nprivate class EmptyChunk extends ChunkBase implements ChunkObject {\r\n  public function new() { }\r\n    \r\n  public function getLength()\r\n    return 0;\r\n    \r\n  public function slice(from:Int, to:Int):Chunk\r\n    return this;\r\n    \r\n  public function blitTo(target:Bytes, offset:Int):Void {}\r\n    \r\n  public function toString()\r\n    return '';\r\n    \r\n  public function toBytes()\r\n    return EMPTY;\r\n    \r\n  static var EMPTY = Bytes.alloc(0);\r\n}\r\n\r\nprivate class CompoundChunk extends ChunkBase implements ChunkObject {\r\n  var left:Chunk;\r\n  var right:Chunk;\r\n  \r\n  var split:Int;\r\n  var length:Int;\r\n  \r\n  public function getLength()\r\n    return this.length;\r\n    \r\n  public function new(left:Chunk, right:Chunk) {\r\n    //TODO: try balancing here\r\n    this.left = left;\r\n    this.right = right;\r\n    this.split = left.length;\r\n    this.length = split + right.length;\r\n  }\r\n  \r\n  override public function flatten(into:Array<ByteChunk>) {\r\n    (left:ChunkObject).flatten(into);\r\n    (right:ChunkObject).flatten(into);\r\n  }\r\n    \r\n  public function slice(from:Int, to:Int):Chunk \r\n    return\r\n      left.slice(from, to).concat(right.slice(from - split, to - split));\r\n    \r\n  public function blitTo(target:Bytes, offset:Int):Void {\r\n    left.blitTo(target, offset);\r\n    right.blitTo(target, offset + split);\r\n  }\r\n    \r\n  public function toString() \r\n    return toBytes().toString();\r\n    \r\n  public function toBytes() {\r\n    var ret = Bytes.alloc(this.length);\r\n    blitTo(ret, 0);\r\n    return ret;\r\n  }\r\n  \r\n}\r\n\r\nabstract Chunk(ChunkObject) from ChunkObject to ChunkObject {\r\n  \r\n  public var length(get, never):Int;\r\n    inline function get_length()\r\n      return this.getLength();\r\n      \r\n  public function concat(that:Chunk) \r\n    return switch [length, that.length] {\r\n      case [0, 0]: EMPTY;\r\n      case [0, _]: that;\r\n      case [_, 0]: this;\r\n      case _: new CompoundChunk(this, that);\r\n    }\r\n    \r\n  public inline function cursor()  \r\n    return this.getCursor();\r\n  \r\n  public inline function iterator()\r\n    return new ChunkIterator(this.getCursor());\r\n      \r\n  public inline function slice(from:Int, to:Int):Chunk \r\n    return this.slice(from, to);\r\n    \r\n  public inline function blitTo(target:Bytes, offset:Int)\r\n    return this.blitTo(target, offset);\r\n  \r\n  public inline function toHex()\r\n    return this.toBytes().toHex();\r\n    \r\n  @:to public inline function toString()\r\n    return this.toString();\r\n    \r\n  @:to public inline function toBytes()\r\n    return this.toBytes();\r\n    \r\n  static public function join(chunks:Array<Chunk>)\r\n    return switch chunks {\r\n      case null | []: EMPTY;\r\n      case [v]: v;\r\n      case v:\r\n        var ret = v[0] & v[1];\r\n        for (i in 2...v.length)\r\n          ret = ret & v[i];\r\n        ret;\r\n    }\r\n\r\n  @:from public static inline function ofBytes(b:Bytes):Chunk \r\n    return (ByteChunk.of(b) : ChunkObject);\r\n    \r\n  @:from public static inline function ofString(s:String):Chunk \r\n    return ofBytes(Bytes.ofString(s));\r\n    \r\n  public static function ofHex(s:String):Chunk {\r\n    var length = s.length >> 1;\r\n    var bytes = Bytes.alloc(length);\r\n    for(i in 0...length) bytes.set(i, Std.parseInt('0x' + s.substr(i * 2, 2)));\r\n    return bytes;\r\n  }\r\n    \r\n  @:op(a & b) static function catChunk(a:Chunk, b:Chunk)\r\n    return a.concat(b);\r\n    \r\n  @:op(a & b) static function rcatString(a:Chunk, b:String)\r\n    return catChunk(a, b);\r\n    \r\n  @:op(a & b) static function lcatString(a:String, b:Chunk)\r\n    return catChunk(a, b);\r\n    \r\n  @:op(a & b) static function lcatBytes(a:Bytes, b:Chunk)\r\n    return catChunk(a, b);\r\n    \r\n  @:op(a & b) static function rcatBytes(a:Chunk, b:Bytes)\r\n    return catChunk(a, b);\r\n    \r\n  static public var EMPTY(default, null):Chunk = ((new EmptyChunk() : ChunkObject) : Chunk);//haxe 3.2.1 ¯\\_(ツ)_/¯\r\n}","package tink.http;\n\nimport tink.http.Request;\nimport tink.http.Response;\n\nusing tink.CoreApi;\n\ntypedef HandlerFunction = IncomingRequest->Future<OutgoingResponse>;\n\n@:forward\nabstract Handler(HandlerObject) from HandlerObject to HandlerObject {\n  \n  #if tink_http_middleware\n  public inline function applyMiddleware(m:Middleware)\n    return m.apply(this);\n  #end\n  \n  @:from\n  public static inline function ofFunc(f:HandlerFunction):Handler\n    return new SimpleHandler(f);\n}\n\nclass SimpleHandler implements HandlerObject {\n  var f:HandlerFunction;\n  \n  public function new(f)\n    this.f = f;\n    \n  public function process(req:IncomingRequest):Future<OutgoingResponse>\n    return f(req);\n}\n\ninterface HandlerObject {\n  function process(req:IncomingRequest):Future<OutgoingResponse>;\n}","package server.externs.express;\n\nimport EReg;\n\nabstract Route(Dynamic)\n from String to String\n  {\n \t@:from inline static function fromEReg( e : EReg ) : Route {\n \t\treturn untyped e.r;\n \t}\n}\n","package tink;\n\nusing tink.CoreApi;\nusing StringTools;\n\nabstract Stringly(String) from String to String {\n   \n  static function isNumber(s:String, allowFloat:Bool) {\n    \n    if (s.length == 0) return false;\n    \n    var pos = 0,\n        max = s.length;\n        \n    inline function isDigit(code)\n      return code ^ 0x30 < 10;//a sharp glimpse at the ASCII table revealed this to me\n        \n    inline function digits()\n      while (pos < max && isDigit(s.fastCodeAt(pos))) pos++;\n    \n    inline function allow(code)\n      return \n        if (pos < max && s.fastCodeAt(pos) == code) pos++ > -1;//always true ... not pretty, but generates much simpler code ... check with 3.3 again to see if it can be removed\n        else false;\n    \n    allow('-'.code);\n    \n    if (!allowFloat) {\n      if (allow('0'.code))\n        allow('x'.code);\n    }\n    \n    digits();\n    \n    if (allowFloat && pos < max) {\n      if (allow('.'.code))\n        digits();\n        \n      if (allow('e'.code) || allow('E'.code)) {\n        allow('+'.code) || allow('-'.code);\n        digits();\n      }\n    }\n    \n    return pos == max;\n  }\n    \n  @:to public function toBool()\n    return \n      this != null && switch this.trim().toLowerCase() {\n        case 'false', '0', 'no': false;\n        default: true;\n      }\n    \n  @:to public function parseFloat()\n    return switch this.trim() {\n      case v if (isNumber(v, true)):\n        Success((Std.parseFloat(v) : Float));\n      case v:\n        Failure(new Error(UnprocessableEntity, '$v (encoded as $this) is not a valid float'));\n    }\n  \n  @:to function toFloat()\n    return parseFloat().sure();\n    \n  @:to public function parseInt()\n    return switch this.trim() {\n      case v if (isNumber(v, false)):\n        Success((Std.parseInt(v) : Int));\n      case v:\n        Failure(new Error(UnprocessableEntity, '$v (encoded as $this) is not a valid integer'));\n    }\n        \n  @:to function toInt()\n    return parseInt().sure();\n    \n  \n  // This is a subset of ISO 8601\n  // - Only support full date: so for example '20:00Z' (no date) or '2017-01-01' (no time) are not supported\n  // - timezone indicator must exist, either \"Z\" or \"+00:00\". \"+00\" and \"+0000\" are not supported\n  // - sub-seconds is optional, but must be 3 digits if exists \".000\"\n  static var SUPPORTED_DATE_REGEX = ~/^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2})(\\.\\d{3})?(Z|[\\+-]\\d{2}:\\d{2})$/;\n  \n  @:to public function parseDate() {\n    inline function fail(?pos:haxe.PosInfos) {\n      return Failure(new Error(UnprocessableEntity, '$this is not a valid date' #if !macro, pos #end));\n    }\n    return switch parseFloat() {\n      case Success(f):\n        Success(Date.fromTime(f));\n      case Failure(_): \n        if(!SUPPORTED_DATE_REGEX.match(this)) return fail();\n      #if js\n        var date:Date = untyped __js__('new Date({0})', this);\n        if(Math.isNaN(date.getTime())) fail() else Success(date);\n      #elseif java\n        try {\n          var d = java.javax.xml.bind.DatatypeConverter.parseDateTime(this).getTime();\n          Success(new Date(d.getYear() + 1900, d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds()));\n        } catch(e:Dynamic) \n          fail();\n      #elseif cs\n        try {\n          var s = if(SUPPORTED_DATE_REGEX.matched(2) == null) this else this.substr(0, 23) + '0000' + this.substr(23);\n          var d = cs.system.DateTime.Parse(s, null, cs.system.globalization.DateTimeStyles.None);\n          Success(new Date(d));\n        } catch(e:Dynamic) \n          fail();\n      #elseif php\n        var s = this.replace('Z', '+00:00');\n        var d = DateTime.createFromFormat(if(SUPPORTED_DATE_REGEX.matched(2) == null) 'Y-m-d\\\\TH:i:sP' else 'Y-m-d\\\\TH:i:s.uP', s, new DateTimeZone('UTC'));\n        if(untyped __php__('!{0}', d)) return fail();\n        Success(Date.fromTime(d.getTimestamp() * 1000));\n      #else\n        var s = SUPPORTED_DATE_REGEX.matched(1).split('T');\n        var d = s[0].split('-');\n        var t = s[1].split(':');\n        var y = Std.parseInt(d[0]) - 1970;\n        var m = Std.parseInt(d[1]);\n        var d = Std.parseInt(d[2]);\n        var hh = Std.parseInt(t[0]);\n        var mm = Std.parseInt(t[1]);\n        var ss = Std.parseInt(t[2]);\n        \n        var days = y * 365 + d - 1;\n        days += y < 2 ? 0 : Std.int((y-2) / 4); // leap years\n        var daysOfMonth = [31,28,31,30,31,30,31,31,30,31,30,31];\n        for(m in 0...m-1) days += daysOfMonth[m];\n        if(y >= 2) if((y-2) % 4 != 0 || m >= 3) days ++; // current year is leap and already passed Feb\n        var stamp = days * 86400 + hh * 3600 + mm * 60 + ss;\n        \n        var stamp = stamp + switch SUPPORTED_DATE_REGEX.matched(2) {\n          case null: 0.0;\n          case v: Std.parseInt(v.substr(1)) / 1000;\n        }\n        \n        var stamp = stamp + switch SUPPORTED_DATE_REGEX.matched(3) {\n          case 'Z': 0.0;\n          case v:\n            var positive = v.charCodeAt(0) == '+'.code;\n            var s = v.substr(1).split(':');\n            (Std.parseInt(s[0]) * 3600 + Std.parseInt(s[1]) * 60) * (positive ? -1 : 1);\n        }\n        \n        Success(Date.fromTime(stamp * 1000));\n        \n      #end\n    }\n  }\n  \n  @:to function toDate()\n    return parseDate().sure();\n\n  public function parse<T>(f:Stringly->T)\n    return f.bind(this).catchExceptions();\n      \n  @:from static inline function ofBool(b:Bool):Stringly\n    return if (b) 'true' else 'false';\n    \n  @:from static inline function ofInt(i:Int):Stringly\n    return Std.string(i);  \n    \n  @:from static inline function ofFloat(f:Float):Stringly\n    return Std.string(f);\n    \n  @:from static inline function ofDate(d:Date):Stringly\n    return ofFloat(d.getTime());\n}\n\n#if php\n@:native('DateTime')\nextern class DateTime {\n  static function createFromFormat(format:String, time:String, ?timezone:Dynamic):DateTime;\n  function getTimestamp():Int;\n}\n@:native('DateTimeZone')\nextern class DateTimeZone {\n  function new(s:String);\n}\n#end\n","package tink.chunk;\r\n\r\nimport haxe.ds.Option;\r\nusing haxe.io.Bytes;\r\n\r\nclass ChunkCursor {\r\n  \r\n  var parts:Array<ByteChunk>;\r\n  var curPart:ByteChunk;\r\n  var curPartIndex:Int = 0;\r\n  var curOffset:Int = 0;\r\n  var curLength:Int = 0;\r\n  \r\n  public var length(default, null):Int = 0;\r\n  public var currentPos(default, null):Int = 0;\r\n  public var currentByte(default, null):Int = -1;\r\n  \r\n  static public function create(parts) {\r\n    var ret = new ChunkCursor();\r\n    ret.parts = parts;\r\n    ret.reset();\r\n    return ret;\r\n  }\r\n  \r\n  /**\r\n   *  Creates a cloned cursor\r\n   *  @return cloned cursor\r\n   */\r\n  public function clone() {\r\n    var ret = new ChunkCursor();\r\n    ret.parts = this.parts.copy();\r\n    ret.curPart = this.curPart;\r\n    ret.curPartIndex = this.curPartIndex;\r\n    ret.curOffset = this.curOffset;\r\n    ret.curLength = this.curLength;\r\n    ret.length = this.length;\r\n    ret.currentPos = this.currentPos;\r\n    ret.currentByte = this.currentByte;\r\n    return ret;\r\n  }\r\n\r\n  function new() {}\r\n    \r\n  function reset() {\r\n    length = 0;\r\n    currentPos = 0;\r\n    currentByte = -1;\r\n    curOffset = 0;\r\n    \r\n    for (p in parts)\r\n      length += p.getLength();\r\n    \r\n    this.curPart = parts[this.curPartIndex = 0];\r\n    if (this.curPart != null) {\r\n      this.curLength = this.curPart.getLength();\r\n      this.currentByte = this.curPart.getByte(0);\r\n    }    \r\n  }\r\n  \r\n  /**\r\n   *  Like prune(), but returns the removed chunk\r\n   *  @return Removed chunk (chunk to the left of current position)\r\n   */\r\n  public function flush() {\r\n    var ret = left();\r\n    prune();\r\n    return ret;\r\n  }\r\n\r\n  /**\r\n   *  Remove chunk to the left of current position and reset `currentPos` to zero.\r\n   */\r\n  public inline function prune() \r\n    shift();\r\n\r\n  /**\r\n   *  Add a chunk to the end and reset `currentPos` to zero.\r\n   *  @param chunk - Chunk to be added\r\n   */\r\n  public function add(chunk:Chunk) {\r\n    (chunk : ChunkObject).flatten(parts);//load new data\r\n    reset();\r\n  }\r\n\r\n  /**\r\n   *  Remove data to the left of current position and optionally add a chunk at the end.\r\n   *  Reset `currentPos` to zero.\r\n   *  @param chunk - Optional chunk to be added to the end\r\n   */\r\n  public function shift(?chunk:Chunk) {\r\n\r\n    parts.splice(0, curPartIndex);//throw out all old chunks\r\n    \r\n    switch parts[0] {\r\n      case null:\r\n      case chunk:\r\n        switch chunk.getSlice(curOffset, curLength) {//get rid of old data in current chunk\r\n          case null:\r\n            parts.shift();\r\n          case rest:\r\n            parts[0] = rest;\r\n        }\r\n    }\r\n    \r\n    if (chunk != null)\r\n      add(chunk);\r\n    else\r\n      reset();\r\n  }\r\n\r\n  /**\r\n   *  Clear all data of this cursor\r\n   */\r\n  public function clear() {\r\n    parts = [];\r\n    reset();\r\n  }\r\n\r\n  /**\r\n   *  Return the chunk to the left of current position, excluding current byte\r\n   */\r\n  public function left() {\r\n    if (curPart == null) return Chunk.EMPTY;\r\n    var left = [for (i in 0...curPartIndex) (parts[i]:Chunk)];\r\n    left.push(curPart.slice(0, curOffset));\r\n    return Chunk.join(left);\r\n  }\r\n  \r\n  /**\r\n   *  Return the chunk to the right of current position, including current byte\r\n   */\r\n  public function right() {\r\n    if (curPart == null) return Chunk.EMPTY;\r\n    var right = [for (i in curPartIndex...parts.length) (parts[i]:Chunk)];\r\n    if (right.length > 0) {\r\n      right[0] = curPart.slice(curOffset, curLength);\r\n    }\r\n    return Chunk.join(right);\r\n  }\r\n\r\n  public function seek(seekable:Seekable, ?options: { ?withoutPruning:Bool }):Option<Chunk> {\r\n\r\n    if (curPart == null || seekable == null || seekable.length == 0)\r\n      return None;\r\n\r\n    var max = seekable.length - 1,\r\n        first = seekable[0],\r\n        candidates = [],\r\n        count = 0,\r\n        copy = clone();\r\n    \r\n    copy.shift();\r\n\r\n    function part(b:ByteChunk, offset:Int) @:privateAccess {\r\n      var data = b.data;\r\n      \r\n      for (i in b.from + offset ... b.to) {\r\n        var byte = data.fastGet(i);\r\n\r\n        if (candidates.length > 0) {\r\n          var c = 0;\r\n          while (c < count) {\r\n            var pos = candidates[c];\r\n            if (seekable[pos] == byte) \r\n              if (pos == max) {\r\n                copy.moveBy(i-(b.from + offset) - seekable.length + 1);\r\n                var before = copy.left();\r\n                this.moveBy(before.length + seekable.length);\r\n                switch options {\r\n                  case null | { withoutPruning: false | null }:\r\n                    this.prune();\r\n                  default:\r\n                }\r\n                return Some(before);\r\n              }\r\n              else candidates[c++] = pos + 1;\r\n            else {\r\n              count--;\r\n              var last = candidates.pop();\r\n              if (count > c)\r\n                candidates[c] = last;\r\n            }\r\n\r\n          }\r\n        }\r\n\r\n        if (byte == first)\r\n          count = candidates.push(1);\r\n      }\r\n\r\n      copy.moveBy(b.to - (b.from + offset));\r\n\r\n      return None;\r\n    }\r\n\r\n    switch part(curPart, curOffset) {\r\n      case None: \r\n\r\n        for (i in curPartIndex+1...parts.length)\r\n          switch part(parts[i], 0) {\r\n            case Some(v): return Some(v);\r\n            case None: \r\n          }\r\n\r\n        return None;\r\n      case v: return v;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   *  Like moveBy(), but returns the swept chunk instead of new position\r\n   *  @param len - length to sweep\r\n   *  @return the swept chunk\r\n   */\r\n  public function sweep(len:Int) {\r\n    var data = right().slice(0, len);\r\n    moveBy(len);\r\n    return data;\r\n  }\r\n  \r\n  /**\r\n   *  Like moveTo(), but returns the swept chunk instead of new position\r\n   *  @param pos - target position\r\n   *  @return the swept chunk\r\n   */\r\n  public inline function sweepTo(pos:Int)\r\n    return sweep(pos - currentPos);\r\n  \r\n  /**\r\n   *  Move cursor position by specified amount.\r\n   *  @param delta - amount to move\r\n   *  @return new position\r\n   */\r\n  public inline function moveBy(delta:Int) \r\n    return moveTo(currentPos + delta);\r\n\r\n  /**\r\n   *  Move to specified position.\r\n   *  If `position` is greater than length of cursor, it is set to `length - 1`.\r\n   *  If `position` is less than zero, it is set to zero.\r\n   *  @param position - the position to move to\r\n   *  @return new position\r\n   */\r\n  public function moveTo(position:Int) {\r\n    \r\n    if (length == 0) return 0;\r\n\r\n    if (position > length) position = length - 1;\r\n    if (position < 0) position = 0;\r\n    \r\n    this.currentPos = position;\r\n    \r\n    if (position == length) ffwd();\r\n    else\r\n      for (i in 0...parts.length) {\r\n        var c = parts[i];\r\n        switch c.getLength() {\r\n          case enough if (enough > position):\r\n            this.curPart = c;\r\n            this.curPartIndex = i;\r\n            this.curOffset = position;\r\n            this.curLength = c.getLength();\r\n            this.currentByte = c.getByte(position);\r\n            break;\r\n          case v: \r\n            position -= v;\r\n        }\r\n      }\r\n\r\n    return this.currentPos;\r\n  }\r\n\r\n  function ffwd() {\r\n    currentByte = -1;\r\n    curLength = 0;\r\n    curOffset = 0;\r\n    curPart = null;\r\n    curPartIndex = parts.length;//right?\r\n  }\r\n\r\n  /**\r\n   *  Advance to next byte\r\n   *  @return `false` if there is no next byte\r\n   */\r\n  public function next():Bool {\r\n    if (currentPos == length) return false;\r\n    currentPos++;\r\n    if (currentPos == length) {\r\n      ffwd();\r\n      return false;\r\n    }\r\n    if (curOffset == curLength - 1) {\r\n      curOffset = 0;\r\n      curPart = parts[++curPartIndex];\r\n      curLength = curPart.getLength();\r\n      currentByte = curPart.getByte(0);\r\n    }\r\n    else {\r\n      currentByte = curPart.getByte(++curOffset);\r\n    }\r\n    return true;\r\n  }\r\n}\r\n","package tink.chunk;\r\n\r\nimport haxe.io.Bytes;\r\nimport haxe.io.BytesData;\r\n\r\nclass ChunkIterator {\r\n  \r\n  var target:ChunkCursor;\r\n  var _hasNext:Bool;\r\n  \r\n  public inline function new(target) {\r\n    this.target = target;\r\n    this._hasNext = target.length > target.currentPos;\r\n  }\r\n  \r\n  public inline function hasNext()\r\n    return _hasNext;\r\n    \r\n  public inline function next() {\r\n    var ret = target.currentByte;\r\n    _hasNext = target.next();\r\n    return ret;\r\n  }\r\n}","package tink.chunk;\r\n\r\nimport haxe.io.Bytes;\r\n\r\nabstract Seekable(Array<Int>) {\r\n\r\n  inline function new(a) this = a; \r\n\r\n  public var length(get, never):Int;\r\n    inline function get_length()\r\n      return this.length;\r\n\r\n  @:arrayAccess public inline function get(index:Int)\r\n    return this[index];\r\n  \r\n  @:from static public inline function ofChunk(c:Chunk)\r\n    return ofBytes(c);\r\n  \r\n  @:from static public function ofBytes(b:Bytes)\r\n    return new Seekable([for (i in 0...b.length) b.get(i)]);\r\n\r\n  @:from static public inline function ofString(s:String) \r\n    return ofBytes(Bytes.ofString(s));\r\n}","package tink.core;\n\nprivate typedef AnnexableTo<T> = \n  #if (haxe_ver >= 3.4)\n    haxe.Constraints.Constructible<T->Void>\n  #else\n    { function new(targeT:T):Void; }\n  #end\n\n#if (java || cs) @:dce #end // this make sure the generic method is not genrated\nclass Annex<Target> {\n  \n  var target:Target;\n  var registry:Map<Dynamic, Dynamic>;\n  \n  public function new(target:Target) {\n  \tthis.target = target;\n    this.registry = cast new haxe.ds.ObjectMap();\n  }\n  #if (java || cs) @:extern #end\n  @:generic public inline function get<A:AnnexableTo<Target>>(c:Class<A>):A \n    return switch registry[c] {\n      case null: registry[c] = new A(target);\n   \t  case v: v;\n  \t}\n}","package tink.core;\n\ntypedef Option<T> = haxe.ds.Option<T>;\n\nclass OptionTools {\n  \n  /**\n   *  Extracts the value if the option is `Some`, throws an `Error` otherwise\n   */\n  static public inline function force<T>(o:Option<T>, ?pos:tink.core.Error.Pos)\n    return switch o {\n      case Some(v): \n        v;\n      default: \n        throw new Error(NotFound, 'Some value expected but none found', pos);\n    }\n  \n  /**\n   *  Extracts the value if the option is `Some`, uses the fallback value otherwise\n   */\n  static public inline function or<T>(o:Option<T>, l:Lazy<T>):T\n    return switch o {\n      case Some(v): v;\n      default: l.get();\n    }\n\n  /**\n   *  Extracts the value if the option is `Some`, otherwise `null`\n   */\n  static public inline function orNull<T>(o:Option<T>):Null<T>\n    return switch o {\n      case Some(v): v;\n      default: null;\n    }\n    \n  /**\n   *  Returns `Some(value)` if the option is `Some` and the filter function evaluates to `true`, otherwise `None`\n   */\n  static public inline function filter<T>(o:Option<T>, f:T->Bool):Option<T>\n    return switch o {\n      case Some(f(_) => false): None;\n      default: o;\n    }\n    \n  /**\n   *  Returns `true` if the option is `Some` and the filter function evaluates to `true`, otherwise `false`\n   */\n  static public inline function satisfies<T>(o:Option<T>, f:T->Bool):Bool\n    return switch o {\n      case Some(v): f(v);\n      default: false;\n    }\n    \n  /**\n   *  Returns `true` if the option is `Some` and the value is equal to `v`, otherwise `false`\n   */\n  static public inline function equals<T>(o:Option<T>, v:T):Bool\n    return satisfies(o, function (found) return found == v);\n    \n  /**\n   *  Transforms the option value with a transform function\n   *  Different from `flatMap`, the transform function of `map` returns a plain value\n   */\n  static public inline function map<In, Out>(o:Option<In>, f:In->Out):Option<Out>\n    return switch o {\n      case Some(v): Some(f(v));\n      default: None;\n    }\n    \n  /**\n   *  Transforms the option value with a transform function\n   *  Different from `map`, the transform function of `flatMap` returns an `Option`\n   */\n  static public inline function flatMap<In, Out>(o:Option<In>, f:In->Option<Out>)\n    return switch o {\n      case Some(v): f(v);\n      default: None;\n    }\n    \n  /**\n   *  Creates an iterator from the option.\n   *  The iterator has one item if the option is `Some`, and no items if it is `None`\n   */\n  static public inline function iterator<T>(o:Option<T>) \n    return new OptionIter(o);\n  \n  /**\n   *  Creates an array from the option.\n   *  The array has one item if the option is `Some`, and no items if it is `None`\n   */\n  static public inline function toArray<T>(o:Option<T>) \n    return switch o {\n      case Some(v): [v];\n      default: [];\n    }\n    \n}\n\nclass OptionIter<T> {\n  var value:T;\n  var alive = true;\n  \n  public inline function new(o:Option<T>) \n    switch o {\n      case Some(v): value = v;\n      default: alive = false;\n    }\n    \n  public inline function hasNext()\n    return alive;\n  \n  public inline function next() {\n    alive = false;\n    //TODO: we might want to null the value after usage, but iterators are usually short lived\n    return value;\n  }\n}","package tink.core;\r\n\r\nimport haxe.ds.Option;\r\nimport tink.core.Either;\r\n\r\nenum Outcome<Data, Failure> {//TODO: turn into abstract when this commit is released: https://github.com/HaxeFoundation/haxe/commit/e8715189fc055220f2f33a06c5e1331c96310a88\r\n  Success(data:Data);\r\n  Failure(failure:Failure);\r\n}\r\n\r\nclass OutcomeTools {\r\n  \r\n  /**\r\n   *  Extracts the value if the outcome is `Success`, throws the `Failure` contents otherwise\r\n   */\r\n  static public function sure<D, F>(outcome:Outcome<D, F>):D \r\n    return\r\n      switch (outcome) {\r\n        case Success(data): \r\n          data;\r\n        case Failure(failure): \r\n          switch Error.asError(failure) {\r\n            case null: throw failure;\r\n            case e: e.throwSelf();\r\n          }\r\n      }\r\n  \r\n  /**\r\n   *  Creates an `Option` from this `Outcome`, discarding the `Failure` information\r\n   */\r\n  static public function toOption<D, F>(outcome:Outcome<D, F>):Option<D>\r\n    return \r\n      switch (outcome) {\r\n        case Success(data): Option.Some(data);\r\n        case Failure(_): Option.None;\r\n      }\r\n  \r\n  /**\r\n   *  Creates an `Outcome` from an `Option`, with made-up `Failure` information\r\n   */\r\n  static public function toOutcome<D>(option:Option<D>, ?pos:haxe.PosInfos):Outcome<D, Error>//TODO: this should go into OptionTools in the next major release\r\n    return\r\n      switch (option) {\r\n        case Some(value): \r\n          Success(value);\r\n        case None: \r\n          Failure(new Error(NotFound, 'Some value expected but none found in ' + pos.fileName + '@line ' + pos.lineNumber));\r\n      }\r\n  \r\n  /**\r\n   *  Extracts the value if the option is `Success`, otherwise `null`\r\n   */\r\n  static public function orNull<D, F>(outcome: Outcome<D, F>):Null<D> \r\n    return\r\n      switch (outcome) {\r\n        case Success(data): data;\r\n        case Failure(_): null;\r\n      }    \r\n\r\n  /**\r\n   *  Extracts the value if the option is `Success`, uses the fallback value otherwise\r\n   */\r\n  static public function orUse<D, F>(outcome: Outcome<D, F>, fallback: Lazy<D>):D \r\n    return\r\n      switch (outcome) {\r\n        case Success(data): data;\r\n        case Failure(_): fallback.get();\r\n      }    \r\n  \r\n  /**\r\n   *  Extracts the value if the option is `Success`, uses the fallback `Outcome` otherwise\r\n   */\r\n  static public function orTry<D, F>(outcome: Outcome<D, F>, fallback: Lazy<Outcome<D, F>>):Outcome<D, F> \r\n    return\r\n      switch (outcome) {\r\n        case Success(_): outcome;\r\n        case Failure(_): fallback.get();\r\n      }\r\n  /**\r\n   *   Returns `true` if the outcome is `Some` and the value is equal to `v`, otherwise `false`\r\n   */\r\n  static public function equals<D, F>(outcome:Outcome<D, F>, to: D):Bool \r\n    return \r\n      switch (outcome) {\r\n        case Success(data): data == to;\r\n        case Failure(_): false;\r\n      }\r\n  /**\r\n   *  Transforms the outcome with a transform function\r\n   *  Different from `flatMap`, the transform function of `map` returns a plain value\r\n   */\r\n  static public function map<A, B, F>(outcome:Outcome<A, F>, transform: A->B) \r\n    return \r\n      switch (outcome) {\r\n        case Success(a): \r\n          Success(transform(a));\r\n        case Failure(f): \r\n          Failure(f);\r\n      }\r\n  \r\n  /**\r\n   *  Returns `true` if the outcome is `Success`\r\n   */\r\n  static public function isSuccess<D, F>(outcome:Outcome<D, F>):Bool \r\n    return \r\n      switch outcome {\r\n        case Success(_): true;\r\n        default: false;\r\n      }\r\n  \r\n  \r\n  /**\r\n   *  Transforms the outcome with a transform function\r\n   *  Different from `map`, the transform function of `flatMap` returns an `Outcome`\r\n   */\r\n  static public function flatMap<DIn, FIn, DOut, FOut>(o:Outcome<DIn, FIn>, mapper:OutcomeMapper<DIn, FIn, DOut, FOut>):Outcome<DOut, FOut> {\r\n    return mapper.apply(o);\r\n  }\r\n  \r\n  /**\r\n   *  Like `map` but with a plain value instead of a transform function, thus discarding the orginal result\r\n   */\r\n  static public function swap<A, B, F>(outcome:Outcome<A, F>, v:B)\r\n    return \r\n      switch (outcome) {\r\n        case Success(a): \r\n          Success(v);\r\n        case Failure(f): \r\n          Failure(f);\r\n      }\r\n  \r\n  /**\r\n   *  Try to run `f` and wraps the result in `Success`,\r\n   *  thrown exceptions are transformed by `report` then wrapped into a `Failure`\r\n   */\r\n  static public function attempt<D, F>(f:Void->D, report:Dynamic->F) \r\n    return\r\n      try Success(f())\r\n      catch (e:Dynamic) \r\n        Failure(report(e));\r\n        \r\n  static public function flatten<D, F>(o:Outcome<Outcome<D, F>, F>):Outcome<D, F>\r\n    return switch o {\r\n      case Success(Success(d)): Success(d);\r\n      case Success(Failure(f)) | Failure(f): Failure(f);\r\n    }\r\n}\r\n\r\nprivate abstract OutcomeMapper<DIn, FIn, DOut, FOut>({ f: Outcome<DIn, FIn>->Outcome<DOut, FOut> }) {\r\n  function new(f:Outcome<DIn, FIn>->Outcome<DOut, FOut>) this = { f: f };\r\n  public function apply(o) \r\n    return this.f(o);\r\n    \r\n  @:from static function withSameError<In, Out, Error>(f:In->Outcome<Out, Error>):OutcomeMapper<In, Error, Out, Error> {\r\n    return new OutcomeMapper(function (o)\r\n      return switch o {\r\n        case Success(d): f(d);\r\n        case Failure(f): Failure(f);\r\n      }\r\n    );\r\n  }\r\n  \r\n  @:from static function withEitherError<DIn, FIn, DOut, FOut>(f:DIn->Outcome<DOut, FOut>):OutcomeMapper<DIn, FIn, DOut, Either<FIn, FOut>> {\r\n    return new OutcomeMapper(function (o)\r\n      return switch o {\r\n        case Success(d): \r\n          switch f(d) {\r\n            case Success(d): Success(d);\r\n            case Failure(f): Failure(Right(f));\r\n          }\r\n        case Failure(f): Failure(Left(f));\r\n      }\r\n    );    \r\n  }\r\n}","package tink.core;\r\n\r\n@:pure\r\nabstract Pair<A, B>(MPair<A, B>) {\r\n  \r\n  public var a(get, never):A;\r\n  public var b(get, never):B;\r\n  \r\n  public inline function new(a:A, b:B) this = new MPair(a, b);\r\n  \r\n  inline function get_a():A return this.a;\r\n  inline function get_b():B return this.b;\r\n  \r\n  @:to inline function toBool() \r\n    return this != null;\r\n    \r\n  @:op(!a) public function isNil() \r\n    return this == null;\r\n  \r\n  static public function nil<A, B>():Pair<A, B> \r\n    return null;\r\n}\r\n\r\nclass MPair<A, B> {\r\n  public var a:A;\r\n  public var b:B;\r\n  public function new(a, b) {\r\n    this.a = a;\r\n    this.b = b;\r\n  }\r\n}","package tink.core;\r\n\r\nabstract Ref<T>(haxe.ds.Vector<T>) {\r\n  public var value(get, set):T;\r\n  \r\n  inline function new() this = new haxe.ds.Vector(1);\r\n  \r\n  @:to inline function get_value():T return this[0];\r\n  inline function set_value(param:T) return this[0] = param;\r\n  \r\n  public function toString():String return '@[' + Std.string(value)+']';\r\n  \r\n  @:noUsing @:from static inline public function to<A>(v:A):Ref<A> {\r\n    var ret = new Ref();\r\n    ret.value = v;\r\n    return ret;\r\n  }\r\n}","package tink.core;\r\n\r\nimport tink.core.Callback;\r\nimport tink.core.Noise;\r\n\r\n@:forward\r\nabstract Signal<T>(SignalObject<T>) from SignalObject<T> to SignalObject<T> {\r\n  \r\n  public inline function new(f:Callback<T>->CallbackLink) this = new SimpleSignal(f);\r\n  \r\n  /**\r\n   *  Creates a new signal by applying a transform function to the result.\r\n   *  Different from `flatMap`, the transform function of `map` returns a sync value\r\n   */\r\n  public function map<A>(f:T->A, ?gather = true):Signal<A> {\r\n    var ret = new Signal(function (cb) return this.handle(function (result) cb.invoke(f(result))));\r\n    return\r\n      if (gather) ret.gather();\r\n      else ret;\r\n  }\r\n  \r\n  /**\r\n   *  Creates a new signal by applying a transform function to the result.\r\n   *  Different from `map`, the transform function of `flatMap` returns a `Future`\r\n   */\r\n  public function flatMap<A>(f:T->Future<A>, ?gather = true):Signal<A> {\r\n    var ret = new Signal(function (cb) return this.handle(function (result) f(result).handle(cb)));\r\n    return \r\n      if (gather) ret.gather() \r\n      else ret;\r\n  }\r\n  \r\n  /**\r\n   *  Creates a new signal whose values will only be emitted when the filter function evalutes to `true`\r\n   */\r\n  public function filter(f:T->Bool, ?gather = true):Signal<T> {\r\n    var ret = new Signal(function (cb) return this.handle(function (result) if (f(result)) cb.invoke(result)));\r\n    return\r\n      if (gather) ret.gather();\r\n      else ret;\r\n  }\r\n\r\n  public function select<R>(selector:T->Option<R>, ?gather = true):Signal<R> {\r\n    var ret = new Signal(function (cb) return this.handle(function (result) switch selector(result) {\r\n      case Some(v): cb.invoke(v);\r\n      case None:\r\n    }));\r\n    return\r\n      if (gather) ret.gather();\r\n      else ret;\r\n  }\r\n  \r\n  /**\r\n   *  Creates a new signal by joining `this` and `other`,\r\n   *  the new signal will be triggered whenever either of the two triggers\r\n   */\r\n  public function join(other:Signal<T>, ?gather = true):Signal<T> {\r\n    var ret = new Signal(\r\n      function (cb:Callback<T>):CallbackLink \r\n        return this.handle(cb) & other.handle(cb)\r\n    );\r\n    return\r\n      if (gather) ret.gather();\r\n      else ret;\r\n  }\r\n  \r\n  /**\r\n   *  Gets the next emitted value as a Future\r\n   */\r\n  public function nextTime(?condition:T->Bool):Future<T> {\r\n    var ret = Future.trigger();\r\n    var link:CallbackLink = null,\r\n        immediate = false;\r\n        \r\n    link = this.handle(function (v) if (condition == null || condition(v)) {\r\n      ret.trigger(v);\r\n      if (link == null) immediate = true;\r\n      else link.cancel();\r\n    });\r\n    \r\n    if (immediate) \r\n      link.cancel();\r\n    \r\n    return ret.asFuture();\r\n  }\r\n\r\n  public function until<X>(end:Future<X>):Signal<T> {\r\n    var ret = new Suspendable(\r\n      function (yield) return this.handle(yield)\r\n    );\r\n    end.handle(ret.kill);\r\n    return ret;\r\n  }\r\n\r\n  @:deprecated(\"use nextTime instead\")\r\n  public inline function next(?condition:T->Bool):Future<T>\r\n    return nextTime(condition);\r\n  \r\n  /**\r\n   *  Transforms this signal and makes it emit `Noise`\r\n   */\r\n  public function noise():Signal<Noise>\r\n    return map(function (_) return Noise);\r\n  \r\n  /**\r\n   *  Creates a new signal which stores the result internally.\r\n   *  Useful for tranformed signals, such as product of `map` and `flatMap`,\r\n   *  so that the transformation function will not be invoked for every callback\r\n   */\r\n  public function gather():Signal<T> {\r\n    var ret = trigger();\r\n    this.handle(function (x) ret.trigger(x));\r\n    return ret.asSignal();\r\n  }\r\n  \r\n  static public function generate<T>(generator:(T->Void)->Void):Signal<T> {\r\n    var ret = trigger();\r\n    generator(ret.trigger);\r\n    return ret;\r\n  }\r\n\r\n  /**\r\n   *  Creates a new `SignalTrigger`\r\n   */\r\n  static public function trigger<T>():SignalTrigger<T>\r\n    return new SignalTrigger();\r\n\r\n  static public inline function create<T>(create:(T->Void)->(Void->Void)):Signal<T>\r\n    return new Suspendable<T>(create);\r\n    \r\n  /**\r\n   *  Creates a `Signal` from classic signals that has the semantics of `addListener` and `removeListener`\r\n   *  Example: `var signal = Signal.ofClassical(emitter.addListener.bind(eventType), emitter.removeListener.bind(eventType));`\r\n   */\r\n  static public function ofClassical<A>(add:(A->Void)->Void, remove:(A->Void)->Void, ?gather = true) {\r\n    var ret = new Signal(function (cb:Callback<A>) {\r\n      var f = function (a) cb.invoke(a);\r\n      add(f);\r\n      return remove.bind(f);\r\n    });\r\n    \r\n    return\r\n      if (gather) ret.gather();\r\n      else ret;\r\n  }\r\n}\r\n\r\nprivate class SimpleSignal<T> implements SignalObject<T> {\r\n  var f:Callback<T>->CallbackLink;\r\n  public inline function new(f) this.f = f;\r\n  public inline function handle(cb) return this.f(cb);\r\n}\r\n\r\nprivate class Suspendable<T> implements SignalObject<T> {\r\n  var trigger:SignalTrigger<T> = new SignalTrigger();\r\n  var activate:(T->Void)->(Void->Void);\r\n  var suspend:Void->Void;\r\n  var check:CallbackLink;\r\n  \r\n  public var killed(default, null):Bool = false;\r\n\r\n  public function kill()\r\n    if (!killed) {\r\n      killed = true;\r\n      trigger = null;\r\n    }\r\n\r\n  public function new(activate) {\r\n    this.activate = activate;\r\n  }\r\n\r\n  public function handle(cb) {\r\n    if (killed) return null;\r\n    if (trigger.getLength() == 0) \r\n      this.suspend = activate(trigger.trigger);\r\n    \r\n    return \r\n      trigger.handle(cb) \r\n      & function ()\r\n          if (trigger.getLength() == 0) {\r\n            suspend();\r\n            suspend = null;\r\n          }\r\n  }\r\n}\r\n\r\nclass SignalTrigger<T> implements SignalObject<T> {\r\n  var handlers = new CallbackList<T>();\r\n  public inline function new() {} \r\n    \r\n  /**\r\n   *  Emits a value for this signal\r\n   */\r\n  public inline function trigger(event:T)\r\n    handlers.invoke(event);\r\n    \r\n  /**\r\n   *  Gets the number of handlers registered\r\n   */\r\n  public inline function getLength()\r\n    return handlers.length;\r\n\r\n  public inline function handle(cb) \r\n    return handlers.add(cb);\r\n\r\n  /**\r\n   *  Clear all handlers\r\n   */\r\n  public inline function clear()\r\n    handlers.clear();\r\n    \r\n  @:to public inline function asSignal():Signal<T> \r\n    return this;\r\n}\r\n\r\ninterface SignalObject<T> {\r\n  /**\r\n   *  Registers a callback to be invoked every time the signal is triggered\r\n   *  @return A `CallbackLink` instance that can be used to unregister the callback\r\n   */\r\n  function handle(handler:Callback<T>):CallbackLink;\r\n}","package tink.http;\n\nimport tink.streams.Stream;\nimport tink.io.StreamParser;\nimport tink.io.Transformer;\nimport tink.Chunk;\nimport tink.chunk.*;\n\nusing StringTools;\nusing tink.CoreApi;\nusing tink.io.Source;\n\nclass Chunked {\n\tstatic var _encoder:ChunkedEncoder<Dynamic>;\n\tstatic var _decoder:ChunkedDecoder<Dynamic>;\n\t\n\tpublic static function encoder<Q>():ChunkedEncoder<Q> {\n\t\tif(_encoder == null) _encoder = new ChunkedEncoder();\n\t\treturn cast _encoder;\n\t}\n\t\n\tpublic static function decoder<Q>():ChunkedDecoder<Q> {\n\t\tif(_decoder == null) _decoder = new ChunkedDecoder();\n\t\treturn cast _decoder;\n\t}\n\t\n\tpublic static inline function encode<Q>(source:Source<Q>):Source<Q>\n\t\treturn encoder().transform(source);\n\t\t\n\tpublic static inline function decode<Q>(source:Source<Q>):RealSource\n\t\treturn decoder().transform(source);\n}\n\nclass ChunkedEncoder<Q> implements Transformer<Q, Q> {\n\tpublic function new() {}\n\t\n\tpublic function transform(source:Source<Q>):Source<Q> {\n\t\treturn source.chunked()\n\t\t\t.map(function(chunk:tink.Chunk) return '${chunk.length.hex()}\\r\\n' & chunk & '\\r\\n')\n\t\t\t.append([Chunk.ofString('0\\r\\n')].iterator());\n\t}\n}\n\nclass ChunkedDecoder<Q> implements Transformer<Q, Error> {\n\tpublic function new() {}\n\t\n\tpublic function transform(source:Source<Q>):RealSource {\n\t\treturn (\n\t\t\t(source:RealSource).parseStream(new ChunkedParser())\n\t\t\t\t.map(function(v) return v == null ? Chunk.EMPTY : v)\n\t\t\t:Stream<Chunk, Error>\n\t\t);\n\t}\n}\n\nclass ChunkedParser implements StreamParserObject<Chunk> {\n\t\n\tstatic var LINEBREAK:Seekable = '\\r\\n';\n\tvar chunkSize:Int;\n\t\n\tpublic function new() {\n\t\treset();\n\t}\n\t\n\tfunction reset()\n\t\tchunkSize = -1;\n\t\n\tpublic function progress(cursor:ChunkCursor):ParseStep<Chunk> {\n\t\treturn\n\t\t\tif(chunkSize < 0) {\n\t\t\t\tswitch cursor.seek(LINEBREAK) {\n\t\t\t\t\tcase Some(v): chunkSize = Std.parseInt('0x$v');\n\t\t\t\t\tcase None: // do nothing\n\t\t\t\t}\n\t\t\t\tProgressed;\n\t\t\t} else if(chunkSize == 0) {\n\t\t\t\tProgressed;\n\t\t\t} else {\n\t\t\t\tif(cursor.length >= chunkSize + 2)\n\t\t\t\t\tswitch cursor.seek(LINEBREAK) {\n\t\t\t\t\t\tcase Some(v): reset(); Done(v);\n\t\t\t\t\t\tcase None: Failed(new Error('Invalid encoding'));\n\t\t\t\t\t}\n\t\t\t\telse Progressed;\n\t\t\t}\n\t}\n\t\n\tpublic function eof(rest:ChunkCursor):Outcome<Chunk, Error> {\n\t\treturn chunkSize == 0 ? Success(Chunk.EMPTY) : Failure(new Error('Unexpected end of input'));\n\t}\n\t\n\t\n\t\n}","package tink.io;\n\nimport tink.chunk.ChunkCursor;\nimport tink.io.PipeOptions;\nimport tink.io.Sink;\nimport tink.streams.Stream;\nimport tink.streams.RealStream;\n\nusing tink.CoreApi;\n\nenum ParseStep<Result> {\n  Progressed;\n  Done(r:Result);\n  Failed(e:Error);\n}\n\nenum ParseResult<Result, Quality> {\n  Parsed(data:Result, rest:Source<Quality>):ParseResult<Result, Quality>;\n  Invalid(e:Error, rest:Source<Quality>):ParseResult<Result, Quality>;\n  Broke(e:Error):ParseResult<Result, Error>;\n}\n\n\nabstract StreamParser<Result>(StreamParserObject<Result>) from StreamParserObject<Result> to StreamParserObject<Result> {\n  static function doParse<R, Q, F>(source:Stream<Chunk, Q>, p:StreamParserObject<R>, consume:R->Future<{ resume: Bool }>, finish:Void->F):Future<ParseResult<F, Q>> {\n    var cursor = Chunk.EMPTY.cursor();\n    var resume = true;\n    function mk(source:Source<Q>) {\n      return if(cursor.currentPos < cursor.length)\n        source.prepend(cursor.right());\n      else\n        source;\n    }\n      \n    function flush():Source<Q>\n      return switch cursor.flush() {\n        case c if(c.length == 0): cast Source.EMPTY;\n        case c: c;\n      }\n      \n    return source.forEach(function (chunk:Chunk):Future<Handled<Error>> {\n      if(chunk.length == 0) return Future.sync(Resume); // TODO: review this fix\n      cursor.shift(chunk);\n      \n      return Future.async(function(cb) {\n        function next() {\n          cursor.shift();\n          var lastPos = cursor.currentPos;\n          switch p.progress(cursor) {\n            case Progressed:\n              if(lastPos != cursor.currentPos && cursor.currentPos < cursor.length) next() else cb(Resume);\n            case Done(v): \n              consume(v).handle(function (o) {\n                resume = o.resume;\n                if (resume) {\n                  if(lastPos != cursor.currentPos && cursor.currentPos < cursor.length) next() else cb(Resume);\n                } else\n                  cb(Finish);\n              });\n            case Failed(e): \n              cb(Clog(e));\n          }\n        }\n        next();\n      });\n    }).flatMap(function (c) return switch c {\n      case Halted(rest):\n        Future.sync(Parsed(finish(), mk(rest)));\n      case Clogged(e, rest):\n        Future.sync(Invalid(e, mk(rest)));\n      case Failed(e):\n        Future.sync(Broke(e));\n      case Depleted if(cursor.currentPos < cursor.length): \n        Future.sync(Parsed(finish(), mk(Chunk.EMPTY)));\n      case Depleted if(!resume):\n        Future.sync(Parsed(finish(), flush()));\n      case Depleted:\n        switch p.eof(cursor) {\n          case Success(result):\n            consume(result).map(function (_) return Parsed(finish(), flush()));\n          case Failure(e):\n            Future.sync(Invalid(e, flush()));\n        }     \n    });\n  }\n  static public function parse<R, Q>(s:Source<Q>, p:StreamParser<R>):Future<ParseResult<R, Q>> {\n    var res = null;\n    function onResult(r) {\n      res = r;\n      return Future.sync({ resume: false });\n    }\n    return doParse(s, p, onResult, function () return res);\n  }\n  \n  static public function parseStream<R, Q>(s:Source<Q>, p:StreamParser<R>):RealStream<R> {\n    return Generator.stream(function next(step) {\n      if(s.depleted)\n        step(End);\n      else \n        parse(s, p).handle(function(o) switch o {\n          case Parsed(result, rest):\n            s = rest;\n            step(Link(result, Generator.stream(next)));\n          case Invalid(e, _) | Broke(e): step(Fail(e));\n      });\n    });\n  }\n}\n\nclass Splitter extends BytewiseParser<Option<Chunk>> {\n  var delim:Chunk;\n  var buf = Chunk.EMPTY;\n  public function new(delim) {\n    this.delim = delim;\n  }\n  override function read(char:Int):ParseStep<Option<Chunk>> {\n    \n    if(char == -1) return Done(None);\n    \n    buf = buf & String.fromCharCode(char);\n    return if(buf.length >= delim.length) {\n      var bcursor = buf.cursor();\n      bcursor.moveBy(buf.length - delim.length);\n      var dcursor = delim.cursor();\n      \n      for(i in 0...delim.length) {\n        if(bcursor.currentByte != dcursor.currentByte) {\n          return Progressed;\n        }\n        else {\n          bcursor.next();\n          dcursor.next();\n        }\n      }\n      var out = Done(Some(buf.slice(0, bcursor.currentPos - delim.length)));\n      buf = Chunk.EMPTY;\n      return out;\n      \n    } else {\n      \n      Progressed;\n      \n    }\n  }\n}\n\nclass SimpleBytewiseParser<Result> extends BytewiseParser<Result> {\n  \n  var _read:Int->ParseStep<Result>;\n\n  public function new(f)\n    this._read = f;\n\n  override public function read(char:Int)\n    return _read(char); \n}\n\nclass BytewiseParser<Result> implements StreamParserObject<Result> { \n\n  function read(char:Int):ParseStep<Result> {\n    return throw 'abstract';\n  }\n  \n  public function progress(cursor:ChunkCursor) {\n    \n    do switch read(cursor.currentByte) {\n      case Progressed:\n      case Done(r): \n        cursor.next();\n        return Done(r);\n      case Failed(e):\n        return Failed(e);\n    } while (cursor.next());\n    \n    return Progressed;\n  }\n  \n  public function eof(rest:ChunkCursor) \n    return switch read( -1) {\n      case Progressed: Failure(new Error(UnprocessableEntity, 'Unexpected end of input'));\n      case Done(r): Success(r);\n      case Failed(e): Failure(e);\n    }\n  \n  \n}\n\ninterface StreamParserObject<Result> {\n  function progress(cursor:ChunkCursor):ParseStep<Result>;\n  function eof(rest:ChunkCursor):Outcome<Result, Error>;\n}","package tink.http;\n\n@:enum abstract Method(String) to String {\n  var GET = 'GET';\n  var HEAD = 'HEAD';\n  var OPTIONS = 'OPTIONS';\n  \n  var POST = 'POST';\n  var PUT = 'PUT';\n  var PATCH = 'PATCH';\n  var DELETE = 'DELETE';\n  \n  static public function ofString(s:String, fallback:String->Method)\n    return switch s.toUpperCase() {\n      case 'GET': GET;\n      case 'HEAD': HEAD;\n      case 'OPTIONS': OPTIONS;\n      case 'POST': POST;\n      case 'PUT': PUT;\n      case 'PATCH': PATCH;\n      case 'DELETE': DELETE;\n      case v: fallback(v); \n    }\n}","package tink.http;\n\nimport haxe.io.Bytes;\nimport tink.io.Sink;\n\nusing tink.io.Source;\nusing tink.CoreApi;\n\ntypedef StructuredBody = Array<Named<BodyPart>>;\n\nenum BodyPart {\n  Value(v:String);\n  File(handle:UploadedFile);\n}\n\n@:forward\nabstract UploadedFile(UploadedFileBase) from UploadedFileBase to UploadedFileBase {\n  static public function ofBlob(name:String, type:String, data:Bytes):UploadedFile\n    return {\n      fileName: name,\n      mimeType: type,\n      size: data.length,\n      read: function():RealSource return data,\n      saveTo: function(path:String) {\n        var name = 'File sink $path';\n        var dest:RealSink = \n          #if (nodejs && !macro)\n            Sink.ofNodeStream(name, js.node.Fs.createWriteStream(path))\n          #elseif sys\n            Sink.ofOutput(name, sys.io.File.write(path))\n          #else\n            throw 'not implemented'\n          #end\n        ;\n        return (data : IdealSource).pipeTo(dest, { end: true } ).map(function (r) return switch r {\n          case AllWritten: Success(Noise);\n          case SinkEnded(_, _): Failure(new Error(\"File $path closed unexpectedly\"));\n          case SinkFailed(e, _): Failure(e);\n        });\n      }\n    }\n}\n\ntypedef UploadedFileBase = {\n  \n  var fileName(default, null):String;\n  var mimeType(default, null):String;\n  var size(default, null):Int;\n  \n  /**\n   *  Read the uploaded file as Source\n   *  @return RealSource\n   */\n  function read():RealSource;\n  \n  /**\n   *  Save the uploaded file to the specified location\n   */\n  function saveTo(path:String):Promise<Noise>;\n}","package tink.io;\n\nprivate typedef Data = {\n  ?end:Bool,\n  ?destructive:Bool,\n}\n\nabstract PipeOptions(Data) from Data to Data { \n  \n  public var end(get, never):Bool;\n    inline function get_end()\n      return this != null && this.end;\n      \n  public var destructive(get, never):Bool;\n    inline function get_destructive()\n      return this != null && this.destructive;\n      \n}","package tink.io;\n\nimport tink.streams.Stream;\n\nusing tink.CoreApi;\n\nenum PipeResult<In, Out, Result> {\n  AllWritten:PipeResult<In, Out, Result>;\n  SinkEnded(result:Result, rest:Source<In>):PipeResult<In, Out, Result>;\n  SinkFailed(e:Error, rest:Source<In>):PipeResult<In, Error, Result>;\n  SourceFailed(e:Error):PipeResult<Error, Out, Result>;\n}\n\nclass PipeResultTools {\n  \n  /**\n   * Transform PipeResult to an Outcome of Bool, indicating the source is completely written or not\n   */\n  static public function toOutcome<EIn, FailingWith, Result>(result:PipeResult<EIn, FailingWith, Result>):Outcome<Bool, Error> {\n    return switch result {\n      case AllWritten: Success(true);\n      case SinkEnded(_): Success(false);\n      case SinkFailed(e, _) | SourceFailed(e): Failure(e);\n    }\n  }\n  \n  \n  static public function toResult<EIn, FailingWith, Result>(c:Conclusion<Chunk, FailingWith, EIn>, result:Result, ?buffered:Chunk):PipeResult<EIn, FailingWith, Result> {\n\n    function mk(s:Source<EIn>)\n      return switch buffered {\n        case null: s;\n        case v: s.prepend(v);\n      }\n\n    return switch c {\n      case Failed(e): SourceFailed(e);\n      case Clogged(e, rest): SinkFailed(e, mk(rest));\n      case Depleted: AllWritten;\n      case Halted(rest): SinkEnded(result, mk(rest));      \n    }\n  }  \n}","package tink.io;\n\nusing tink.CoreApi;\n\nabstract Worker(WorkerObject) from WorkerObject to WorkerObject {\n  \n  static public var EAGER(default, null):Worker = new EagerWorker();\n  static var pool:Array<Worker> = \n    #if (tink_runloop && !macro)\n      [for (i in 0...#if concurrent 16 #else 1 #end) tink.RunLoop.current.createSlave()]\n    #else\n      [EAGER]\n    #end\n  ;\n  \n  public function ensure()\n    return if (this == null) get() else this;\n    \n  static public function get() \n    return pool[Std.random(pool.length)];\n    \n  public function work<A>(task:Lazy<A>):Future<A>\n    return this.work(task);\n  \n  #if (tink_runloop && !macro)\n  @:from static function ofRunLoopWorker(worker):Worker\n    return (new RunLoopWorker(worker) : WorkerObject);\n  #end\n}\n\nprivate class EagerWorker implements WorkerObject {\n  \n  public function new() { }\n  \n  public function work<A>(task:Lazy<A>):Future<A>\n    return Future.sync(task.get());    \n}\n\n#if (tink_runloop && !macro)\nprivate class RunLoopWorker implements WorkerObject {\n  \n  var actualWorker:tink.runloop.Worker;\n  \n  public function new(actualWorker)\n    this.actualWorker = actualWorker;\n  \n  public function work<A>(task:Lazy<A>):Future<A> {\n    return \n      actualWorker.owner.delegate(task, actualWorker);\n  }\n}\n#end\n\ninterface WorkerObject {\n  function work<A>(task:Lazy<A>):Future<A>;\n}","package tink.io.js;\n\nimport haxe.io.Bytes;\nimport js.html.*;\nimport tink.streams.Stream;\n\nusing tink.CoreApi;\n\nclass BlobSource extends Generator<Chunk, Error> {\n  var name:String;\n  \n  function new(name:String, blob:Blob, pos:Int, chunkSize:Int) {\n    this.name = name;\n    \n    super(Future.async(function (cb) {\n      if(pos >= blob.size) {\n        cb(End);\n      } else {\n        var end = pos + chunkSize;\n        if(end > blob.size) end = blob.size;\n        \n        var reader = new FileReader();\n        reader.onload = function() {\n          var chunk:Chunk = Bytes.ofData(reader.result);\n          cb(Link(chunk, new BlobSource(name, blob, end, chunkSize)));\n        }\n        reader.onerror = function(e:js.Error) cb(Fail(Error.ofJsError(e)));\n        reader.readAsArrayBuffer(blob.slice(pos, end));\n      }\n    }, true));\n  }\n  \n  static inline public function wrap(name, blob, chunkSize)\n    return new BlobSource(name, blob, 0, chunkSize);\n  \n}","package tink.io.nodejs;\n\nimport haxe.io.Bytes;\nimport js.node.Buffer;\nimport tink.chunk.*;\n\nclass WrappedBuffer implements ChunkObject {\n  \n  public var buffer:Buffer;\n  \n  public function new(buffer) {\n    this.buffer = buffer;\n  }\n  \n  public function getCursor():ChunkCursor\n    return (toBytes() : Chunk).cursor();\n    \n  public function flatten(into)\n    ((toBytes() : Chunk) : ChunkObject).flatten(into);\n    \n  public function getLength():Int\n    return buffer.length;\n    \n  public function slice(from:Int, to:Int):Chunk\n    return new WrappedBuffer(buffer.slice(from, to));\n  \n  public function toString():String\n    return buffer.toString();\n    \n  public function toBytes():Bytes {\n    var copy = alloc(buffer.length);\n    buffer.copy(copy);\n    return copy.hxToBytes();\n  }\n\n  static var alloc:Int->Buffer = \n    if (untyped __js__('\"allocUnsafe\" in Buffer')) Buffer.allocUnsafe;\n    else function (size) return new Buffer(size);\n    \n  public function blitTo(target:Bytes, offset:Int):Void\n    return buffer.copy(Buffer.hxFromBytes(target), offset);\n  \n  \n}","package tink.io.std;\n\nimport haxe.io.*;\nimport tink.streams.Stream;\nusing tink.CoreApi;\n\nclass InputSource extends Generator<Chunk, Error> {\n  public function new(name:String, target:Input, worker:Worker, buf:Bytes, offset:Int) {\n    \n    function next(buf, offset) \n      return new InputSource(name, target, worker, buf, offset);\n\n    var free = buf.length - offset;\n\n    super(Future.async(function (cb) {\n      worker.work(function () {\n        return try {\n          var read = target.readBytes(buf, offset, free);\n          \n          if (read == 0) \n            Link(tink.Chunk.EMPTY, next(buf, offset));\n          else {\n\n            var nextOffset = \n              if (free - read < 0x400) 0;\n              else offset + read;\n\n            var nextBuf = \n              if (nextOffset == 0) Bytes.alloc(buf.length);\n              else buf;\n\n            Link(\n              (buf:Chunk).slice(offset, offset + read),\n              next(nextBuf, nextOffset)\n            );\n          }\n        }\n        catch (e:haxe.io.Eof) {\n          End;\n        }\n        catch (e:haxe.io.Error) \n          switch e {\n            case Blocked: \n              Link(tink.Chunk.EMPTY, next(buf, offset));\n            #if (neko || cpp)\n            case Custom(v) if(Std.string(v) == #if neko 'ssl@ssl_recv' #elseif cpp 'ssl_recv' #end):\n              End; // FIXME: remove this case when issue resolved: https://github.com/HaxeFoundation/haxe/issues/6244\n            #end\n            default: \n              Fail(Error.withData('Failed to read from $name', e));\n          }\n      }).handle(function (step) {\n        switch step {\n          case End | Fail(_):\n            try target.close()\n            catch (e:Dynamic) {}\n          default:\n        }\n        cb(step);\n      });\n    }, true));\n  }\n}","package tink.io.std;\n\nimport haxe.io.*;\nimport tink.streams.Stream;\n\nusing tink.io.PipeResult;\nusing tink.CoreApi;\n\nclass OutputSink extends tink.io.Sink.SinkBase<Error, Noise> {\n  var name:String;\n  var target:Output;\n  var worker:Worker;\n  \n  public function new(name, target, worker) {\n    this.name = name;\n    this.target = target;\n    this.worker = worker;\n  }\n\n  override public function consume<EIn>(source:Stream<Chunk, EIn>, options:PipeOptions):Future<PipeResult<EIn, Error, Noise>> {\n    var rest = Chunk.EMPTY;\n\n    var ret = source.forEach(function (c:Chunk) return Future.async(function (cb) {\n      \n      var pos = 0,\n          bytes = c.toBytes();\n\n      function write() {\n        if (pos == bytes.length) cb(Resume);\n        else this.worker.work(\n          function () \n            return try {\n              Success(target.writeBytes(bytes, pos, bytes.length - pos));\n            }\n            catch (e:haxe.io.Eof) {\n              Success(-1);\n            }\n            catch (e:haxe.io.Error) switch e {\n              case Blocked: Success(0);\n              default: Failure(Error.withData('Error writing to $name', e));\n            }\n            catch (e:Error) {\n              Failure(e);\n            }\n            catch (e:Dynamic) {\n              Failure(Error.withData('Error writing to $name', e));\n            }\n        ).handle(function (o) switch o {\n          case Success(-1): \n            rest = (bytes:Chunk).slice(pos, bytes.length);\n            cb(Finish);\n          case Success(v):\n            pos += v;\n            if (pos == bytes.length) cb(Resume);\n            else write();\n          case Failure(e):\n            cb(Clog(e)); \n        });\n      }\n\n      write();\n    }));\n    \n    if (options.end)\n      ret.handle(function (end) try target.close() catch (e:Dynamic) {});    \n    \n    return ret.map(function (c) return c.toResult(Noise, rest));    \n  }\n} ","package tink.json;\n\n#if tink_json_compact_code\nabstract Char(String) from String to String {\n\n  @:from macro static function ofAny(i:Int) \n    return macro $v{String.fromCharCode(i)};\n  \n  public inline function toString()\n    return this;\n}\n#else\nabstract Char(Int) from Int to Int {\n  public inline function toString() \n    return String.fromCharCode(this);\n}\n#end","package tink.json;\n\nabstract Representation<T>(T) {\n\n  public function get():T\n    return this;\n  \n  public inline function new(v:T) \n    this = v;\n  \n  static public function of<A>(v:Representation<A>) \n    return v;\n}","package tink.json;\n\nusing tink.CoreApi;\n\n@:genericBuild(tink.json.macros.Macro.buildWriter())\nclass Writer<T> {}\n\n#if !macro\n@:build(tink.json.macros.Macro.compact())\n#end\nclass BasicWriter {\n  public var plugins(default, null):Annex<BasicWriter>;\n\n  var buf:StringBuf;\n  \n  function new() \n    this.plugins = new Annex(this);\n\n  function init() {\n    buf = new StringBuf();\n  }\n  \n  inline function output(s:String) \n    buf.add(s);\n    \n  inline function char(c:Char)\n    buf.addChar(c);\n    \n  inline function writeInt(v:Int)\n    output(Std.string(v));\n    \n  inline function writeFloat(v:Float)\n    output(Std.string(v));\n    \n  inline function writeBool(b:Bool)\n    output(if (b) 'true' else 'false');\n    \n  inline function writeString(s:String) \n    output(StdWriter.stringify(s));\n  \n  function writeDynamic(value:Dynamic) \n    output(StdWriter.stringify(value));\n  \n  function writeValue(value:Value)\n    switch value {\n      case VNumber(f): writeFloat(f);\n      case VString(s): writeString(s);\n      case VNull: output('null');\n      case VBool(b): output(if (b) 'true' else 'false');\n      case VArray([]): output('[]');\n      case VArray(a): \n        \n        char('['.code);\n        writeValue(a[0]);\n        \n        for (i in 1...a.length) {\n          char(','.code);\n          writeValue(a[i]);\n        }\n        char(']'.code);\n        \n      case VObject([]): output('{}');\n      case VObject(a):\n      \n        char('{'.code);\n        \n        inline function write(p:tink.core.Named<Value>) {\n          writeString(p.name);\n          char(':'.code);\n          writeValue(p.value);\n        }\n        write(a[0]);\n        for (i in 1...a.length) {\n          char(','.code);\n          write(a[i]);\n        }\n        \n        char('}'.code);      \n      \n    }\n}\n\n#if js\n@:forward(toString)\nprivate abstract StringBuf(String) {\n  \n  public inline function new() \n    this = '';\n    \n  public inline function addChar(c:Char) \n    this += c.toString();\n    \n  public inline function add(s:String)\n    this += s;\n}\n\n@:native(\"JSON\")\nextern private class StdWriter {\n  static function stringify(v:Dynamic):String;\n}\n#else\nprivate class StdWriter {\n  static public inline function stringify(v:Dynamic):String\n    return haxe.format.JsonPrinter.print(v);\n}\n#end\n","package tink.json.macros;\n\nimport haxe.macro.Context;\nimport haxe.macro.Expr;\nimport haxe.macro.Type;\nimport haxe.ds.Option;\nimport tink.macro.BuildCache;\n\nimport tink.typecrawler.*;\n\nusing haxe.macro.Tools;\nusing StringTools;\nusing tink.MacroApi;\n\nclass Macro {\n  \n  static function compact(?prefix:String = '', ?fields:Array<Field>) {\n    #if tink_json_compact_code\n    if (fields == null)\n      fields = Context.getBuildFields();\n    for (i in 0...fields.length) {\n      var f = fields[i];\n\n      var meta = {\n        name: ':native',\n        params: [macro $v{prefix + i.shortIdent()}],\n        pos: f.pos,\n      }\n      switch f.meta {\n        case null: f.meta = [meta];\n        case v: v.push(meta);\n      }\n    }      \n    return fields;\n    #else\n    return null;\n    #end\n  }\n    \n  static public function nativeName(f:FieldInfo)\n    return\n      switch f.meta.filter(function (m) return m.name == ':json') {\n        case []: f.name;\n        case [{ params: [name] }]: name.getName().sure();\n        case [v]: v.pos.error('@:json must have exactly one parameter');\n        case v: v[1].pos.error('duplicate @:json metadata not allowed on a single field');\n      }    \n  \n  static function getType(name) \n    return \n      switch Context.getLocalType() {\n        case TInst(_.toString() == name => true, [v]):\n          v;\n        default:\n          throw 'assert';\n      }      \n\n  static public function buildParser():Type\n    return BuildCache.getType('tink.json.Parser', parser);\n\n  static public function nameNiladic(c:EnumField)\n    return\n      switch c.meta.extract(':json') {\n        case []: c.name;\n        case [{ params:[{ expr: EConst(CString(v)) }]}]: v;\n        case v: c.pos.error('invalid use of @:json');\n      }\n  \n\n  static function parser(ctx:BuildContext):TypeDefinition {\n    var name = ctx.name,\n        ct = ctx.type.toComplex();\n        \n    var cl = macro class $name extends tink.json.Parser.BasicParser {\n      public function new() super();\n    } \n    \n    function add(t:TypeDefinition)\n      cl.fields = cl.fields.concat(t.fields);\n      \n    var ret = Crawler.crawl(ctx.type, ctx.pos, GenReader.inst);\n    \n    cl.fields = cl.fields.concat(ret.fields);  \n    \n    add(macro class { \n      public function parse(source):$ct @:pos(ret.expr.pos) {\n        this.init(source);\n        return ${ret.expr};\n      }\n      public function tryParse(source)\n        return tink.core.Error.catchExceptions(function () return parse(source));\n    });\n\n    compact('p', cl.fields);\n    return cl;\n  }\n\n  static public function buildWriter():Type\n    return BuildCache.getType('tink.json.Writer', writer);\n      \n  static function writer(ctx:BuildContext):TypeDefinition {\n    var name = ctx.name,\n        ct = ctx.type.toComplex();\n        \n    var cl = macro class $name extends tink.json.Writer.BasicWriter {\n      public function new() super();\n    } \n    \n    var ret = Crawler.crawl(ctx.type, ctx.pos, GenWriter.inst);\n    \n    cl.fields = cl.fields.concat(ret.fields);\n    \n    function add(t:TypeDefinition)\n      cl.fields = cl.fields.concat(t.fields);\n    \n    add(macro class { \n      public function write(value:$ct):tink.json.Serialized<$ct> {\n        this.init();\n        ${ret.expr};\n        return cast this.buf.toString();\n      }\n    });\n    compact('w', cl.fields);\n    return cl;\n  }\n  \n  static public function getRepresentation(t:Type, pos:Position) {\n\n    switch t.reduce() {\n      case TDynamic(null) | TMono(_): return None;\n      default: \n    }\n    var ct = t.toComplex({ direct: true });\n    \n    return\n      switch (macro tink.json.Representation.of((null : $ct)).get()).typeof() {\n        case Success(rep):\n          \n          var rt = rep.toComplex();\n          \n          if (!(macro ((null : tink.json.Representation<$rt>) : $ct)).typeof().isSuccess()) \n            pos.error('Cannot represent ${t.toString()} in JSON because ${(macro : tink.json.Representation<$rt>).toString()} cannot be converted to ${t.toString()}');\n          \n          Some(rep);\n          \n        default:\n          None;\n      }\n  }\n  \n  static public function shouldSerialize(f:ClassField) \n    return \n      !f.meta.has(':transient') \n      && switch f.kind {\n        case FVar(AccNever | AccCall, AccNever | AccCall):\n          f.meta.has(':isVar');\n        case FVar(_, _): true;\n        default: false;\n      }  \n}\n","package tink.json.macros;\n\nimport haxe.ds.Option;\nimport haxe.macro.Type;\nimport haxe.macro.Expr;\nimport tink.typecrawler.FieldInfo;\nimport tink.typecrawler.Generator;\n\nusing haxe.macro.Tools;\nusing tink.MacroApi;\n\nclass GenWriter extends GenBase {\n  static public var inst(default, null) = new GenWriter();\n\n  function new() {\n    super(':jsonStringify');\n  }\n\n  public function wrap(placeholder:Expr, ct:ComplexType):Function\n    return placeholder.func(['value'.toArg(ct)], false);\n    \n  public function nullable(e) \n    return macro if (value == null) this.output('null') else $e;\n    \n  public function string() \n    return macro this.writeString(value);\n    \n  public function int() \n    return macro this.writeInt(value);\n    \n  public function float() \n    return macro this.writeFloat(value);\n    \n  public function bool() \n    return macro this.writeBool(value);\n    \n  public function date() \n    return macro this.writeFloat(value.getTime());\n    \n  public function bytes() \n    return macro this.writeString(haxe.crypto.Base64.encode(value));\n    \n  public function map(k, v)               \n    return macro {\n      this.char('['.code);\n      var first = true;\n      for (k in value.keys()) {\n        if (first)\n          first = false;\n        else\n          this.char(','.code);\n          \n        this.char('['.code);\n        {\n          var value = k;\n          $k;\n        }\n        \n        this.char(','.code);\n        {\n          var value = value.get(k);\n          $v;\n        }\n        \n        this.char(']'.code);\n      }\n      this.char(']'.code);  \n    }\n    \n  public function anon(fields:Array<FieldInfo>, ct) \n    return if(fields.length == 0)\n      macro this.output('{}');\n    else {\n      fields = fields.copy();\n      fields.sort(function (a, b)\n        return switch [a.optional, b.optional] {\n          case [false, true]: -1;\n          case [true, false]: 1;\n          case [x, y]: Reflect.compare(a.name, b.name);\n        }\n      );\n      \n      var hasMandatory = !fields[0].optional;\n      if (!hasMandatory) macro {\n        var __first = true;\n        \n        this.char('{'.code);\n        $b{[for (f in fields) {\n          var name = f.name,\n              field = '\"${Macro.nativeName(f)}\":';\n            \n          function write(value, expr) \n            return macro {\n              if (__first)\n                __first = false;\n              else\n                this.char(','.code);\n              this.output($v{field});\n              var value = $value;\n              $expr;\n            }\n          \n          switch f.type.reduce() {\n            case TEnum(_.get() => {name: 'Option', pack: ['haxe', 'ds']}, [t]):\n              macro switch @:privateAccess value.$name {\n                case null | None:\n                case Some(v): ${write(macro v, f.as(t))};\n              }\n            default:\n              macro switch @:privateAccess value.$name {\n                case null:\n                case v: ${write(macro @:privateAccess value.$name, f.expr)};\n              }\n            }\n        }]};\n        this.char('}'.code);\n      }\n      else macro {\n        var __first = true;\n        this.char('{'.code);\n        \n        $b{[for (f in fields) {\n          var name = f.name,\n              field = '\"${Macro.nativeName(f)}\":';\n\n          var write = macro {\n            if(__first) __first = false;\n            else this.char(','.code);\n            this.output($v{field});\n            ${f.expr};\n          }\n          \n          switch f.type.reduce() {\n            case TEnum(_.get() => {name: 'Option', pack: ['haxe', 'ds']}, [t]):\n              macro switch @:privateAccess value.$name {\n                case null | None:\n                case Some(value):\n                  if(__first) __first = false;\n                  else this.char(','.code);\n                  this.output($v{field});\n                  ${f.as(t)};\n              }\n            default:\n              if (f.optional)\n                macro switch @:privateAccess value.$name {\n                  case null:\n                  case value: $write;\n                }\n              else \n                macro {\n                  var value = @:privateAccess value.$name;\n                  $write;\n                }\n          }\n        }]};\n        this.char('}'.code);\n      };\n    }\n\n  public function array(e) \n    return macro {\n      this.char('['.code);\n      var first = true;\n      for (value in value) {\n        if (first)\n          first = false;\n        else\n          this.char(','.code);\n        $e;\n      }\n      this.char(']'.code);  \n    };\n    \n  public function enm(constructors:Array<EnumConstructor>, ct, _, _) {\n    var cases = [];\n    for (c in constructors) {\n      var cfields = c.fields,\n          inlined = c.inlined,\n          c = c.ctor,\n          name = c.name,\n          postfix = '}',\n          first = true;      \n      cases.push(\n        if (c.type.reduce().match(TEnum(_,_))) \n          {\n            values: [macro $i{name}],\n            expr: (macro this.output($v{haxe.format.JsonPrinter.print(Macro.nameNiladic(c))})),\n          }\n        else {\n          var prefix = \n            switch c.meta.extract(':json') {\n              case []:\n                \n                postfix = '}}';\n                '{\"$name\":{';\n                \n              case [{ params:[{ expr: EObjectDecl(obj) }] }]:                \n                \n                first = false;\n                var ret = haxe.format.JsonPrinter.print(ExprTools.getValue(EObjectDecl(obj).at()));\n                ret.substr(0, ret.length - 1);\n\n              default:\n                c.pos.error('invalid use of @:json');\n            } \n            \n          var args = \n            if (inlined) [macro value]\n            else [for (f in cfields) macro $i{f.name}];\n          \n          {\n            values: [macro @:pos(c.pos) ${args.length == 0 ? macro $i{name} : macro $i{name}($a{args})}],\n            expr: macro {\n              this.output($v{prefix});\n              $b{[for (f in cfields) {\n                var fname = f.name;\n                macro {\n                  this.output($v{'${if (first) { first = false; \"\"; } else \",\"}\"${f.name}\"'});\n                  this.char(':'.code);\n                  {\n                    var value = ${\n                      if (inlined)\n                        macro value.$fname\n                      else\n                        macro $i{f.name}\n                    }\n                    ${f.expr};\n                  }\n                }\n              }]}\n              this.output($v{postfix});\n            },\n          };            \n        }    \n      );\n    }\n    return ESwitch(macro (value:$ct), cases, null).at();\n  }\n  \n  public function enumAbstract(names:Array<Expr>, e:Expr, ct:ComplexType, pos:Position):Expr {\n    return macro @:pos(pos) {\n      var value = cast value;\n      $e;\n    }\n  }\n  \n  public function dyn(e, ct) \n    return macro {\n      var value:haxe.DynamicAccess<$ct> = value;\n      $e;\n    }\n    \n  public function dynAccess(e)\n    return macro {\n      var first = true;\n          \n      this.char('{'.code);\n      for (k in value.keys()) {\n        if (first)\n          first = false;\n        else\n          this.char(','.code);\n          \n        this.writeString(k);\n        this.char(':'.code);\n        {\n          var value = value.get(k);\n          $e;\n        }\n        \n      }\n      this.char('}'.code);\n    }\n    \n  override public function rescue(t:Type, pos:Position, gen:GenType):Option<Expr>\n    return \n      switch t.reduce() {\n        \n        case TInst(_.get() => { isInterface: true }, _):\n          \n          pos.error('Interfaces cannot be stringified. ');\n        \n        case TInst(_.get() => cl, params):\n          //TODO: this should be handled by converting the class to an anonymous type and handing that off to `gen`\n          var a = new Array<FieldInfo>();\n          \n          for (f in cl.fields.get()) \n            if (Macro.shouldSerialize(f)) {\n              var ft = f.type.applyTypeParameters(cl.params, params);\n              a.push(new FieldInfo({ name: f.name, pos: f.pos, type: ft }, gen, false, f.meta.get()));\n            }\n          \n          Some(anon(a, t.toComplex()));\n          \n        default:\n          super.rescue(t, pos, gen);             \n      }    \n      \n  public function reject(t:Type) \n    return 'Cannot stringify ${t.toString()}';\n\n  override function processRepresentation(pos:Position, actual:Type, representation:Type, value:Expr):Expr {\n    var ct = representation.toComplex();\n    return macro @:pos(pos) {\n      var value = (value : tink.json.Representation<$ct>).get();\n      $value;\n    }\n  }\n\n  override function processDynamic(pos:Position):Expr\n    return macro @:pos(pos) this.writeDynamic(value);\n\n  override function processValue(pos:Position):Expr\n    return macro @:pos(pos) this.writeValue(value);\n\n  override function processSerialized(pos:Position):Expr\n    return macro @:pos(pos) this.output(value);\n\n  override function processCustom(c:CustomRule, original:Type, gen:Type->Expr):Expr {\n    var original = original.toComplex();\n    return switch c {\n      case WithClass(writer):\n        var path = writer.toString().asTypePath();\n        var rep = (macro @:pos(writer.pos) { var f = null; new $path(null).prepare((f():$original)); }).typeof().sure();\n        \n        return macro @:pos(writer.pos) {\n          var value = this.plugins.get($writer).prepare(value);\n          ${gen(rep)};\n        }    \n      case WithFunction(e):\n        //TODO: the two cases look suspiciously similar\n        var rep = (macro @:pos(e.pos) { var f = null; $e((f():$original)); }).typeof().sure();\n        return macro @:pos(e.pos) {\n          var value = $e(value);\n          ${gen(rep)};\n        }    \n    }\n  }\n\n  override public function drive(type:Type, pos:Position, gen:Type->Position->Expr):Expr\n    return\n      switch type.reduce() {\n        case TEnum(_.get().module => 'haxe.ds.Either', [left, right]):\n          var lct = left.toComplex();\n          var rct = right.toComplex();\n          macro @:pos(pos) switch value {\n            case Left(v): this.output(tink.Json.stringify((v:$lct)));\n            case Right(v): this.output(tink.Json.stringify((v:$rct)));\n          }\n        default: super.drive(type, pos, gen);\n      }\n}\n","package;\n\n@:observable typedef Result = {\n    slideshow:{\n        title:String,\n        author:String,\n        date:String,\n        slides:Array<{\n            title:String,\n            type:String,\n            ?items:Array<String>,\n        }>,\n    }\n}\n","package tink.querystring;\n\nimport tink.url.*;\nusing tink.CoreApi;\n\nabstract Pairs<T>(Iterator<Named<T>>) from Iterator<Named<T>> to Iterator<Named<T>> {\n  \n  @:from static function portions(s:String):Pairs<Portion>\n    return (Query.parseString(s) : Iterator<Named<Portion>>);\n    \n  @:from static function portionsOfUrl(u:Url):Pairs<Portion>\n    return portions(u.query);\n    \n  @:from static function ofIterable<T>(i:Iterable<Named<T>>):Pairs<T>\n    return i.iterator();\n \n}","package tink.streams;\n\nimport tink.streams.Stream;\n\nusing tink.CoreApi;\n\n@:forward\nabstract IdealStream<Item>(Stream<Item, Noise>) from Stream<Item, Noise> to Stream<Item, Noise> {\n  @:from\n  public static inline function promiseOfIdealStream<Item>(p:Promise<IdealStream<Item>>):IdealStream<Item>\n    return cast Stream.promise(p);\n  \n  @:from\n  public static inline function promiseOfStreamNoise<Item>(p:Promise<Stream<Item, Noise>>):IdealStream<Item>\n    return cast Stream.promise(p);\n    \n  public function collect():Future<Array<Item>> {\n    var buf = [];\n    return this.forEach(function(x) {\n      buf.push(x);\n      return Resume;\n    }).map(function(c) return buf);\n  }\n}\n\ntypedef IdealStreamObject<Item> = StreamObject<Item, Noise>;\n\nclass IdealStreamBase<Item> extends StreamBase<Item, Noise> {\n  override public function idealize(rescue:Error->Stream<Item,Noise>):IdealStream<Item> \n    return this;\n}","package tink.streams;\n\nimport tink.streams.Stream;\n\nusing tink.CoreApi;\n\n@:forward\nabstract RealStream<Item>(Stream<Item, Error>) from Stream<Item, Error> to Stream<Item, Error> {\n  @:from\n  public static inline function promiseOfIdealStream<Item>(p:Promise<IdealStream<Item>>):RealStream<Item>\n    return cast Stream.promise(p);\n  \n  @:from\n  public static inline function promiseOfStreamNoise<Item>(p:Promise<Stream<Item, Noise>>):RealStream<Item>\n    return cast Stream.promise(p);\n    \n  @:from\n  public static inline function promiseOfRealStream<Item>(p:Promise<RealStream<Item>>):RealStream<Item>\n    return cast Stream.promise(p);\n  \n  @:from\n  public static inline function promiseOfStreamError<Item>(p:Promise<Stream<Item, Error>>):RealStream<Item>\n    return cast Stream.promise(p);\n  \n  public function collect():Promise<Array<Item>> {\n    var buf = [];\n    return this.forEach(function(x) {\n      buf.push(x);\n      return Resume;\n    }).map(function(c) return switch c {\n\t\tcase Depleted: Success(buf);\n\t\tcase Failed(e): Failure(e);\n\t\tcase Halted(_): throw 'unreachable';\n\t});\n  }\n}\ntypedef RealStreamObject<Item> = StreamObject<Item, Error>;\ntypedef RealStreamBase<Item> = StreamBase<Item, Error>;","package tink.url;\n\n/**\n * Represents inline authentication data, e.g. `http://user:password@somehost.tld/...`\n * May be accessed when null.\n */\nabstract Auth(String) {\n  public var user(get, never):Null<String>;\n  public var password(get, never):Null<String>;\n\n  public inline function new(user:String, password:String)\n    this = '$user:$password';\n      \n  inline function get_user()\n    return\n      if (this == null) null;\n      else this.split(':')[0];\n\n  inline function get_password()\n    return\n      if (this == null) null;\n      else this.split(':')[1];\n\n  @:to public inline function toString():String\n    return if (this == null) '' else '$this@';\n    \n}","package tink.url;\n\n@:forward\nabstract PortionArray(Array<Portion>) from Array<Portion> to Array<Portion> {\n\t@:to\n\tpublic function toStringArray()\n\t\treturn [for(p in this) p.toString()];\n}","package tink.web;\n\nimport tink.http.Message;\nimport tink.http.Response;\n\ntypedef TypedResponse<T> = Message<ResponseHeader, T>;\n\n@:forward\nabstract Response<T>(TypedResponse<T>) {\n\tpublic inline function new(header, body)\n\t\tthis = new Message(header, body);\n\t\n\t@:to\n\tpublic inline function getData():T\n\t\treturn this.body;\n}","package tink.web.forms;\n\nimport tink.http.StructuredBody;\nimport tink.http.Request;\nimport tink.Stringly;\n\nabstract FormField(BodyPart) from BodyPart to BodyPart {\n  public function getValue():Stringly \n    return switch this {\n      case Value(v): v;\n      case File(_): throw 'expected plain value but received file';\n    }\n    \n  @:to function toFloat():Float\n    return getValue();\n    \n  @:to function toInt():Int\n    return getValue();    \n    \n  @:to function toString():String\n    return getValue();\n    \n  @:to public function getFile():FormFile \n    return switch this {\n      case Value(_): throw 'expected file but got plain value';\n      case File(u): @:privateAccess new FormFile(u);\n    }\n  \n}","package tink.web.forms;\n\nimport haxe.io.Bytes;\nimport tink.chunk.ByteChunk;\nimport tink.json.Representation;\nimport tink.http.StructuredBody;\n\nusing tink.io.Source;\nusing tink.CoreApi;\n\ntypedef JsonFileRep = Representation<{\n  mimeType:String,\n  fileName:String,\n  content:Bytes,\n}>;\n\n@:forward\nabstract FormFile(UploadedFile) {\n  \n  inline function new(v) this = v;\n\n  @:to function toJson():JsonFileRep {\n    return new Representation({\n      fileName: this.fileName,\n      mimeType: this.mimeType,\n      content: {\n        var src = this.read();\n        var chunk = null;\n        var write = src.all().handle(function(c) chunk = c.sure());\n        if(chunk != null) \n          chunk.toBytes();\n        else {\n          write.dissolve();\n          throw new Error(NotImplemented, 'Can only upload files through JSON backed by with sync sources but got a $src');\n        }\n      }\n    });\n  }\n  \n  @:from static function ofJson(rep:JsonFileRep):FormFile {\n    var data = rep.get();\n    return new FormFile(ofBlob(data.fileName, data.mimeType, data.content));\n  }\n  \n  static inline public function ofBlob(name:String, type:String, data:Bytes):UploadedFile \n    return UploadedFile.ofBlob(name, type, data);\n}","package tink.web.routing;\n\nimport haxe.io.Bytes;\nimport httpstatus.HttpStatusCode;\nimport tink.http.Response;\nimport tink.http.Header;\n\n@:forward\nabstract Response(OutgoingResponse) from OutgoingResponse to OutgoingResponse {\n  \n  @:from static function ofString(s:String):Response \n    return textual('text/plain', s);\n  \n  @:from static function ofBytes(b:Bytes):Response \n    return binary('application/octet-stream', b);\n    \n  #if tink_template\n  @:from static function ofHtml(h:tink.template.Html)\n    return textual('text/html', h);\n  #end\n  \n  @:from static function ofUrl(u:tink.Url):Response {\n    return new OutgoingResponse(new ResponseHeader(Found, Found, [new HeaderField('location', u)]), Chunk.EMPTY);\n  }\n\n  static public function binary(?code, contentType:String, bytes:Bytes, ?headers):Response {\n    //TODO: calculate ETag\n    return OutgoingResponse.blob(code, bytes, contentType, headers);\n  }\n  \n  static public function empty(?code = OK):Response {\n    return new OutgoingResponse(new ResponseHeader(code, code, [new HeaderField(CONTENT_LENGTH, '0')]), Chunk.EMPTY);\n  }\n    \n  static public function textual(?code, contentType:String, string:String, ?headers):Response\n    return binary(code, contentType, Bytes.ofString(string), headers);\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi extern class String {\n\tvar length(default,null) : Int;\n\n\t@:pure function new(string:String) : Void;\n\t@:pure function toUpperCase() : String;\n\t@:pure function toLowerCase() : String;\n\t@:pure function charAt( index : Int) : String;\n\t@:pure function indexOf( str : String, ?startIndex : Int ) : Int;\n\t@:pure function lastIndexOf( str : String, ?startIndex : Int ) : Int;\n\t@:pure function split( delimiter : String ) : Array<String>;\n\t@:pure function toString() : String;\n\t@:pure function substring( startIndex : Int, ?endIndex : Int ) : String;\n\n\t@:pure inline function charCodeAt( index : Int) : Null<Int> {\n\t\treturn @:privateAccess HxOverrides.cca(this, index);\n\t}\n\n\t@:pure inline function substr( pos : Int, ?len : Int ) : String {\n\t\treturn @:privateAccess HxOverrides.substr(this, pos, len);\n\t}\n\n\t@:pure static inline function fromCharCode( code : Int ) : String {\n\t\treturn untyped __define_feature__('String.fromCharCode', js.Syntax.code(\"String.fromCodePoint({0})\", code));\n\t}\n\n\tstatic function __init__() : Void {\n\t\tuntyped __feature__('String.fromCharCode', js.Syntax.code(\"if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }\"));\n\t}\n\n}\n"],
"names":[],
"mappings":"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"
}