// Generated by Haxe TypeScript Declaration Generator :)

export namespace tink.core {
	export interface SignalObject<T> {
	}
}

export namespace tink.state._State {
	export interface StateObject<T> {
		set(value: T): void;
	}
}

export namespace tink.core {
	export class MPair<A, B> {
		constructor(a: A, b: B);
		a: A;
		b: B;
	}
}

export namespace tink.core._Callback {
	export interface LinkObject {
		cancel(): void;
	}
}

export namespace tink.core._Future {
	export interface FutureObject<T> {
		flatMap<R>(f: (arg0: T) => tink.core._Future.FutureObject<R>): tink.core._Future.FutureObject<R>;
		/**
		 *  Registers a callback to handle the future result.
		 *  If the result is already available, the callback will be invoked immediately.
		 *  @return A `CallbackLink` instance that can be used to cancel the callback, no effect if the callback is already invoked
		 */
		handle(callback: (arg0: T) => void): tink.core._Callback.LinkObject;
		/**
		 *  Caches the result to ensure the underlying tranform is performed once only.
		 *  Useful for tranformed futures, such as product of `map` and `flatMap`
		 *  so that the transformation function will not be invoked for every callback
		 */
		gather(): tink.core._Future.FutureObject<T>;
	}
}

export namespace tink.state {
	export interface ObservableObject<T> {
		poll(): tink.core.MPair<T,tink.core._Future.FutureObject<any>>;
	}
}

export namespace tink.core {
	export class TypedError<T> {
		private constructor();
	}
}

export namespace client.data {
	export class TodoItemModel {
		constructor(init: {completed?: boolean, created?: Date, description: string});
		readonly completed: boolean;
		readonly description: string;
		readonly created: Date;
		readonly updatePerformed: tink.core.SignalObject<{}>;
		observables: {completed: tink.state._State.StateObject<boolean>, created: tink.state.ObservableObject<Date>, description: tink.state._State.StateObject<string>, isInTransition: tink.state.ObservableObject<boolean>};
		transitionErrors: tink.core.SignalObject<tink.core.TypedError<any>>;
		readonly isInTransition: boolean;
		static isActive(item: client.data.TodoItemModel): boolean;
		static isCompleted(item: client.data.TodoItemModel): boolean;
		static create(description: string): client.data.TodoItemModel;
	}
}

export namespace tink.core {
	export class NamedWith<N, V> {
		constructor(name: N, value: V);
		readonly name: N;
		readonly value: V;
	}
}

export namespace client.data {
	export class TodoFilterStore {
		constructor();
		currentFilter: (arg0: client.data.TodoItemModel) => boolean;
		mapOptions<A>(cb: (fo: tink.core.NamedWith<string,(arg0: client.data.TodoItemModel) => boolean>) => A): A[];
		toggle(filter: (arg0: client.data.TodoItemModel) => boolean): tink.core._Future.FutureObject<any>;
		isActive(filter: (arg0: client.data.TodoItemModel) => boolean): boolean;
		matches(store: client.data.TodoItemStore): boolean;
	}
}

export namespace client.data {
	export class TodoItemStore {
		constructor(item: client.data.TodoItemModel);
		item: client.data.TodoItemModel;
		completed: boolean;
		description: string;
		created: Date;
		setCompleted(val: boolean): void;
		setDescription(val: string): void;
		isActive(): boolean;
		isCompleted(): boolean;
		static create(description: string): client.data.TodoItemStore;
		static wrap(item: client.data.TodoItemModel): client.data.TodoItemStore;
	}
}

export namespace tink.pure {

}

export namespace tink.pure._List {
	export class Node<T> {
		constructor(length: number, value: T, tails?: tink.pure._List.Node<T>[]);
		readonly length: number;
		readonly value: T;
		readonly tails: tink.pure._List.Node<T>[];
		filter(f: (arg0: T) => tink.pure.FilterResult): tink.pure._List.Node<T>;
		static EMPTY: any[];
	}
}

export namespace client.data {
	export class TodoListModel {
		constructor(init: {items?: tink.pure._List.Node<client.data.TodoItemModel>});
		add(description: string): tink.core._Future.FutureObject<any>;
		delete(item: client.data.TodoItemModel): tink.core._Future.FutureObject<any>;
		clearCompleted(): tink.core._Future.FutureObject<any>;
		get_items(): tink.pure._List.Node<client.data.TodoItemModel>;
		get_unfinished(): number;
		get_hasAnyCompleted(): boolean;
		observables: {hasAnyCompleted: tink.state.ObservableObject<boolean>, isInTransition: tink.state.ObservableObject<boolean>, items: tink.state.ObservableObject<tink.pure._List.Node<client.data.TodoItemModel>>, unfinished: tink.state.ObservableObject<number>};
		transitionErrors: tink.core.SignalObject<tink.core.TypedError<any>>;
		get_isInTransition(): boolean;
		get_updatePerformed(): tink.core.SignalObject<{items?: tink.pure._List.Node<client.data.TodoItemModel>}>;
	}
}

export namespace client.data {
	export class TodoListStore {
		constructor();
		items: client.data.TodoItemStore[];
		length: number;
		unfinished: number;
		hasAnyCompleted: boolean;
		get_items(): client.data.TodoItemStore[];
		add(description: string): void;
		delete(store: client.data.TodoItemStore): void;
		clearCompleted(): void;
	}
}